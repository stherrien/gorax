# GitHub Secrets Configuration Template
#
# This file documents all required secrets for the gorax repository.
# DO NOT commit actual secret values to version control.
#
# To add secrets:
#   Via GitHub UI: Settings → Secrets and variables → Actions → New secret
#   Via GitHub CLI: gh secret set SECRET_NAME --body "value"
#
# Last updated: 2026-01-02

# ============================================================
# REPOSITORY SECRETS
# ============================================================
# These secrets are available to all workflows

repository_secrets:
  # Codecov Integration (Optional)
  # Used by: .github/workflows/ci.yml
  CODECOV_TOKEN:
    description: "Token for uploading test coverage to Codecov"
    required: false
    how_to_obtain: |
      1. Go to https://codecov.io
      2. Sign in with GitHub
      3. Add repository: gorax
      4. Copy the upload token from repository settings
    example: "abc123def456ghi789jkl012mno345pqr678"
    rotation_schedule: "Every 180 days or when compromised"

  # GitHub Token (Built-in)
  # Automatically provided by GitHub Actions
  GITHUB_TOKEN:
    description: "Automatic token for GitHub Actions (built-in)"
    required: true
    how_to_obtain: "Automatically provided - no setup needed"
    example: "N/A - automatic"
    notes: |
      - Scoped to repository
      - Expires after workflow run
      - Cannot be rotated manually

# ============================================================
# STAGING ENVIRONMENT SECRETS
# ============================================================
# These secrets are only available when using the 'staging' environment

staging_environment_secrets:
  # Staging Environment URL
  STAGING_URL:
    description: "Base URL for staging environment"
    required: true
    how_to_obtain: "Your staging deployment URL"
    example: "https://staging.gorax.dev"

  # Staging Database Password
  STAGING_DB_PASSWORD:
    description: "PostgreSQL database password for staging"
    required: true
    how_to_obtain: |
      Generate strong password:
        openssl rand -base64 32
    example: "xK9mP2vL8qR4nT6wY3hJ5sD7fG1aE0zC"
    rotation_schedule: "Every 90 days"
    security_notes: |
      - Minimum 16 characters
      - Use mix of uppercase, lowercase, numbers, special chars
      - Do not reuse production password

  # Staging Redis Password
  STAGING_REDIS_PASSWORD:
    description: "Redis password for staging environment"
    required: false
    how_to_obtain: |
      Generate strong password:
        openssl rand -base64 24
    example: "aB3cD5eF7gH9iJ1kL2mN4oP6qR8s"
    rotation_schedule: "Every 90 days"

  # Staging Health Check Token
  STAGING_HEALTH_CHECK_TOKEN:
    description: "Bearer token for health check endpoints in staging"
    required: false
    how_to_obtain: |
      Generate random token:
        openssl rand -hex 32
    example: "Bearer sk_staging_1234567890abcdef"
    rotation_schedule: "Every 180 days"

# ============================================================
# PRODUCTION ENVIRONMENT SECRETS
# ============================================================
# These secrets are only available when using the 'production' environment

production_environment_secrets:
  # Production Environment URL
  PRODUCTION_URL:
    description: "Base URL for production environment"
    required: true
    how_to_obtain: "Your production deployment URL"
    example: "https://gorax.dev"

  # Production Database Password
  PRODUCTION_DB_PASSWORD:
    description: "PostgreSQL database password for production"
    required: true
    how_to_obtain: |
      Generate strong password:
        openssl rand -base64 48
    example: "yZ8nW6tV4rP2qO0mL1kJ3hG5fD7cB9aE8xU6sR4qP2oN0mK1jI3h"
    rotation_schedule: "Every 90 days"
    security_notes: |
      - Minimum 32 characters for production
      - Use cryptographically secure random generation
      - Store backup in secure vault (1Password, Vault, etc.)
      - Never log or print this value

  # Production Redis Password
  PRODUCTION_REDIS_PASSWORD:
    description: "Redis password for production environment"
    required: false
    how_to_obtain: |
      Generate strong password:
        openssl rand -base64 32
    example: "cC1dD3eE5fF7gG9hH1iI3jJ5kK7lL9m"
    rotation_schedule: "Every 90 days"

  # Health Check Token
  HEALTH_CHECK_TOKEN:
    description: "Bearer token for health check endpoints"
    required: true
    how_to_obtain: |
      Generate random token:
        openssl rand -hex 48
    example: "Bearer sk_prod_1234567890abcdef1234567890abcdef"
    rotation_schedule: "Every 180 days"
    security_notes: |
      - Used for external monitoring
      - Should have read-only health check permissions
      - Rotate if suspected compromise

  # Credential Master Key
  CREDENTIAL_MASTER_KEY:
    description: "Master encryption key for credential encryption"
    required: true
    how_to_obtain: |
      Generate 32-byte base64 key:
        openssl rand -base64 32
    example: "L7K9m2N4p6Q8r0S2t4U6v8W0x2Y4z6A8b0C2d4E6f8G0="
    rotation_schedule: "Every 365 days"
    security_notes: |
      - CRITICAL: Loss of this key means all encrypted credentials are unrecoverable
      - Store securely in multiple locations (KMS, vault, encrypted backup)
      - For production, consider using AWS KMS instead (CREDENTIAL_USE_KMS=true)
      - Never commit to version control
      - Rotation requires re-encrypting all credentials

# ============================================================
# INFRASTRUCTURE SECRETS (Choose one deployment type)
# ============================================================

# Option A: Kubernetes Deployment
kubernetes_secrets:
  KUBECONFIG:
    description: "Base64-encoded kubeconfig file"
    required: true
    how_to_obtain: |
      1. Get kubeconfig: cat ~/.kube/config
      2. Base64 encode: cat ~/.kube/config | base64
      3. Or use service account token method (preferred)
    example: "YXBpVmVyc2lvbjogdjEKY2x1c3RlcnM6Ci0gY2x1c3Rlcjp..."
    rotation_schedule: "Every 90 days"
    security_notes: |
      - Use service account with minimal permissions
      - Scope to specific namespace
      - Enable RBAC restrictions

  K8S_CLUSTER_URL:
    description: "Kubernetes cluster API URL"
    required: true
    how_to_obtain: "From kubeconfig or cluster provider"
    example: "https://kubernetes.default.svc.cluster.local"

  K8S_TOKEN:
    description: "Kubernetes service account token"
    required: true
    how_to_obtain: |
      Create service account:
        kubectl create serviceaccount github-deployer
        kubectl create token github-deployer
    example: "eyJhbGciOiJSUzI1NiIsImtpZCI6IjEyMzQ1Njc4OTAifQ..."
    rotation_schedule: "Every 90 days"

  K8S_NAMESPACE:
    description: "Kubernetes namespace for deployments"
    required: true
    how_to_obtain: "Your application namespace"
    example: "gorax-production"

# Option B: AWS ECS Deployment
aws_ecs_secrets:
  AWS_ACCESS_KEY_ID:
    description: "AWS access key ID"
    required: true
    how_to_obtain: |
      1. Go to AWS IAM Console
      2. Create user: github-deployer
      3. Attach policy: ECS deployment permissions
      4. Create access key
    example: "AKIAIOSFODNN7EXAMPLE"
    rotation_schedule: "Every 90 days"
    security_notes: |
      - Use minimal IAM permissions
      - Enable MFA if possible
      - Monitor CloudTrail for usage

  AWS_SECRET_ACCESS_KEY:
    description: "AWS secret access key"
    required: true
    how_to_obtain: "From AWS IAM when creating access key"
    example: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
    rotation_schedule: "Every 90 days"
    security_notes: |
      - CRITICAL: Never log or print
      - Rotate immediately if suspected compromise
      - Use AWS Secrets Manager for additional security

  AWS_REGION:
    description: "AWS region for ECS deployment"
    required: true
    how_to_obtain: "Your AWS region"
    example: "us-east-1"

  ECS_CLUSTER:
    description: "ECS cluster name"
    required: true
    how_to_obtain: "From AWS ECS Console"
    example: "gorax-production"

  ECS_SERVICE:
    description: "ECS service name"
    required: true
    how_to_obtain: "From AWS ECS Console"
    example: "gorax-api"

  ECS_TASK_DEFINITION:
    description: "ECS task definition family name"
    required: true
    how_to_obtain: "From AWS ECS Console"
    example: "gorax-api"

# Option C: SSH Deployment
ssh_secrets:
  SSH_PRIVATE_KEY:
    description: "SSH private key for deployment"
    required: true
    how_to_obtain: |
      Generate new key pair:
        ssh-keygen -t ed25519 -C "github-deploy@gorax.dev" -f deploy_key
      Then:
        cat deploy_key
    example: |
      -----BEGIN OPENSSH PRIVATE KEY-----
      b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
      ...
      -----END OPENSSH PRIVATE KEY-----
    rotation_schedule: "Every 365 days"
    security_notes: |
      - Use Ed25519 for better security
      - Add passphrase if possible
      - Restrict to specific commands on server
      - Add public key to server: ~/.ssh/authorized_keys

  SSH_HOST:
    description: "SSH server hostname or IP"
    required: true
    how_to_obtain: "Your server hostname/IP"
    example: "prod.gorax.dev"

  SSH_USER:
    description: "SSH username"
    required: true
    how_to_obtain: "Deployment user on server"
    example: "deploy"
    security_notes: |
      - Use dedicated deployment user
      - Limit sudo permissions
      - Enable only necessary commands

  SSH_PORT:
    description: "SSH port (default: 22)"
    required: false
    how_to_obtain: "SSH port on your server"
    example: "22"

# ============================================================
# OPTIONAL INTEGRATION SECRETS
# ============================================================

optional_secrets:
  # Slack Notifications
  SLACK_WEBHOOK_URL:
    description: "Slack incoming webhook for notifications"
    required: false
    how_to_obtain: |
      1. Go to Slack workspace settings
      2. Create incoming webhook
      3. Select channel for notifications
      4. Copy webhook URL
    example: "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXX"
    rotation_schedule: "Every 180 days"

  # Sentry Error Tracking
  SENTRY_DSN:
    description: "Sentry Data Source Name for error tracking"
    required: false
    how_to_obtain: |
      1. Go to https://sentry.io
      2. Create project
      3. Copy DSN from project settings
    example: "https://abc123@o123456.ingest.sentry.io/1234567"
    rotation_schedule: "Every 180 days"

  # Docker Registry Credentials (if not using GitHub Container Registry)
  DOCKER_USERNAME:
    description: "Docker registry username"
    required: false
    example: "gorax-deploy"

  DOCKER_PASSWORD:
    description: "Docker registry password or token"
    required: false
    how_to_obtain: "From Docker Hub or your registry"
    rotation_schedule: "Every 90 days"

# ============================================================
# SECRET MANAGEMENT BEST PRACTICES
# ============================================================

best_practices:
  generation:
    - "Use cryptographically secure random generation"
    - "Minimum 16 characters for passwords"
    - "Use openssl, secrets module, or password manager"
    - "Never use dictionary words or predictable patterns"

  storage:
    - "Never commit secrets to version control"
    - "Use GitHub Secrets for CI/CD"
    - "Store backup copies in secure vault (1Password, Vault, etc.)"
    - "Encrypt secrets at rest"

  rotation:
    - "Rotate all secrets on schedule"
    - "Immediate rotation if compromised"
    - "Update documentation after rotation"
    - "Test after rotation"

  access_control:
    - "Limit who can view/modify secrets"
    - "Use environment-specific secrets"
    - "Require 2FA for access"
    - "Audit secret access regularly"

  monitoring:
    - "Monitor for secret usage anomalies"
    - "Alert on failed authentication attempts"
    - "Review CloudTrail/audit logs"
    - "Set up secret scanning in repository"

# ============================================================
# QUICK REFERENCE
# ============================================================

quick_commands:
  # Add repository secret
  add_repo_secret: |
    gh secret set SECRET_NAME --body "secret_value"

  # Add environment secret
  add_env_secret: |
    gh secret set SECRET_NAME --env production --body "secret_value"

  # Add secret from file
  add_from_file: |
    gh secret set SSH_PRIVATE_KEY < ~/.ssh/id_ed25519

  # List all secrets
  list_secrets: |
    gh secret list

  # Delete secret
  delete_secret: |
    gh secret delete SECRET_NAME

  # Generate random password
  generate_password: |
    openssl rand -base64 32

  # Generate hex token
  generate_token: |
    openssl rand -hex 32

# ============================================================
# TROUBLESHOOTING
# ============================================================

troubleshooting:
  secret_not_available_in_workflow:
    problem: "Secret is undefined or empty in workflow"
    solutions:
      - "Verify secret name matches exactly (case-sensitive)"
      - "For environment secrets, ensure job specifies environment"
      - "Check secret is set in correct location (repo vs environment)"
      - "Verify workflow has permission to access secrets"

  permission_denied:
    problem: "Cannot add or modify secrets"
    solutions:
      - "Ensure you have admin access to repository"
      - "Verify GitHub token has required scopes"
      - "Check organization permissions if applicable"

  secret_rotation_failed:
    problem: "Application fails after rotating secret"
    solutions:
      - "Verify new secret is correctly set"
      - "Check application has been redeployed with new secret"
      - "Review application logs for authentication errors"
      - "Rollback secret if needed and investigate"

# For detailed setup instructions, see:
# - docs/GITHUB_CONFIGURATION_GUIDE.md
# - docs/GITHUB_SECURITY_CHECKLIST.md
