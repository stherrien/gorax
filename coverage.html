
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gorax/gorax/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/gorax/gorax/cmd/worker/main.go (0.0%)</option>
				
				<option value="file2">github.com/gorax/gorax/internal/api/app.go (0.0%)</option>
				
				<option value="file3">github.com/gorax/gorax/internal/api/app_with_auth.go (0.0%)</option>
				
				<option value="file4">github.com/gorax/gorax/internal/api/handlers/auth.go (0.0%)</option>
				
				<option value="file5">github.com/gorax/gorax/internal/api/handlers/credential.go (65.0%)</option>
				
				<option value="file6">github.com/gorax/gorax/internal/api/handlers/execution.go (64.1%)</option>
				
				<option value="file7">github.com/gorax/gorax/internal/api/handlers/health.go (0.0%)</option>
				
				<option value="file8">github.com/gorax/gorax/internal/api/handlers/schedule.go (0.0%)</option>
				
				<option value="file9">github.com/gorax/gorax/internal/api/handlers/tenant_admin.go (6.1%)</option>
				
				<option value="file10">github.com/gorax/gorax/internal/api/handlers/usage.go (47.8%)</option>
				
				<option value="file11">github.com/gorax/gorax/internal/api/handlers/webhook.go (0.0%)</option>
				
				<option value="file12">github.com/gorax/gorax/internal/api/handlers/websocket.go (0.0%)</option>
				
				<option value="file13">github.com/gorax/gorax/internal/api/handlers/workflow.go (0.0%)</option>
				
				<option value="file14">github.com/gorax/gorax/internal/api/middleware/auth.go (0.0%)</option>
				
				<option value="file15">github.com/gorax/gorax/internal/api/middleware/dev_auth.go (0.0%)</option>
				
				<option value="file16">github.com/gorax/gorax/internal/api/middleware/logger.go (0.0%)</option>
				
				<option value="file17">github.com/gorax/gorax/internal/api/middleware/quota.go (0.0%)</option>
				
				<option value="file18">github.com/gorax/gorax/internal/api/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file19">github.com/gorax/gorax/internal/api/middleware/tenant.go (0.0%)</option>
				
				<option value="file20">github.com/gorax/gorax/internal/billing/webhook.go (89.4%)</option>
				
				<option value="file21">github.com/gorax/gorax/internal/config/config.go (0.0%)</option>
				
				<option value="file22">github.com/gorax/gorax/internal/credential/domain.go (0.0%)</option>
				
				<option value="file23">github.com/gorax/gorax/internal/credential/encryption.go (37.3%)</option>
				
				<option value="file24">github.com/gorax/gorax/internal/credential/errors.go (0.0%)</option>
				
				<option value="file25">github.com/gorax/gorax/internal/credential/injector.go (0.0%)</option>
				
				<option value="file26">github.com/gorax/gorax/internal/credential/kms.go (2.3%)</option>
				
				<option value="file27">github.com/gorax/gorax/internal/credential/masker.go (92.9%)</option>
				
				<option value="file28">github.com/gorax/gorax/internal/credential/repository.go (0.0%)</option>
				
				<option value="file29">github.com/gorax/gorax/internal/credential/service_impl.go (63.6%)</option>
				
				<option value="file30">github.com/gorax/gorax/internal/database/tenant_hooks.go (0.0%)</option>
				
				<option value="file31">github.com/gorax/gorax/internal/executor/actions.go (2.2%)</option>
				
				<option value="file32">github.com/gorax/gorax/internal/executor/actions/action.go (100.0%)</option>
				
				<option value="file33">github.com/gorax/gorax/internal/executor/actions/formula.go (94.1%)</option>
				
				<option value="file34">github.com/gorax/gorax/internal/executor/actions/http.go (80.2%)</option>
				
				<option value="file35">github.com/gorax/gorax/internal/executor/actions/interpolation.go (88.2%)</option>
				
				<option value="file36">github.com/gorax/gorax/internal/executor/actions/registry.go (93.1%)</option>
				
				<option value="file37">github.com/gorax/gorax/internal/executor/actions/script.go (86.7%)</option>
				
				<option value="file38">github.com/gorax/gorax/internal/executor/actions/transform.go (91.4%)</option>
				
				<option value="file39">github.com/gorax/gorax/internal/executor/circuit_breaker.go (93.0%)</option>
				
				<option value="file40">github.com/gorax/gorax/internal/executor/conditional.go (5.7%)</option>
				
				<option value="file41">github.com/gorax/gorax/internal/executor/errors.go (70.1%)</option>
				
				<option value="file42">github.com/gorax/gorax/internal/executor/executor.go (13.4%)</option>
				
				<option value="file43">github.com/gorax/gorax/internal/executor/expression/evaluator.go (70.7%)</option>
				
				<option value="file44">github.com/gorax/gorax/internal/executor/expression/parser.go (85.2%)</option>
				
				<option value="file45">github.com/gorax/gorax/internal/executor/loop.go (58.5%)</option>
				
				<option value="file46">github.com/gorax/gorax/internal/executor/retry.go (82.1%)</option>
				
				<option value="file47">github.com/gorax/gorax/internal/executor/slack_actions.go (83.3%)</option>
				
				<option value="file48">github.com/gorax/gorax/internal/integrations/slack/add_reaction.go (88.2%)</option>
				
				<option value="file49">github.com/gorax/gorax/internal/integrations/slack/client.go (56.0%)</option>
				
				<option value="file50">github.com/gorax/gorax/internal/integrations/slack/errors.go (72.7%)</option>
				
				<option value="file51">github.com/gorax/gorax/internal/integrations/slack/models.go (100.0%)</option>
				
				<option value="file52">github.com/gorax/gorax/internal/integrations/slack/send_dm.go (87.5%)</option>
				
				<option value="file53">github.com/gorax/gorax/internal/integrations/slack/send_message.go (85.7%)</option>
				
				<option value="file54">github.com/gorax/gorax/internal/integrations/slack/update_message.go (88.2%)</option>
				
				<option value="file55">github.com/gorax/gorax/internal/queue/consumer.go (0.0%)</option>
				
				<option value="file56">github.com/gorax/gorax/internal/queue/message.go (92.3%)</option>
				
				<option value="file57">github.com/gorax/gorax/internal/queue/metrics.go (0.0%)</option>
				
				<option value="file58">github.com/gorax/gorax/internal/queue/publisher.go (0.0%)</option>
				
				<option value="file59">github.com/gorax/gorax/internal/queue/publisher_adapter.go (0.0%)</option>
				
				<option value="file60">github.com/gorax/gorax/internal/queue/sqs.go (0.0%)</option>
				
				<option value="file61">github.com/gorax/gorax/internal/quota/executor_integration.go (0.0%)</option>
				
				<option value="file62">github.com/gorax/gorax/internal/quota/tracker.go (78.2%)</option>
				
				<option value="file63">github.com/gorax/gorax/internal/ratelimit/limiter.go (82.9%)</option>
				
				<option value="file64">github.com/gorax/gorax/internal/schedule/model.go (0.0%)</option>
				
				<option value="file65">github.com/gorax/gorax/internal/schedule/repository.go (0.0%)</option>
				
				<option value="file66">github.com/gorax/gorax/internal/schedule/scheduler.go (81.9%)</option>
				
				<option value="file67">github.com/gorax/gorax/internal/schedule/service.go (16.7%)</option>
				
				<option value="file68">github.com/gorax/gorax/internal/schedule/workflow_executor.go (0.0%)</option>
				
				<option value="file69">github.com/gorax/gorax/internal/tenant/model.go (100.0%)</option>
				
				<option value="file70">github.com/gorax/gorax/internal/tenant/repository.go (0.0%)</option>
				
				<option value="file71">github.com/gorax/gorax/internal/tenant/service.go (0.0%)</option>
				
				<option value="file72">github.com/gorax/gorax/internal/user/repository.go (0.0%)</option>
				
				<option value="file73">github.com/gorax/gorax/internal/user/service.go (74.5%)</option>
				
				<option value="file74">github.com/gorax/gorax/internal/webhook/model.go (0.0%)</option>
				
				<option value="file75">github.com/gorax/gorax/internal/webhook/repository.go (0.0%)</option>
				
				<option value="file76">github.com/gorax/gorax/internal/webhook/service.go (0.0%)</option>
				
				<option value="file77">github.com/gorax/gorax/internal/websocket/events.go (86.7%)</option>
				
				<option value="file78">github.com/gorax/gorax/internal/websocket/hub.go (51.1%)</option>
				
				<option value="file79">github.com/gorax/gorax/internal/worker/concurrency.go (0.0%)</option>
				
				<option value="file80">github.com/gorax/gorax/internal/worker/health.go (0.0%)</option>
				
				<option value="file81">github.com/gorax/gorax/internal/worker/worker.go (0.0%)</option>
				
				<option value="file82">github.com/gorax/gorax/internal/workflow/formula/evaluator.go (55.0%)</option>
				
				<option value="file83">github.com/gorax/gorax/internal/workflow/formula/functions.go (84.3%)</option>
				
				<option value="file84">github.com/gorax/gorax/internal/workflow/model.go (94.1%)</option>
				
				<option value="file85">github.com/gorax/gorax/internal/workflow/repository.go (0.0%)</option>
				
				<option value="file86">github.com/gorax/gorax/internal/workflow/service.go (13.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gorax/gorax/internal/api"
        "github.com/gorax/gorax/internal/config"
)

func main() <span class="cov0" title="0">{
        // Initialize structured logger
        logger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))
        slog.SetDefault(logger)

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to load configuration", "error", err)
                os.Exit(1)
        }</span>

        // Initialize application
        <span class="cov0" title="0">app, err := api.NewApp(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to initialize application", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer app.Close()

        // Create HTTP server
        server := &amp;http.Server{
                Addr:         cfg.Server.Address,
                Handler:      app.Router(),
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                slog.Info("starting API server", "address", cfg.Server.Address)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        slog.Error("server error", "error", err)
                        os.Exit(1)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        slog.Info("shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("server forced to shutdown", "error", err)
        }</span>

        <span class="cov0" title="0">slog.Info("server stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"

        "github.com/gorax/gorax/internal/config"
        "github.com/gorax/gorax/internal/schedule"
        "github.com/gorax/gorax/internal/worker"
        "github.com/gorax/gorax/internal/workflow"
)

func main() <span class="cov0" title="0">{
        // Initialize structured logger
        logger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))
        slog.SetDefault(logger)

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to load configuration", "error", err)
                os.Exit(1)
        }</span>

        // Create cancellable context
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Initialize database connection for scheduler
        db, err := sqlx.Connect("postgres", cfg.Database.ConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to connect to database", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Initialize repositories
        workflowRepo := workflow.NewRepository(db)
        scheduleRepo := schedule.NewRepository(db)

        // Initialize workflow service
        workflowService := workflow.NewService(workflowRepo, logger)

        // Initialize schedule service
        scheduleService := schedule.NewService(scheduleRepo, logger)

        // Create workflow getter adapter
        workflowGetter := &amp;workflowServiceAdapter{workflowService: workflowService}
        scheduleService.SetWorkflowService(workflowGetter)

        // Create workflow executor adapter for scheduler
        executorAdapter := schedule.NewWorkflowServiceAdapter(func(ctx context.Context, tenantID, workflowID, triggerType string, triggerData []byte) (string, error) </span><span class="cov0" title="0">{
                execution, err := workflowService.Execute(ctx, tenantID, workflowID, triggerType, triggerData)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return execution.ID, nil</span>
        })

        // Initialize scheduler
        <span class="cov0" title="0">scheduler := schedule.NewScheduler(scheduleService, executorAdapter, logger)

        // Initialize worker
        w, err := worker.New(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to initialize worker", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer w.Close()

        // Start health check server
        healthServer := worker.NewHealthServer(w, cfg.Worker.HealthPort)
        go func() </span><span class="cov0" title="0">{
                if err := healthServer.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        slog.Error("health server error", "error", err)
                }</span>
        }()
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer shutdownCancel()
                healthServer.Shutdown(shutdownCtx)
        }</span>()

        // Start scheduler in goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                slog.Info("starting workflow scheduler")
                if err := scheduler.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        slog.Error("scheduler error", "error", err)
                }</span>
        }()

        // Start worker in goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                slog.Info("starting workflow worker", "concurrency", cfg.Worker.Concurrency)
                if err := w.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        slog.Error("worker error", "error", err)
                        cancel()
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        slog.Info("shutting down worker and scheduler...")
        cancel()

        // Stop scheduler
        scheduler.Stop()

        // Wait for worker to finish current jobs
        w.Wait()

        slog.Info("worker and scheduler stopped")</span>
}

// workflowServiceAdapter adapts workflow.Service to schedule.WorkflowGetter interface
type workflowServiceAdapter struct {
        workflowService *workflow.Service
}

func (w *workflowServiceAdapter) GetByID(ctx context.Context, tenantID, id string) (interface{}, error) <span class="cov0" title="0">{
        return w.workflowService.GetByID(ctx, tenantID, id)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-chi/cors"
        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"
        "github.com/redis/go-redis/v9"

        "github.com/gorax/gorax/internal/api/handlers"
        apiMiddleware "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/config"
        "github.com/gorax/gorax/internal/credential"
        "github.com/gorax/gorax/internal/executor"
        "github.com/gorax/gorax/internal/quota"
        "github.com/gorax/gorax/internal/schedule"
        "github.com/gorax/gorax/internal/tenant"
        "github.com/gorax/gorax/internal/webhook"
        "github.com/gorax/gorax/internal/websocket"
        "github.com/gorax/gorax/internal/workflow"
)

// App holds application dependencies
type App struct {
        config   *config.Config
        logger   *slog.Logger
        db       *sqlx.DB
        redis    *redis.Client
        router   *chi.Mux

        // Services
        tenantService     *tenant.Service
        workflowService   *workflow.Service
        webhookService    *webhook.Service
        scheduleService   *schedule.Service
        credentialService credential.Service

        // WebSocket
        wsHub *websocket.Hub

        // Handlers
        healthHandler       *handlers.HealthHandler
        workflowHandler     *handlers.WorkflowHandler
        webhookHandler      *handlers.WebhookHandler
        websocketHandler    *handlers.WebSocketHandler
        tenantAdminHandler  *handlers.TenantAdminHandler
        scheduleHandler     *handlers.ScheduleHandler
        executionHandler    *handlers.ExecutionHandler
        usageHandler        *handlers.UsageHandler
        credentialHandler   *handlers.CredentialHandler

        // Middleware
        quotaChecker *apiMiddleware.QuotaChecker

        // Quota tracking
        quotaTracker *quota.Tracker
}

// NewApp creates a new application instance
func NewApp(cfg *config.Config, logger *slog.Logger) (*App, error) <span class="cov0" title="0">{
        app := &amp;App{
                config: cfg,
                logger: logger,
        }

        // Initialize database connection
        db, err := sqlx.Connect("postgres", cfg.Database.ConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)
        app.db = db

        // Initialize Redis client
        app.redis = redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Redis.Address,
                Password: cfg.Redis.Password,
                DB:       cfg.Redis.DB,
        })

        // Initialize repositories
        tenantRepo := tenant.NewRepository(db)
        workflowRepo := workflow.NewRepository(db)
        webhookRepo := webhook.NewRepository(db)
        scheduleRepo := schedule.NewRepository(db)

        // Initialize services
        app.tenantService = tenant.NewService(tenantRepo, logger)
        app.workflowService = workflow.NewService(workflowRepo, logger)
        app.webhookService = webhook.NewService(webhookRepo, logger)
        app.scheduleService = schedule.NewService(scheduleRepo, logger)

        // Initialize WebSocket hub
        app.wsHub = websocket.NewHub(logger)
        go app.wsHub.Run() // Start hub in background

        // Initialize executor with WebSocket broadcaster
        broadcaster := websocket.NewHubBroadcaster(app.wsHub)
        workflowExecutor := executor.NewWithBroadcaster(workflowRepo, logger, broadcaster)

        // Create workflow getter adapter for schedule service
        workflowGetter := &amp;workflowServiceAdapter{workflowService: app.workflowService}

        // Wire up dependencies to avoid import cycles
        app.workflowService.SetExecutor(workflowExecutor)
        app.workflowService.SetWebhookService(app.webhookService)
        app.scheduleService.SetWorkflowService(workflowGetter)

        // Initialize handlers
        app.healthHandler = handlers.NewHealthHandler(db, app.redis)
        app.workflowHandler = handlers.NewWorkflowHandler(app.workflowService, logger)
        app.webhookHandler = handlers.NewWebhookHandler(app.workflowService, app.webhookService, logger)
        app.websocketHandler = handlers.NewWebSocketHandler(app.wsHub, logger)
        app.tenantAdminHandler = handlers.NewTenantAdminHandler(app.tenantService, logger)
        app.scheduleHandler = handlers.NewScheduleHandler(app.scheduleService, logger)
        app.executionHandler = handlers.NewExecutionHandler(app.workflowService, logger)

        // TODO: Initialize credential service and handler once service implementation is complete
        // credentialRepo := credential.NewRepository(db)
        // app.credentialService = credential.NewService(credentialRepo, kmsClient, logger)
        // app.credentialHandler = handlers.NewCredentialHandler(app.credentialService, logger)

        // Initialize quota tracker
        app.quotaTracker = quota.NewTracker(app.redis)

        // Initialize usage service and handler
        usageService := handlers.NewUsageService(app.quotaTracker, app.tenantService, logger)
        app.usageHandler = handlers.NewUsageHandler(usageService)

        // Initialize middleware
        app.quotaChecker = apiMiddleware.NewQuotaChecker(app.tenantService, app.redis, logger)

        // Setup router
        app.setupRouter()

        return app, nil</span>
}

// Router returns the HTTP router
func (a *App) Router() http.Handler <span class="cov0" title="0">{
        return a.router
}</span>

// Close cleans up application resources
func (a *App) Close() error <span class="cov0" title="0">{
        if a.db != nil </span><span class="cov0" title="0">{
                a.db.Close()
        }</span>
        <span class="cov0" title="0">if a.redis != nil </span><span class="cov0" title="0">{
                a.redis.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *App) setupRouter() <span class="cov0" title="0">{
        r := chi.NewRouter()

        // Global middleware
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(apiMiddleware.StructuredLogger(a.logger))
        r.Use(middleware.Recoverer)
        r.Use(middleware.Compress(5))

        // CORS configuration
        r.Use(cors.Handler(cors.Options{
                AllowedOrigins:   []string{"http://localhost:5173", "http://localhost:5174", "http://localhost:3000"},
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-Tenant-ID"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: true,
                MaxAge:           300,
        }))

        // Health check endpoints (no auth required)
        r.Get("/health", a.healthHandler.Health)
        r.Get("/ready", a.healthHandler.Ready)

        // API v1 routes
        r.Route("/api/v1", func(r chi.Router) </span><span class="cov0" title="0">{
                // Authentication middleware
                if a.config.Server.Env == "development" </span><span class="cov0" title="0">{
                        // Use development auth that bypasses Kratos
                        r.Use(apiMiddleware.DevAuth())
                }</span> else<span class="cov0" title="0"> {
                        // Use production Kratos auth
                        r.Use(apiMiddleware.KratosAuth(a.config.Kratos))
                }</span>

                // Admin routes (no tenant context, no quotas)
                <span class="cov0" title="0">r.Route("/admin", func(r chi.Router) </span><span class="cov0" title="0">{
                        // TODO: Add admin role check middleware
                        r.Route("/tenants", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", a.tenantAdminHandler.ListTenants)
                                r.Post("/", a.tenantAdminHandler.CreateTenant)
                                r.Get("/{tenantID}", a.tenantAdminHandler.GetTenant)
                                r.Put("/{tenantID}", a.tenantAdminHandler.UpdateTenant)
                                r.Delete("/{tenantID}", a.tenantAdminHandler.DeleteTenant)
                                r.Put("/{tenantID}/quotas", a.tenantAdminHandler.UpdateTenantQuotas)
                                r.Get("/{tenantID}/usage", a.tenantAdminHandler.GetTenantUsage)
                        }</span>)
                })

                // Tenant context middleware (for non-admin routes)
                <span class="cov0" title="0">r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(apiMiddleware.TenantContext(a.tenantService))
                        r.Use(a.quotaChecker.CheckQuotas())

                        // Workflow routes
                        r.Route("/workflows", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", a.workflowHandler.List)
                                r.Post("/", a.workflowHandler.Create)
                                r.Get("/{workflowID}", a.workflowHandler.Get)
                                r.Put("/{workflowID}", a.workflowHandler.Update)
                                r.Delete("/{workflowID}", a.workflowHandler.Delete)
                                r.Post("/{workflowID}/execute", a.workflowHandler.Execute)

                                // Schedule routes for a specific workflow
                                r.Route("/{workflowID}/schedules", func(r chi.Router) </span><span class="cov0" title="0">{
                                        r.Get("/", a.scheduleHandler.List)
                                        r.Post("/", a.scheduleHandler.Create)
                                }</span>)
                        })

                        // Execution routes
                        <span class="cov0" title="0">r.Route("/executions", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", a.executionHandler.ListExecutionsAdvanced)
                                r.Get("/stats", a.executionHandler.GetExecutionStats)
                                r.Get("/{executionID}", a.workflowHandler.GetExecution)
                                r.Get("/{executionID}/steps", a.executionHandler.GetExecutionWithSteps)
                        }</span>)

                        // Usage routes
                        <span class="cov0" title="0">r.Route("/tenants/{id}/usage", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", a.usageHandler.GetCurrentUsage)
                                r.Get("/history", a.usageHandler.GetUsageHistory)
                        }</span>)

                        // Schedule routes (all schedules across workflows)
                        <span class="cov0" title="0">r.Route("/schedules", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", a.scheduleHandler.ListAll)
                                r.Get("/{scheduleID}", a.scheduleHandler.Get)
                                r.Put("/{scheduleID}", a.scheduleHandler.Update)
                                r.Delete("/{scheduleID}", a.scheduleHandler.Delete)
                                r.Post("/parse-cron", a.scheduleHandler.ParseCron)
                        }</span>)

                        // WebSocket routes
                        <span class="cov0" title="0">r.Route("/ws", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", a.websocketHandler.HandleConnection)
                                r.Get("/executions/{executionID}", a.websocketHandler.HandleExecutionConnection)
                                r.Get("/workflows/{workflowID}", a.websocketHandler.HandleWorkflowConnection)
                        }</span>)

                        // Credential routes
                        // TODO: Uncomment once credential service is implemented
                        // r.Route("/credentials", func(r chi.Router) {
                        //         r.Get("/", a.credentialHandler.List)
                        //         r.Post("/", a.credentialHandler.Create)
                        //         r.Get("/{credentialID}", a.credentialHandler.Get)
                        //         r.Get("/{credentialID}/value", a.credentialHandler.GetValue) // Sensitive endpoint
                        //         r.Put("/{credentialID}", a.credentialHandler.Update)
                        //         r.Delete("/{credentialID}", a.credentialHandler.Delete)
                        //         r.Post("/{credentialID}/rotate", a.credentialHandler.Rotate)
                        //         r.Get("/{credentialID}/versions", a.credentialHandler.ListVersions)
                        //         r.Get("/{credentialID}/access-log", a.credentialHandler.GetAccessLog)
                        // })
                })
        })

        // Webhook endpoint (public, uses webhook-specific auth)
        <span class="cov0" title="0">r.Route("/webhooks", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/{workflowID}/{webhookID}", a.webhookHandler.Handle)
        }</span>)

        <span class="cov0" title="0">a.router = r</span>
}

// workflowServiceAdapter adapts workflow.Service to schedule.WorkflowGetter interface
type workflowServiceAdapter struct {
        workflowService *workflow.Service
}

func (w *workflowServiceAdapter) GetByID(ctx context.Context, tenantID, id string) (interface{}, error) <span class="cov0" title="0">{
        return w.workflowService.GetByID(ctx, tenantID, id)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "log/slog"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-chi/cors"
        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"
        "github.com/redis/go-redis/v9"

        "github.com/gorax/gorax/internal/api/handlers"
        apiMiddleware "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/config"
        "github.com/gorax/gorax/internal/executor"
        "github.com/gorax/gorax/internal/tenant"
        "github.com/gorax/gorax/internal/user"
        "github.com/gorax/gorax/internal/webhook"
        "github.com/gorax/gorax/internal/websocket"
        "github.com/gorax/gorax/internal/workflow"
)

// AppWithAuth holds application dependencies including authentication
type AppWithAuth struct {
        config   *config.Config
        logger   *slog.Logger
        db       *sqlx.DB
        redis    *redis.Client
        router   *chi.Mux

        // Services
        tenantService   *tenant.Service
        userService     *user.Service
        workflowService *workflow.Service
        webhookService  *webhook.Service

        // WebSocket
        wsHub *websocket.Hub

        // Handlers
        healthHandler      *handlers.HealthHandler
        authHandler        *handlers.AuthHandler
        workflowHandler    *handlers.WorkflowHandler
        webhookHandler     *handlers.WebhookHandler
        websocketHandler   *handlers.WebSocketHandler
        tenantAdminHandler *handlers.TenantAdminHandler

        // Middleware
        quotaChecker *apiMiddleware.QuotaChecker
}

// NewAppWithAuth creates a new application instance with authentication
func NewAppWithAuth(cfg *config.Config, logger *slog.Logger) (*AppWithAuth, error) <span class="cov0" title="0">{
        app := &amp;AppWithAuth{
                config: cfg,
                logger: logger,
        }

        // Initialize database connection
        db, err := sqlx.Connect("postgres", cfg.Database.ConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)
        app.db = db

        // Initialize Redis client
        app.redis = redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Redis.Address,
                Password: cfg.Redis.Password,
                DB:       cfg.Redis.DB,
        })

        // Initialize repositories
        tenantRepo := tenant.NewRepository(db)
        userRepo := user.NewRepository(db)
        workflowRepo := workflow.NewRepository(db)
        webhookRepo := webhook.NewRepository(db)

        // Initialize services
        app.tenantService = tenant.NewService(tenantRepo, logger)
        app.userService = user.NewService(userRepo, logger)
        app.workflowService = workflow.NewService(workflowRepo, logger)
        app.webhookService = webhook.NewService(webhookRepo, logger)

        // Initialize WebSocket hub
        app.wsHub = websocket.NewHub(logger)
        go app.wsHub.Run() // Start hub in background

        // Initialize executor with WebSocket broadcaster
        broadcaster := websocket.NewHubBroadcaster(app.wsHub)
        workflowExecutor := executor.NewWithBroadcaster(workflowRepo, logger, broadcaster)

        // Wire up dependencies to avoid import cycles
        app.workflowService.SetExecutor(workflowExecutor)
        app.workflowService.SetWebhookService(app.webhookService)

        // Initialize handlers
        app.healthHandler = handlers.NewHealthHandler(db, app.redis)
        app.authHandler = handlers.NewAuthHandler(app.userService, cfg.Kratos, logger)
        app.workflowHandler = handlers.NewWorkflowHandler(app.workflowService, logger)
        app.webhookHandler = handlers.NewWebhookHandler(app.workflowService, app.webhookService, logger)
        app.websocketHandler = handlers.NewWebSocketHandler(app.wsHub, logger)
        app.tenantAdminHandler = handlers.NewTenantAdminHandler(app.tenantService, logger)

        // Initialize middleware
        app.quotaChecker = apiMiddleware.NewQuotaChecker(app.tenantService, app.redis, logger)

        // Setup router
        app.setupRouter()

        return app, nil</span>
}

// Router returns the HTTP router
func (a *AppWithAuth) Router() http.Handler <span class="cov0" title="0">{
        return a.router
}</span>

// Close cleans up application resources
func (a *AppWithAuth) Close() error <span class="cov0" title="0">{
        if a.db != nil </span><span class="cov0" title="0">{
                a.db.Close()
        }</span>
        <span class="cov0" title="0">if a.redis != nil </span><span class="cov0" title="0">{
                a.redis.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *AppWithAuth) setupRouter() <span class="cov0" title="0">{
        r := chi.NewRouter()

        // Global middleware
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(apiMiddleware.StructuredLogger(a.logger))
        r.Use(middleware.Recoverer)
        r.Use(middleware.Compress(5))

        // CORS configuration
        r.Use(cors.Handler(cors.Options{
                AllowedOrigins:   []string{"http://localhost:5173", "http://localhost:5174", "http://localhost:3000"},
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-Tenant-ID"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: true,
                MaxAge:           300,
        }))

        // Health check endpoints (no auth required)
        r.Get("/health", a.healthHandler.Health)
        r.Get("/ready", a.healthHandler.Ready)

        // API v1 routes
        r.Route("/api/v1", func(r chi.Router) </span><span class="cov0" title="0">{
                // Public auth routes (no auth middleware)
                r.Route("/auth", func(r chi.Router) </span><span class="cov0" title="0">{
                        // Registration flow
                        r.Get("/register", a.authHandler.InitiateRegistration)
                        r.Post("/register", a.authHandler.Register)

                        // Login flow
                        r.Get("/login", a.authHandler.InitiateLogin)
                        r.Post("/login", a.authHandler.Login)

                        // Password reset flow
                        r.Post("/password-reset/request", a.authHandler.RequestPasswordReset)
                        r.Post("/password-reset/confirm", a.authHandler.ConfirmPasswordReset)

                        // Email verification flow
                        r.Post("/verification/request", a.authHandler.RequestEmailVerification)
                        r.Post("/verification/confirm", a.authHandler.ConfirmEmailVerification)

                        // Kratos webhook endpoint (secured with webhook secret)
                        r.Post("/webhooks/kratos", a.authHandler.KratosWebhook)

                        // Protected auth routes
                        r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                                if a.config.Server.Env == "development" </span><span class="cov0" title="0">{
                                        r.Use(apiMiddleware.DevAuth())
                                }</span> else<span class="cov0" title="0"> {
                                        r.Use(apiMiddleware.KratosAuth(a.config.Kratos))
                                }</span>

                                <span class="cov0" title="0">r.Post("/logout", a.authHandler.Logout)
                                r.Get("/me", a.authHandler.GetCurrentUser)</span>
                        })
                })

                // Protected routes
                <span class="cov0" title="0">r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                        // Authentication middleware
                        if a.config.Server.Env == "development" </span><span class="cov0" title="0">{
                                r.Use(apiMiddleware.DevAuth())
                        }</span> else<span class="cov0" title="0"> {
                                r.Use(apiMiddleware.KratosAuth(a.config.Kratos))
                        }</span>

                        // Admin routes (no tenant context, no quotas)
                        <span class="cov0" title="0">r.Route("/admin", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Route("/tenants", func(r chi.Router) </span><span class="cov0" title="0">{
                                        r.Get("/", a.tenantAdminHandler.ListTenants)
                                        r.Post("/", a.tenantAdminHandler.CreateTenant)
                                        r.Get("/{tenantID}", a.tenantAdminHandler.GetTenant)
                                        r.Put("/{tenantID}", a.tenantAdminHandler.UpdateTenant)
                                        r.Delete("/{tenantID}", a.tenantAdminHandler.DeleteTenant)
                                        r.Put("/{tenantID}/quotas", a.tenantAdminHandler.UpdateTenantQuotas)
                                        r.Get("/{tenantID}/usage", a.tenantAdminHandler.GetTenantUsage)
                                }</span>)
                        })

                        // Tenant-scoped routes
                        <span class="cov0" title="0">r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Use(apiMiddleware.TenantContext(a.tenantService))
                                r.Use(a.quotaChecker.CheckQuotas())

                                // Workflow routes
                                r.Route("/workflows", func(r chi.Router) </span><span class="cov0" title="0">{
                                        r.Get("/", a.workflowHandler.List)
                                        r.Post("/", a.workflowHandler.Create)
                                        r.Get("/{workflowID}", a.workflowHandler.Get)
                                        r.Put("/{workflowID}", a.workflowHandler.Update)
                                        r.Delete("/{workflowID}", a.workflowHandler.Delete)
                                        r.Post("/{workflowID}/execute", a.workflowHandler.Execute)
                                }</span>)

                                // Execution routes
                                <span class="cov0" title="0">r.Route("/executions", func(r chi.Router) </span><span class="cov0" title="0">{
                                        r.Get("/", a.workflowHandler.ListExecutions)
                                        r.Get("/{executionID}", a.workflowHandler.GetExecution)
                                }</span>)

                                // WebSocket routes
                                <span class="cov0" title="0">r.Route("/ws", func(r chi.Router) </span><span class="cov0" title="0">{
                                        r.Get("/", a.websocketHandler.HandleConnection)
                                        r.Get("/executions/{executionID}", a.websocketHandler.HandleExecutionConnection)
                                        r.Get("/workflows/{workflowID}", a.websocketHandler.HandleWorkflowConnection)
                                }</span>)
                        })
                })
        })

        // Webhook endpoint (public, uses webhook-specific auth)
        <span class="cov0" title="0">r.Route("/webhooks", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/{workflowID}/{webhookID}", a.webhookHandler.Handle)
        }</span>)

        <span class="cov0" title="0">a.router = r</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "os"

        "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/config"
        "github.com/gorax/gorax/internal/user"
)

// AuthHandler handles authentication-related requests
type AuthHandler struct {
        userService  *user.Service
        kratosConfig config.KratosConfig
        logger       *slog.Logger
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(userService *user.Service, kratosConfig config.KratosConfig, logger *slog.Logger) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                userService:  userService,
                kratosConfig: kratosConfig,
                logger:       logger,
        }
}</span>

// RegisterRequest represents a registration request
type RegisterRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
        TenantID string `json:"tenant_id"`
}

// LoginRequest represents a login request
type LoginRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// PasswordResetRequest represents a password reset request
type PasswordResetRequest struct {
        Email string `json:"email"`
}

// PasswordResetConfirm represents a password reset confirmation
type PasswordResetConfirm struct {
        Code     string `json:"code"`
        Password string `json:"password"`
}

// VerificationRequest represents an email verification request
type VerificationRequest struct {
        Email string `json:"email"`
}

// VerificationConfirm represents an email verification confirmation
type VerificationConfirm struct {
        Code string `json:"code"`
}

// InitiateRegistration initiates the registration flow with Kratos
func (h *AuthHandler) InitiateRegistration(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Create a new registration flow with Kratos
        flowURL := fmt.Sprintf("%s/self-service/registration/api", h.kratosConfig.PublicURL)

        req, err := http.NewRequest("GET", flowURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create registration flow request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to initiate registration flow", "error", err)
                http.Error(w, "failed to initiate registration", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Forward the response from Kratos
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(resp.StatusCode)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "flow_id": resp.Header.Get("X-Flow-Id"),
                "ui":      resp.Header.Get("Location"),
        })</span>
}

// Register handles user registration via Kratos
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Submit registration to Kratos
        <span class="cov0" title="0">flowID := r.URL.Query().Get("flow")
        if flowID == "" </span><span class="cov0" title="0">{
                http.Error(w, "missing flow parameter", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">registrationURL := fmt.Sprintf("%s/self-service/registration?flow=%s", h.kratosConfig.PublicURL, flowID)

        payload := map[string]interface{}{
                "method": "password",
                "password": req.Password,
                "traits": map[string]interface{}{
                        "email":     req.Email,
                        "tenant_id": req.TenantID,
                },
        }

        payloadBytes, _ := json.Marshal(payload)
        kratosReq, err := http.NewRequest("POST", registrationURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create kratos request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">kratosReq.Header.Set("Content-Type", "application/json")
        kratosReq.Body = http.NoBody

        client := &amp;http.Client{}
        resp, err := client.Do(kratosReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to register with kratos", "error", err)
                http.Error(w, "registration failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Parse response from Kratos
        var kratosResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;kratosResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode kratos response", "error", err)
                http.Error(w, "registration failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(resp.StatusCode)
        json.NewEncoder(w).Encode(kratosResp)

        _ = payloadBytes</span> // Use the variable to avoid unused warning
}

// InitiateLogin initiates the login flow with Kratos
func (h *AuthHandler) InitiateLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        flowURL := fmt.Sprintf("%s/self-service/login/api", h.kratosConfig.PublicURL)

        req, err := http.NewRequest("GET", flowURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create login flow request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to initiate login flow", "error", err)
                http.Error(w, "failed to initiate login", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var flowResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;flowResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode flow response", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(flowResp)</span>
}

// Login handles user login via Kratos
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">flowID := r.URL.Query().Get("flow")
        if flowID == "" </span><span class="cov0" title="0">{
                http.Error(w, "missing flow parameter", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">loginURL := fmt.Sprintf("%s/self-service/login?flow=%s", h.kratosConfig.PublicURL, flowID)

        payload := map[string]interface{}{
                "method":     "password",
                "password":   req.Password,
                "identifier": req.Email,
        }

        payloadBytes, _ := json.Marshal(payload)
        kratosReq, err := http.NewRequest("POST", loginURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create kratos request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">kratosReq.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{}
        resp, err := client.Do(kratosReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to login with kratos", "error", err)
                http.Error(w, "login failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var kratosResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;kratosResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode kratos response", "error", err)
                http.Error(w, "login failed", http.StatusInternalServerError)
                return
        }</span>

        // Copy session cookie from Kratos response
        <span class="cov0" title="0">if cookies := resp.Cookies(); len(cookies) &gt; 0 </span><span class="cov0" title="0">{
                for _, cookie := range cookies </span><span class="cov0" title="0">{
                        http.SetCookie(w, cookie)
                }</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(resp.StatusCode)
        json.NewEncoder(w).Encode(kratosResp)

        _ = payloadBytes</span>
}

// Logout handles user logout
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get session token
        sessionToken := extractSessionToken(r)
        if sessionToken == "" </span><span class="cov0" title="0">{
                http.Error(w, "no active session", http.StatusUnauthorized)
                return
        }</span>

        // Create logout flow
        <span class="cov0" title="0">logoutURL := fmt.Sprintf("%s/self-service/logout/api", h.kratosConfig.PublicURL)
        req, err := http.NewRequest("GET", logoutURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create logout request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Session-Token", sessionToken)

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to logout with kratos", "error", err)
                http.Error(w, "logout failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Clear session cookie
        http.SetCookie(w, &amp;http.Cookie{
                Name:   "ory_kratos_session",
                Value:  "",
                Path:   "/",
                MaxAge: -1,
        })

        w.WriteHeader(http.StatusNoContent)</span>
}

// GetCurrentUser returns the current authenticated user
func (h *AuthHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user from context (set by auth middleware)
        authUser := middleware.GetUser(r)
        if authUser == nil </span><span class="cov0" title="0">{
                http.Error(w, "unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Fetch full user details from database
        <span class="cov0" title="0">user, err := h.userService.GetUserByKratosIdentityID(r.Context(), authUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                // User might not be synced yet, return basic info from Kratos
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(authUser)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

// RequestPasswordReset initiates password reset flow
func (h *AuthHandler) RequestPasswordReset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req PasswordResetRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Create recovery flow
        <span class="cov0" title="0">recoveryURL := fmt.Sprintf("%s/self-service/recovery/api", h.kratosConfig.PublicURL)
        kratosReq, err := http.NewRequest("GET", recoveryURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create recovery request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(kratosReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to initiate recovery", "error", err)
                http.Error(w, "failed to initiate password reset", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var flowResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;flowResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode flow response", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(flowResp)</span>
}

// ConfirmPasswordReset confirms password reset
func (h *AuthHandler) ConfirmPasswordReset(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req PasswordResetConfirm
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">flowID := r.URL.Query().Get("flow")
        if flowID == "" </span><span class="cov0" title="0">{
                http.Error(w, "missing flow parameter", http.StatusBadRequest)
                return
        }</span>

        // Submit recovery code to Kratos
        <span class="cov0" title="0">recoveryURL := fmt.Sprintf("%s/self-service/recovery?flow=%s", h.kratosConfig.PublicURL, flowID)

        payload := map[string]interface{}{
                "method": "code",
                "code":   req.Code,
        }

        payloadBytes, _ := json.Marshal(payload)
        kratosReq, err := http.NewRequest("POST", recoveryURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create kratos request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">kratosReq.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{}
        resp, err := client.Do(kratosReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to confirm password reset", "error", err)
                http.Error(w, "password reset failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var kratosResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;kratosResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode kratos response", "error", err)
                http.Error(w, "password reset failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(resp.StatusCode)
        json.NewEncoder(w).Encode(kratosResp)

        _ = payloadBytes</span>
}

// RequestEmailVerification initiates email verification flow
func (h *AuthHandler) RequestEmailVerification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Create verification flow
        verificationURL := fmt.Sprintf("%s/self-service/verification/api", h.kratosConfig.PublicURL)
        kratosReq, err := http.NewRequest("GET", verificationURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create verification request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(kratosReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to initiate verification", "error", err)
                http.Error(w, "failed to initiate email verification", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var flowResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;flowResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode flow response", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(flowResp)</span>
}

// ConfirmEmailVerification confirms email verification
func (h *AuthHandler) ConfirmEmailVerification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req VerificationConfirm
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">flowID := r.URL.Query().Get("flow")
        if flowID == "" </span><span class="cov0" title="0">{
                http.Error(w, "missing flow parameter", http.StatusBadRequest)
                return
        }</span>

        // Submit verification code to Kratos
        <span class="cov0" title="0">verificationURL := fmt.Sprintf("%s/self-service/verification?flow=%s", h.kratosConfig.PublicURL, flowID)

        payload := map[string]interface{}{
                "method": "code",
                "code":   req.Code,
        }

        payloadBytes, _ := json.Marshal(payload)
        kratosReq, err := http.NewRequest("POST", verificationURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create kratos request", "error", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">kratosReq.Header.Set("Content-Type", "application/json")

        client := &amp;http.Client{}
        resp, err := client.Do(kratosReq)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to confirm email verification", "error", err)
                http.Error(w, "email verification failed", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var kratosResp map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;kratosResp); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode kratos response", "error", err)
                http.Error(w, "email verification failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(resp.StatusCode)
        json.NewEncoder(w).Encode(kratosResp)

        _ = payloadBytes</span>
}

// KratosWebhook handles webhooks from Kratos for identity lifecycle events
func (h *AuthHandler) KratosWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Verify webhook secret
        secret := r.Header.Get("X-Webhook-Secret")
        expectedSecret := os.Getenv("KRATOS_WEBHOOK_SECRET")
        if expectedSecret == "" </span><span class="cov0" title="0">{
                expectedSecret = "YOUR_WEBHOOK_SECRET" // Default for development
        }</span>

        <span class="cov0" title="0">if secret != expectedSecret </span><span class="cov0" title="0">{
                h.logger.Warn("invalid webhook secret")
                http.Error(w, "unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var webhook user.KratosIdentityWebhook
        if err := json.NewDecoder(r.Body).Decode(&amp;webhook); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode webhook payload", "error", err)
                http.Error(w, "invalid payload", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("received kratos webhook",
                "identity_id", webhook.IdentityID,
                "email", webhook.Email,
        )

        // Sync user to database
        _, err := h.userService.SyncFromKratosWebhook(r.Context(), webhook)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to sync user from webhook", "error", err)
                http.Error(w, "failed to sync user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{
                "status": "success",
        })</span>
}

func extractSessionToken(r *http.Request) string <span class="cov0" title="0">{
        // Try Authorization header first
        authHeader := r.Header.Get("Authorization")
        if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov0" title="0">{
                return authHeader[7:]
        }</span>

        // Try session cookie
        <span class="cov0" title="0">cookie, err := r.Cookie("ory_kratos_session")
        if err == nil </span><span class="cov0" title="0">{
                return cookie.Value
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/credential"
)

// CredentialHandler handles credential-related HTTP requests
type CredentialHandler struct {
        service credential.Service
        logger  *slog.Logger
}

// NewCredentialHandler creates a new credential handler
func NewCredentialHandler(service credential.Service, logger *slog.Logger) *CredentialHandler <span class="cov8" title="1">{
        return &amp;CredentialHandler{
                service: service,
                logger:  logger,
        }
}</span>

// Create creates a new credential
func (h *CredentialHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)

        if tenantID == "" || user == nil </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusInternalServerError, "tenant or user context missing")
                return
        }</span>

        <span class="cov8" title="1">var input credential.CreateCredentialInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov8" title="1">cred, err := h.service.Create(r.Context(), tenantID, user.ID, input)
        if err != nil </span><span class="cov8" title="1">{
                if _, ok := err.(*credential.ValidationError); ok </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to create credential",
                        "error", err,
                        "tenant_id", tenantID,
                        "user_id", user.ID)
                h.respondError(w, http.StatusInternalServerError, "failed to create credential")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusCreated, map[string]interface{}{
                "data": cred,
        })</span>
}

// List returns all credentials for the tenant (metadata only)
func (h *CredentialHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)

        if tenantID == "" </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusInternalServerError, "tenant context missing")
                return
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        // Parse filters
        filter := credential.CredentialListFilter{
                Type:   credential.CredentialType(r.URL.Query().Get("type")),
                Status: credential.CredentialStatus(r.URL.Query().Get("status")),
                Search: r.URL.Query().Get("search"),
        }

        credentials, err := h.service.List(r.Context(), tenantID, filter, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list credentials",
                        "error", err,
                        "tenant_id", tenantID)
                h.respondError(w, http.StatusInternalServerError, "failed to list credentials")
                return
        }</span>

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data":   credentials,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// Get retrieves a single credential's metadata
func (h *CredentialHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant context missing")
                return
        }</span>

        <span class="cov8" title="1">cred, err := h.service.GetByID(r.Context(), tenantID, credentialID)
        if err != nil </span><span class="cov8" title="1">{
                if err == credential.ErrNotFound </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get credential",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID)
                h.respondError(w, http.StatusInternalServerError, "failed to get credential")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": cred,
        })</span>
}

// GetValue retrieves the decrypted credential value (restricted access)
func (h *CredentialHandler) GetValue(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" || user == nil </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusInternalServerError, "tenant or user context missing")
                return
        }</span>

        <span class="cov8" title="1">value, err := h.service.GetValue(r.Context(), tenantID, credentialID, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                if err == credential.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov8" title="1">if err == credential.ErrUnauthorized </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusForbidden, "unauthorized access to credential value")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get credential value",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID,
                        "user_id", user.ID)
                h.respondError(w, http.StatusInternalServerError, "failed to get credential value")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": value,
        })</span>
}

// Update updates a credential's metadata
func (h *CredentialHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" || user == nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant or user context missing")
                return
        }</span>

        <span class="cov8" title="1">var input credential.UpdateCredentialInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov8" title="1">cred, err := h.service.Update(r.Context(), tenantID, credentialID, user.ID, input)
        if err != nil </span><span class="cov8" title="1">{
                if err == credential.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov8" title="1">if _, ok := err.(*credential.ValidationError); ok </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update credential",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID,
                        "user_id", user.ID)
                h.respondError(w, http.StatusInternalServerError, "failed to update credential")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": cred,
        })</span>
}

// Delete deletes a credential
func (h *CredentialHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" || user == nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant or user context missing")
                return
        }</span>

        <span class="cov8" title="1">err := h.service.Delete(r.Context(), tenantID, credentialID, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                if err == credential.ErrNotFound </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete credential",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID,
                        "user_id", user.ID)
                h.respondError(w, http.StatusInternalServerError, "failed to delete credential")
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// Rotate creates a new version of the credential value
func (h *CredentialHandler) Rotate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" || user == nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant or user context missing")
                return
        }</span>

        <span class="cov8" title="1">var input credential.RotateCredentialInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov8" title="1">cred, err := h.service.Rotate(r.Context(), tenantID, credentialID, user.ID, input)
        if err != nil </span><span class="cov8" title="1">{
                if err == credential.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov8" title="1">if _, ok := err.(*credential.ValidationError); ok </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to rotate credential",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID,
                        "user_id", user.ID)
                h.respondError(w, http.StatusInternalServerError, "failed to rotate credential")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": cred,
        })</span>
}

// ListVersions returns all versions of a credential
func (h *CredentialHandler) ListVersions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant context missing")
                return
        }</span>

        <span class="cov8" title="1">versions, err := h.service.ListVersions(r.Context(), tenantID, credentialID)
        if err != nil </span><span class="cov0" title="0">{
                if err == credential.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to list credential versions",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID)
                h.respondError(w, http.StatusInternalServerError, "failed to list credential versions")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": versions,
        })</span>
}

// GetAccessLog returns access log entries for a credential
func (h *CredentialHandler) GetAccessLog(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        credentialID := chi.URLParam(r, "credentialID")

        if tenantID == "" </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant context missing")
                return
        }</span>

        <span class="cov8" title="1">limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        logs, err := h.service.GetAccessLog(r.Context(), tenantID, credentialID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                if err == credential.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "credential not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get access log",
                        "error", err,
                        "tenant_id", tenantID,
                        "credential_id", credentialID)
                h.respondError(w, http.StatusInternalServerError, "failed to get access log")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data":   logs,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// Helper methods

func (h *CredentialHandler) respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func (h *CredentialHandler) respondError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        h.respondJSON(w, status, map[string]string{
                "error": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/go-chi/chi/v5"

        "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/workflow"
)

// ExecutionService defines the methods needed from workflow service
type ExecutionService interface {
        ListExecutionsAdvanced(ctx context.Context, tenantID string, filter workflow.ExecutionFilter, cursor string, limit int) (*workflow.ExecutionListResult, error)
        GetExecutionWithSteps(ctx context.Context, tenantID, executionID string) (*workflow.ExecutionWithSteps, error)
        GetExecutionStats(ctx context.Context, tenantID string, filter workflow.ExecutionFilter) (*workflow.ExecutionStats, error)
}

// ExecutionHandler handles execution-related HTTP requests
type ExecutionHandler struct {
        service ExecutionService
        logger  *slog.Logger
}

// NewExecutionHandler creates a new execution handler
func NewExecutionHandler(service ExecutionService, logger *slog.Logger) *ExecutionHandler <span class="cov8" title="1">{
        return &amp;ExecutionHandler{
                service: service,
                logger:  logger,
        }
}</span>

// ListExecutionsAdvanced returns executions with advanced filtering and cursor pagination
// GET /api/v1/executions
func (h *ExecutionHandler) ListExecutionsAdvanced(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        if tenantID == "" </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusInternalServerError, "tenant ID not found")
                return
        }</span>

        <span class="cov8" title="1">filter, err := h.parseExecutionFilter(r)
        if err != nil </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusBadRequest, "invalid filter parameters: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">cursor := r.URL.Query().Get("cursor")
        limit := h.parseLimit(r)

        result, err := h.service.ListExecutionsAdvanced(r.Context(), tenantID, filter, cursor, limit)
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*workflow.ValidationError); ok </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to list executions",
                        "error", err,
                        "tenant_id", tenantID,
                )
                h.respondError(w, http.StatusInternalServerError, "failed to list executions")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, result)</span>
}

// GetExecutionWithSteps retrieves an execution with all its step executions
// GET /api/v1/executions/:executionID/steps
func (h *ExecutionHandler) GetExecutionWithSteps(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        if tenantID == "" </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "tenant ID not found")
                return
        }</span>

        <span class="cov8" title="1">executionID := chi.URLParam(r, "executionID")
        if executionID == "" </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "execution ID is required")
                return
        }</span>

        <span class="cov8" title="1">result, err := h.service.GetExecutionWithSteps(r.Context(), tenantID, executionID)
        if err != nil </span><span class="cov8" title="1">{
                if err == workflow.ErrNotFound </span><span class="cov8" title="1">{
                        h.respondError(w, http.StatusNotFound, "execution not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get execution with steps",
                        "error", err,
                        "tenant_id", tenantID,
                        "execution_id", executionID,
                )
                h.respondError(w, http.StatusInternalServerError, "failed to get execution")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, result)</span>
}

// GetExecutionStats returns execution statistics grouped by status
// GET /api/v1/executions/stats
func (h *ExecutionHandler) GetExecutionStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        tenantID := middleware.GetTenantID(r)
        if tenantID == "" </span><span class="cov8" title="1">{
                h.respondError(w, http.StatusInternalServerError, "tenant ID not found")
                return
        }</span>

        <span class="cov8" title="1">filter, err := h.parseExecutionFilter(r)
        if err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid filter parameters: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">stats, err := h.service.GetExecutionStats(r.Context(), tenantID, filter)
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*workflow.ValidationError); ok </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get execution stats",
                        "error", err,
                        "tenant_id", tenantID,
                )
                h.respondError(w, http.StatusInternalServerError, "failed to get execution stats")
                return</span>
        }

        <span class="cov8" title="1">h.respondJSON(w, http.StatusOK, stats)</span>
}

// parseExecutionFilter parses execution filter from query parameters
func (h *ExecutionHandler) parseExecutionFilter(r *http.Request) (workflow.ExecutionFilter, error) <span class="cov8" title="1">{
        filter := workflow.ExecutionFilter{
                WorkflowID:  r.URL.Query().Get("workflow_id"),
                Status:      r.URL.Query().Get("status"),
                TriggerType: r.URL.Query().Get("trigger_type"),
        }

        if startDateStr := r.URL.Query().Get("start_date"); startDateStr != "" </span><span class="cov8" title="1">{
                startDate, err := time.Parse(time.RFC3339, startDateStr)
                if err != nil </span><span class="cov8" title="1">{
                        return filter, err
                }</span>
                <span class="cov0" title="0">filter.StartDate = &amp;startDate</span>
        }

        <span class="cov8" title="1">if endDateStr := r.URL.Query().Get("end_date"); endDateStr != "" </span><span class="cov0" title="0">{
                endDate, err := time.Parse(time.RFC3339, endDateStr)
                if err != nil </span><span class="cov0" title="0">{
                        return filter, err
                }</span>
                <span class="cov0" title="0">filter.EndDate = &amp;endDate</span>
        }

        <span class="cov8" title="1">return filter, nil</span>
}

// parseLimit parses and validates the limit query parameter
func (h *ExecutionHandler) parseLimit(r *http.Request) int <span class="cov8" title="1">{
        limitStr := r.URL.Query().Get("limit")
        if limitStr == "" </span><span class="cov8" title="1">{
                return 0 // Will use service default
        }</span>

        <span class="cov8" title="1">limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 0 </span><span class="cov0" title="0">{
                return 0 // Will use service default
        }</span>

        <span class="cov8" title="1">return limit</span>
}

// Helper methods

func (h *ExecutionHandler) respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to encode response", "error", err)
        }</span>
}

func (h *ExecutionHandler) respondError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        h.respondJSON(w, status, map[string]string{
                "error": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "github.com/jmoiron/sqlx"
        "github.com/redis/go-redis/v9"
)

// HealthHandler handles health check endpoints
type HealthHandler struct {
        db    *sqlx.DB
        redis *redis.Client
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(db *sqlx.DB, redis *redis.Client) *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{
                db:    db,
                redis: redis,
        }
}</span>

// HealthResponse represents the health check response
type HealthResponse struct {
        Status    string            `json:"status"`
        Timestamp string            `json:"timestamp"`
        Checks    map[string]string `json:"checks,omitempty"`
}

// Health returns basic health status
func (h *HealthHandler) Health(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        resp := HealthResponse{
                Status:    "ok",
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(resp)
}</span>

// Ready returns readiness status including dependency checks
func (h *HealthHandler) Ready(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
        defer cancel()

        checks := make(map[string]string)
        allHealthy := true

        // Check database
        if err := h.db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                checks["database"] = "unhealthy: " + err.Error()
                allHealthy = false
        }</span> else<span class="cov0" title="0"> {
                checks["database"] = "healthy"
        }</span>

        // Check Redis
        <span class="cov0" title="0">if err := h.redis.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                checks["redis"] = "unhealthy: " + err.Error()
                allHealthy = false
        }</span> else<span class="cov0" title="0"> {
                checks["redis"] = "healthy"
        }</span>

        <span class="cov0" title="0">status := "ok"
        statusCode := http.StatusOK
        if !allHealthy </span><span class="cov0" title="0">{
                status = "degraded"
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov0" title="0">resp := HealthResponse{
                Status:    status,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
                Checks:    checks,
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(resp)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/schedule"
)

// ScheduleHandler handles schedule-related HTTP requests
type ScheduleHandler struct {
        service *schedule.Service
        logger  *slog.Logger
}

// NewScheduleHandler creates a new schedule handler
func NewScheduleHandler(service *schedule.Service, logger *slog.Logger) *ScheduleHandler <span class="cov0" title="0">{
        return &amp;ScheduleHandler{
                service: service,
                logger:  logger,
        }
}</span>

// Create creates a new schedule for a workflow
func (h *ScheduleHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)
        workflowID := chi.URLParam(r, "workflowID")

        var input schedule.CreateScheduleInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov0" title="0">sched, err := h.service.Create(r.Context(), tenantID, workflowID, user.ID, input)
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*schedule.ValidationError); ok </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to create schedule", "error", err)
                h.respondError(w, http.StatusInternalServerError, "failed to create schedule")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusCreated, map[string]interface{}{
                "data": sched,
        })</span>
}

// List returns all schedules for a workflow
func (h *ScheduleHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        workflowID := chi.URLParam(r, "workflowID")

        limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        schedules, err := h.service.List(r.Context(), tenantID, workflowID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list schedules", "error", err)
                h.respondError(w, http.StatusInternalServerError, "failed to list schedules")
                return
        }</span>

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data":   schedules,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// ListAll returns all schedules for the tenant
func (h *ScheduleHandler) ListAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)

        limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        schedules, err := h.service.ListAll(r.Context(), tenantID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list all schedules", "error", err)
                h.respondError(w, http.StatusInternalServerError, "failed to list schedules")
                return
        }</span>

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data":   schedules,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// Get retrieves a single schedule
func (h *ScheduleHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        scheduleID := chi.URLParam(r, "scheduleID")

        sched, err := h.service.GetByID(r.Context(), tenantID, scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == schedule.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "schedule not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get schedule", "error", err)
                h.respondError(w, http.StatusInternalServerError, "failed to get schedule")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": sched,
        })</span>
}

// Update updates a schedule
func (h *ScheduleHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        scheduleID := chi.URLParam(r, "scheduleID")

        var input schedule.UpdateScheduleInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov0" title="0">sched, err := h.service.Update(r.Context(), tenantID, scheduleID, input)
        if err != nil </span><span class="cov0" title="0">{
                if err == schedule.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "schedule not found")
                        return
                }</span>
                <span class="cov0" title="0">if _, ok := err.(*schedule.ValidationError); ok </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update schedule", "error", err)
                h.respondError(w, http.StatusInternalServerError, "failed to update schedule")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": sched,
        })</span>
}

// Delete deletes a schedule
func (h *ScheduleHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        scheduleID := chi.URLParam(r, "scheduleID")

        err := h.service.Delete(r.Context(), tenantID, scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == schedule.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "schedule not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete schedule", "error", err)
                h.respondError(w, http.StatusInternalServerError, "failed to delete schedule")
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// ParseCron validates a cron expression and returns next run times
func (h *ScheduleHandler) ParseCron(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input struct {
                CronExpression string `json:"cron_expression"`
                Timezone       string `json:"timezone"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        // Default timezone to UTC
        <span class="cov0" title="0">if input.Timezone == "" </span><span class="cov0" title="0">{
                input.Timezone = "UTC"
        }</span>

        // Calculate next 5 run times
        <span class="cov0" title="0">nextRun, err := h.service.ParseNextRunTime(input.CronExpression, input.Timezone)
        if err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid cron expression: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "valid":    true,
                "next_run": nextRun,
        })</span>
}

// Helper methods

func (h *ScheduleHandler) respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func (h *ScheduleHandler) respondError(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        h.respondJSON(w, status, map[string]string{
                "error": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"
        "github.com/gorax/gorax/internal/tenant"
)

// TenantAdminHandler handles tenant administration endpoints
type TenantAdminHandler struct {
        tenantService *tenant.Service
        logger        *slog.Logger
}

// NewTenantAdminHandler creates a new tenant admin handler
func NewTenantAdminHandler(tenantService *tenant.Service, logger *slog.Logger) *TenantAdminHandler <span class="cov0" title="0">{
        return &amp;TenantAdminHandler{
                tenantService: tenantService,
                logger:        logger,
        }
}</span>

// CreateTenant handles POST /api/v1/admin/tenants
func (h *TenantAdminHandler) CreateTenant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input tenant.CreateTenantInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode create tenant request", "error", err)
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        // TODO: Add validation using validator
        <span class="cov0" title="0">if input.Name == "" || input.Subdomain == "" </span><span class="cov0" title="0">{
                http.Error(w, "name and subdomain are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">t, err := h.tenantService.Create(r.Context(), input)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to create tenant", "error", err)
                http.Error(w, "failed to create tenant: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(t)</span>
}

// ListTenants handles GET /api/v1/admin/tenants
func (h *TenantAdminHandler) ListTenants(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse pagination parameters
        limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">tenants, err := h.tenantService.List(r.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to list tenants", "error", err)
                http.Error(w, "failed to list tenants", http.StatusInternalServerError)
                return
        }</span>

        // Get total count for pagination
        <span class="cov0" title="0">total, err := h.tenantService.Count(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn("failed to get tenant count", "error", err)
                total = 0
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "data": tenants,
                "pagination": map[string]interface{}{
                        "limit":  limit,
                        "offset": offset,
                        "total":  total,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// GetTenant handles GET /api/v1/admin/tenants/{id}
func (h *TenantAdminHandler) GetTenant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := chi.URLParam(r, "tenantID")
        if tenantID == "" </span><span class="cov0" title="0">{
                http.Error(w, "tenant ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">t, err := h.tenantService.GetByID(r.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if err == tenant.ErrNotFound </span><span class="cov0" title="0">{
                        http.Error(w, "tenant not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get tenant", "error", err, "tenant_id", tenantID)
                http.Error(w, "failed to get tenant", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(t)</span>
}

// UpdateTenant handles PUT /api/v1/admin/tenants/{id}
func (h *TenantAdminHandler) UpdateTenant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := chi.URLParam(r, "tenantID")
        if tenantID == "" </span><span class="cov0" title="0">{
                http.Error(w, "tenant ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var input tenant.UpdateTenantInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode update tenant request", "error", err)
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">t, err := h.tenantService.Update(r.Context(), tenantID, input)
        if err != nil </span><span class="cov0" title="0">{
                if err == tenant.ErrNotFound </span><span class="cov0" title="0">{
                        http.Error(w, "tenant not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update tenant", "error", err, "tenant_id", tenantID)
                http.Error(w, "failed to update tenant: "+err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(t)</span>
}

// DeleteTenant handles DELETE /api/v1/admin/tenants/{id}
func (h *TenantAdminHandler) DeleteTenant(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := chi.URLParam(r, "tenantID")
        if tenantID == "" </span><span class="cov0" title="0">{
                http.Error(w, "tenant ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.tenantService.Delete(r.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if err == tenant.ErrNotFound </span><span class="cov0" title="0">{
                        http.Error(w, "tenant not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to delete tenant", "error", err, "tenant_id", tenantID)
                http.Error(w, "failed to delete tenant", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// UpdateTenantQuotas handles PUT /api/v1/admin/tenants/{id}/quotas
func (h *TenantAdminHandler) UpdateTenantQuotas(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := chi.URLParam(r, "tenantID")
        if tenantID == "" </span><span class="cov0" title="0">{
                http.Error(w, "tenant ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var quotas tenant.TenantQuotas
        if err := json.NewDecoder(r.Body).Decode(&amp;quotas); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to decode quotas request", "error", err)
                http.Error(w, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">t, err := h.tenantService.UpdateQuotas(r.Context(), tenantID, quotas)
        if err != nil </span><span class="cov0" title="0">{
                if err == tenant.ErrNotFound </span><span class="cov0" title="0">{
                        http.Error(w, "tenant not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to update tenant quotas", "error", err, "tenant_id", tenantID)
                http.Error(w, "failed to update quotas: "+err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "tenant": t,
                "quotas": quotas,
        })</span>
}

// GetTenantUsage handles GET /api/v1/admin/tenants/{id}/usage
func (h *TenantAdminHandler) GetTenantUsage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := chi.URLParam(r, "tenantID")
        if tenantID == "" </span><span class="cov0" title="0">{
                http.Error(w, "tenant ID is required", http.StatusBadRequest)
                return
        }</span>

        // Get tenant to verify it exists
        <span class="cov0" title="0">t, err := h.tenantService.GetByID(r.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if err == tenant.ErrNotFound </span><span class="cov0" title="0">{
                        http.Error(w, "tenant not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get tenant", "error", err, "tenant_id", tenantID)
                http.Error(w, "failed to get tenant", http.StatusInternalServerError)
                return</span>
        }

        // Get usage statistics
        <span class="cov0" title="0">stats, err := h.tenantService.GetExecutionStats(r.Context(), tenantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get usage stats", "error", err, "tenant_id", tenantID)
                http.Error(w, "failed to get usage stats", http.StatusInternalServerError)
                return
        }</span>

        // Parse quotas for comparison
        <span class="cov0" title="0">var quotas tenant.TenantQuotas
        if err := json.Unmarshal(t.Quotas, &amp;quotas); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to parse quotas", "error", err, "tenant_id", tenantID)
                quotas = tenant.DefaultQuotas(t.Tier)
        }</span>

        <span class="cov0" title="0">response := map[string]interface{}{
                "tenant_id": tenantID,
                "usage":     stats,
                "quotas":    quotas,
                "utilization": map[string]interface{}{
                        "workflows_percentage":            calculatePercentage(stats.WorkflowCount, quotas.MaxWorkflows),
                        "executions_today_percentage":     calculatePercentage(stats.ExecutionsToday, quotas.MaxExecutionsPerDay),
                        "concurrent_executions_percentage": calculatePercentage(stats.ConcurrentExecutions, quotas.MaxConcurrentExecutions),
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// calculatePercentage calculates usage percentage, handling unlimited quotas (-1)
func calculatePercentage(current, max int) float64 <span class="cov8" title="1">{
        if max == -1 </span><span class="cov8" title="1">{
                return 0.0 // Unlimited
        }</span>
        <span class="cov8" title="1">if max == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">percentage := (float64(current) / float64(max)) * 100.0
        if percentage &gt; 100.0 </span><span class="cov8" title="1">{
                return 100.0
        }</span>
        <span class="cov8" title="1">return percentage</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/quota"
        "github.com/gorax/gorax/internal/tenant"
)

// UsageService defines the interface for usage operations
type UsageService interface {
        GetCurrentUsage(ctx context.Context, tenantID string) (*UsageResponse, error)
        GetUsageHistory(ctx context.Context, tenantID string, startDate, endDate time.Time, page, limit int) ([]quota.UsageByDate, int, error)
        GetRateLimitHits(ctx context.Context, tenantID string, period quota.Period) (int64, error)
}

// UsageHandler handles usage-related HTTP requests
type UsageHandler struct {
        service UsageService
        logger  *slog.Logger
}

// NewUsageHandler creates a new usage handler
func NewUsageHandler(service UsageService) *UsageHandler <span class="cov8" title="1">{
        return &amp;UsageHandler{
                service: service,
                logger:  slog.Default(),
        }
}</span>

// UsageResponse represents current usage statistics
type UsageResponse struct {
        TenantID      string       `json:"tenant_id"`
        CurrentPeriod PeriodUsage  `json:"current_period"`
        MonthToDate   PeriodUsage  `json:"month_to_date"`
        Quotas        QuotaInfo    `json:"quotas"`
        RateLimits    RateLimitInfo `json:"rate_limits"`
}

// PeriodUsage represents usage for a specific period
type PeriodUsage struct {
        WorkflowExecutions int64  `json:"workflow_executions"`
        StepExecutions     int64  `json:"step_executions"`
        Period             string `json:"period"`
}

// QuotaInfo represents quota information
type QuotaInfo struct {
        MaxExecutionsPerDay     int     `json:"max_executions_per_day"`
        MaxExecutionsPerMonth   int     `json:"max_executions_per_month"`
        ExecutionsRemaining     int64   `json:"executions_remaining"`
        QuotaPercentUsed        float64 `json:"quota_percent_used"`
        MaxConcurrentExecutions int     `json:"max_concurrent_executions"`
        MaxWorkflows            int     `json:"max_workflows"`
}

// RateLimitInfo represents rate limit information
type RateLimitInfo struct {
        RequestsPerMinute int   `json:"requests_per_minute"`
        RequestsPerHour   int   `json:"requests_per_hour"`
        RequestsPerDay    int   `json:"requests_per_day"`
        HitsToday         int64 `json:"hits_today"`
}

// UsageHistoryResponse represents historical usage data
type UsageHistoryResponse struct {
        Usage      []quota.UsageByDate `json:"usage"`
        Total      int                 `json:"total"`
        Page       int                 `json:"page"`
        Limit      int                 `json:"limit"`
        StartDate  string              `json:"start_date"`
        EndDate    string              `json:"end_date"`
}

// GetCurrentUsage returns current usage statistics for a tenant
func (h *UsageHandler) GetCurrentUsage(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Get tenant from context
        t := middleware.GetTenant(r)
        if t == nil </span><span class="cov8" title="1">{
                http.Error(w, "tenant not found in context", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">tenantID := chi.URLParam(r, "id")
        if tenantID != t.ID </span><span class="cov0" title="0">{
                http.Error(w, "unauthorized", http.StatusForbidden)
                return
        }</span>

        <span class="cov8" title="1">usage, err := h.service.GetCurrentUsage(ctx, tenantID)
        if err != nil </span><span class="cov8" title="1">{
                h.logger.Error("failed to get current usage",
                        "error", err,
                        "tenant_id", tenantID,
                )
                http.Error(w, "failed to get usage", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(usage)</span>
}

// GetUsageHistory returns historical usage data for a tenant
func (h *UsageHandler) GetUsageHistory(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        // Get tenant from context
        t := middleware.GetTenant(r)
        if t == nil </span><span class="cov0" title="0">{
                http.Error(w, "tenant not found in context", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">tenantID := chi.URLParam(r, "id")
        if tenantID != t.ID </span><span class="cov0" title="0">{
                http.Error(w, "unauthorized", http.StatusForbidden)
                return
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">startDateStr := r.URL.Query().Get("start_date")
        endDateStr := r.URL.Query().Get("end_date")

        startDate, endDate, err := parseDateRange(startDateStr, endDateStr)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, fmt.Sprintf("invalid date format: %v", err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">page := parseIntParam(r.URL.Query().Get("page"), 1)
        limit := parseIntParam(r.URL.Query().Get("limit"), 30)

        // Validate limits
        if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov8" title="1">if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 30
        }</span>
        <span class="cov8" title="1">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov8" title="1">usage, total, err := h.service.GetUsageHistory(ctx, tenantID, startDate, endDate, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get usage history",
                        "error", err,
                        "tenant_id", tenantID,
                )
                http.Error(w, "failed to get usage history", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">response := UsageHistoryResponse{
                Usage:     usage,
                Total:     total,
                Page:      page,
                Limit:     limit,
                StartDate: startDate.Format("2006-01-02"),
                EndDate:   endDate.Format("2006-01-02"),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// parseDateRange parses start and end date strings
func parseDateRange(startStr, endStr string) (time.Time, time.Time, error) <span class="cov8" title="1">{
        var startDate, endDate time.Time
        var err error

        if startStr == "" </span><span class="cov8" title="1">{
                // Default to last 30 days
                endDate = time.Now()
                startDate = endDate.AddDate(0, 0, -30)
        }</span> else<span class="cov8" title="1"> {
                startDate, err = time.Parse("2006-01-02", startStr)
                if err != nil </span><span class="cov8" title="1">{
                        return time.Time{}, time.Time{}, fmt.Errorf("invalid start_date format: %w", err)
                }</span>

                <span class="cov8" title="1">if endStr == "" </span><span class="cov0" title="0">{
                        endDate = time.Now()
                }</span> else<span class="cov8" title="1"> {
                        endDate, err = time.Parse("2006-01-02", endStr)
                        if err != nil </span><span class="cov8" title="1">{
                                return time.Time{}, time.Time{}, fmt.Errorf("invalid end_date format: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return startDate, endDate, nil</span>
}

// parseIntParam parses an integer parameter with a default value
func parseIntParam(s string, defaultValue int) int <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return defaultValue
        }</span>

        <span class="cov8" title="1">val, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov8" title="1">return val</span>
}

// UsageServiceImpl implements UsageService
type UsageServiceImpl struct {
        tracker       *quota.Tracker
        tenantService *tenant.Service
        logger        *slog.Logger
}

// NewUsageService creates a new usage service
func NewUsageService(tracker *quota.Tracker, tenantService *tenant.Service, logger *slog.Logger) *UsageServiceImpl <span class="cov0" title="0">{
        return &amp;UsageServiceImpl{
                tracker:       tracker,
                tenantService: tenantService,
                logger:        logger,
        }
}</span>

// GetCurrentUsage returns current usage statistics
func (s *UsageServiceImpl) GetCurrentUsage(ctx context.Context, tenantID string) (*UsageResponse, error) <span class="cov0" title="0">{
        // Get tenant to retrieve quotas
        t, err := s.tenantService.GetByID(ctx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tenant: %w", err)
        }</span>

        // Parse quotas
        <span class="cov0" title="0">var quotas tenant.TenantQuotas
        if err := json.Unmarshal(t.Quotas, &amp;quotas); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse quotas: %w", err)
        }</span>

        // Get current usage
        <span class="cov0" title="0">dailyWorkflow, err := s.tracker.GetWorkflowExecutions(ctx, tenantID, quota.PeriodDaily)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get daily workflow executions: %w", err)
        }</span>

        <span class="cov0" title="0">dailySteps, err := s.tracker.GetStepExecutions(ctx, tenantID, quota.PeriodDaily)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get daily step executions: %w", err)
        }</span>

        <span class="cov0" title="0">monthlyWorkflow, err := s.tracker.GetWorkflowExecutions(ctx, tenantID, quota.PeriodMonthly)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get monthly workflow executions: %w", err)
        }</span>

        <span class="cov0" title="0">monthlySteps, err := s.tracker.GetStepExecutions(ctx, tenantID, quota.PeriodMonthly)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get monthly step executions: %w", err)
        }</span>

        // Calculate remaining quota
        <span class="cov0" title="0">var remaining int64
        var percentUsed float64

        if quotas.MaxExecutionsPerDay == -1 </span><span class="cov0" title="0">{
                remaining = -1
                percentUsed = 0.0
        }</span> else<span class="cov0" title="0"> {
                remaining = int64(quotas.MaxExecutionsPerDay) - dailyWorkflow
                if remaining &lt; 0 </span><span class="cov0" title="0">{
                        remaining = 0
                }</span>
                <span class="cov0" title="0">percentUsed = (float64(dailyWorkflow) / float64(quotas.MaxExecutionsPerDay)) * 100</span>
        }

        // Get rate limit hits
        <span class="cov0" title="0">rateLimitHits, err := s.GetRateLimitHits(ctx, tenantID, quota.PeriodDaily)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("failed to get rate limit hits", "error", err)
                rateLimitHits = 0
        }</span>

        <span class="cov0" title="0">return &amp;UsageResponse{
                TenantID: tenantID,
                CurrentPeriod: PeriodUsage{
                        WorkflowExecutions: dailyWorkflow,
                        StepExecutions:     dailySteps,
                        Period:             "daily",
                },
                MonthToDate: PeriodUsage{
                        WorkflowExecutions: monthlyWorkflow,
                        StepExecutions:     monthlySteps,
                        Period:             "monthly",
                },
                Quotas: QuotaInfo{
                        MaxExecutionsPerDay:     quotas.MaxExecutionsPerDay,
                        MaxExecutionsPerMonth:   -1, // Not currently tracked
                        ExecutionsRemaining:     remaining,
                        QuotaPercentUsed:        percentUsed,
                        MaxConcurrentExecutions: quotas.MaxConcurrentExecutions,
                        MaxWorkflows:            quotas.MaxWorkflows,
                },
                RateLimits: RateLimitInfo{
                        RequestsPerMinute: quotas.MaxAPICallsPerMinute,
                        RequestsPerHour:   -1, // Not currently set
                        RequestsPerDay:    -1, // Not currently set
                        HitsToday:         rateLimitHits,
                },
        }, nil</span>
}

// GetUsageHistory returns historical usage data
func (s *UsageServiceImpl) GetUsageHistory(ctx context.Context, tenantID string, startDate, endDate time.Time, page, limit int) ([]quota.UsageByDate, int, error) <span class="cov0" title="0">{
        usage, err := s.tracker.GetUsageByDateRange(ctx, tenantID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get usage history: %w", err)
        }</span>

        // Apply pagination
        <span class="cov0" title="0">total := len(usage)
        start := (page - 1) * limit
        end := start + limit

        if start &gt;= total </span><span class="cov0" title="0">{
                return []quota.UsageByDate{}, total, nil
        }</span>

        <span class="cov0" title="0">if end &gt; total </span><span class="cov0" title="0">{
                end = total
        }</span>

        <span class="cov0" title="0">return usage[start:end], total, nil</span>
}

// GetRateLimitHits returns rate limit hits for a period
func (s *UsageServiceImpl) GetRateLimitHits(ctx context.Context, tenantID string, period quota.Period) (int64, error) <span class="cov0" title="0">{
        // This would require additional tracking in the rate limiter
        // For now, return 0
        return 0, nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "log/slog"
        "net/http"

        "github.com/go-chi/chi/v5"

        "github.com/gorax/gorax/internal/webhook"
        "github.com/gorax/gorax/internal/workflow"
)

// WebhookHandler handles incoming webhook requests
type WebhookHandler struct {
        workflowService *workflow.Service
        webhookService  *webhook.Service
        logger          *slog.Logger
}

// NewWebhookHandler creates a new webhook handler
func NewWebhookHandler(workflowService *workflow.Service, webhookService *webhook.Service, logger *slog.Logger) *WebhookHandler <span class="cov0" title="0">{
        return &amp;WebhookHandler{
                workflowService: workflowService,
                webhookService:  webhookService,
                logger:          logger,
        }
}</span>

// Handle processes incoming webhook requests
func (h *WebhookHandler) Handle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        workflowID := chi.URLParam(r, "workflowID")
        webhookID := chi.URLParam(r, "webhookID")

        h.logger.Info("webhook received", "workflow_id", workflowID, "webhook_id", webhookID)

        // Look up webhook configuration
        webhookConfig, err := h.webhookService.GetByWorkflowAndWebhookID(r.Context(), workflowID, webhookID)
        if err != nil </span><span class="cov0" title="0">{
                if err == webhook.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "webhook not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to get webhook config", "error", err, "webhook_id", webhookID)
                h.respondError(w, http.StatusInternalServerError, "failed to process webhook")
                return</span>
        }

        // Read request body
        <span class="cov0" title="0">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "failed to read request body")
                return
        }</span>

        // Verify signature if required
        <span class="cov0" title="0">if webhookConfig.AuthType == webhook.AuthTypeSignature </span><span class="cov0" title="0">{
                signature := r.Header.Get("X-Webhook-Signature")
                if signature == "" </span><span class="cov0" title="0">{
                        // Also check for X-Hub-Signature-256 (GitHub style)
                        signature = r.Header.Get("X-Hub-Signature-256")
                }</span>

                <span class="cov0" title="0">if !h.webhookService.VerifySignature(body, signature, webhookConfig.Secret) </span><span class="cov0" title="0">{
                        h.logger.Warn("webhook signature verification failed", "webhook_id", webhookID)
                        h.respondError(w, http.StatusUnauthorized, "invalid signature")
                        return
                }</span>
        }

        // Build trigger data
        <span class="cov0" title="0">triggerData := map[string]interface{}{
                "method":  r.Method,
                "headers": flattenHeaders(r.Header),
                "query":   flattenQuery(r.URL.Query()),
                "body":    json.RawMessage(body),
        }

        triggerDataJSON, err := json.Marshal(triggerData)
        if err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "failed to process trigger data")
                return
        }</span>

        // Execute workflow using tenant ID from webhook config
        <span class="cov0" title="0">execution, err := h.workflowService.Execute(r.Context(), webhookConfig.TenantID, workflowID, "webhook", triggerDataJSON)
        if err != nil </span><span class="cov0" title="0">{
                if err == workflow.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "workflow not found")
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error("failed to execute workflow from webhook", "error", err, "workflow_id", workflowID)
                h.respondError(w, http.StatusInternalServerError, "failed to execute workflow")
                return</span>
        }

        <span class="cov0" title="0">h.logger.Info("workflow execution triggered", "execution_id", execution.ID, "workflow_id", workflowID)

        // Return execution ID
        h.respondJSON(w, http.StatusAccepted, map[string]interface{}{
                "execution_id": execution.ID,
                "status":       execution.Status,
        })</span>
}

func flattenHeaders(headers http.Header) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for key, values := range headers </span><span class="cov0" title="0">{
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        result[key] = values[0]
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func flattenQuery(query map[string][]string) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)
        for key, values := range query </span><span class="cov0" title="0">{
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        result[key] = values[0]
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func (h *WebhookHandler) respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func (h *WebhookHandler) respondError(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        h.respondJSON(w, status, map[string]string{
                "error": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "log/slog"
        "net/http"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "github.com/gorilla/websocket"

        "github.com/gorax/gorax/internal/api/middleware"
        ws "github.com/gorax/gorax/internal/websocket"
)

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                // In production, validate origin against allowed domains
                // For now, allow all origins (matches CORS config)
                return true
        }</span>,
}

// WebSocketHandler handles WebSocket connections
type WebSocketHandler struct {
        hub    *ws.Hub
        logger *slog.Logger
}

// NewWebSocketHandler creates a new WebSocket handler
func NewWebSocketHandler(hub *ws.Hub, logger *slog.Logger) *WebSocketHandler <span class="cov0" title="0">{
        return &amp;WebSocketHandler{
                hub:    hub,
                logger: logger,
        }
}</span>

// HandleConnection handles WebSocket connection upgrades
func (h *WebSocketHandler) HandleConnection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // User is already authenticated via middleware
        user := middleware.GetUser(r)
        if user == nil </span><span class="cov0" title="0">{
                http.Error(w, "unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">tenantID := middleware.GetTenantID(r)

        // Upgrade HTTP connection to WebSocket
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to upgrade connection", "error", err)
                return
        }</span>

        // Create client
        <span class="cov0" title="0">client := &amp;ws.Client{
                ID:            uuid.New().String(),
                TenantID:      tenantID,
                Conn:          conn,
                Hub:           h.hub,
                Send:          make(chan []byte, 256),
                Subscriptions: make(map[string]bool),
        }

        // Register client with hub
        h.hub.Register &lt;- client

        // Parse subscription parameters
        h.handleSubscriptions(r, client)

        // Start client pumps
        go client.WritePump()
        go client.ReadPump()

        h.logger.Info("websocket connection established",
                "client_id", client.ID,
                "tenant_id", tenantID,
                "user_id", user.ID,
        )</span>
}

// handleSubscriptions processes subscription query parameters
func (h *WebSocketHandler) handleSubscriptions(r *http.Request, client *ws.Client) <span class="cov0" title="0">{
        // Get subscription parameters from query string
        executionID := r.URL.Query().Get("execution_id")
        workflowID := r.URL.Query().Get("workflow_id")
        subscribeTenant := r.URL.Query().Get("subscribe_tenant")

        // Subscribe to specific execution
        if executionID != "" </span><span class="cov0" title="0">{
                room := "execution:" + executionID
                h.hub.SubscribeClient(client, room)
                h.logger.Info("client subscribed to execution",
                        "client_id", client.ID,
                        "execution_id", executionID,
                )
        }</span>

        // Subscribe to workflow updates
        <span class="cov0" title="0">if workflowID != "" </span><span class="cov0" title="0">{
                room := "workflow:" + workflowID
                h.hub.SubscribeClient(client, room)
                h.logger.Info("client subscribed to workflow",
                        "client_id", client.ID,
                        "workflow_id", workflowID,
                )
        }</span>

        // Subscribe to tenant-wide updates (for dashboard)
        <span class="cov0" title="0">if subscribeTenant == "true" </span><span class="cov0" title="0">{
                room := "tenant:" + client.TenantID
                h.hub.SubscribeClient(client, room)
                h.logger.Info("client subscribed to tenant",
                        "client_id", client.ID,
                        "tenant_id", client.TenantID,
                )
        }</span>
}

// HandleExecutionConnection is a convenience endpoint for execution-specific subscriptions
func (h *WebSocketHandler) HandleExecutionConnection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        executionID := chi.URLParam(r, "executionID")
        if executionID == "" </span><span class="cov0" title="0">{
                http.Error(w, "execution_id required", http.StatusBadRequest)
                return
        }</span>

        // Add execution_id to query params for the main handler
        <span class="cov0" title="0">q := r.URL.Query()
        q.Set("execution_id", executionID)
        r.URL.RawQuery = q.Encode()

        h.HandleConnection(w, r)</span>
}

// HandleWorkflowConnection is a convenience endpoint for workflow-specific subscriptions
func (h *WebSocketHandler) HandleWorkflowConnection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        workflowID := chi.URLParam(r, "workflowID")
        if workflowID == "" </span><span class="cov0" title="0">{
                http.Error(w, "workflow_id required", http.StatusBadRequest)
                return
        }</span>

        // Add workflow_id to query params for the main handler
        <span class="cov0" title="0">q := r.URL.Query()
        q.Set("workflow_id", workflowID)
        r.URL.RawQuery = q.Encode()

        h.HandleConnection(w, r)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/gorax/gorax/internal/api/middleware"
        "github.com/gorax/gorax/internal/workflow"
)

// WorkflowHandler handles workflow-related HTTP requests
type WorkflowHandler struct {
        service *workflow.Service
        logger  *slog.Logger
}

// NewWorkflowHandler creates a new workflow handler
func NewWorkflowHandler(service *workflow.Service, logger *slog.Logger) *WorkflowHandler <span class="cov0" title="0">{
        return &amp;WorkflowHandler{
                service: service,
                logger:  logger,
        }
}</span>

// List returns all workflows for the tenant
func (h *WorkflowHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)

        limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        workflows, err := h.service.List(r.Context(), tenantID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "failed to list workflows")
                return
        }</span>

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data":   workflows,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// Create creates a new workflow
func (h *WorkflowHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        user := middleware.GetUser(r)

        var input workflow.CreateWorkflowInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov0" title="0">wf, err := h.service.Create(r.Context(), tenantID, user.ID, input)
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*workflow.ValidationError); ok </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.respondError(w, http.StatusInternalServerError, "failed to create workflow")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusCreated, map[string]interface{}{
                "data": wf,
        })</span>
}

// Get retrieves a single workflow
func (h *WorkflowHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        workflowID := chi.URLParam(r, "workflowID")

        wf, err := h.service.GetByID(r.Context(), tenantID, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                if err == workflow.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "workflow not found")
                        return
                }</span>
                <span class="cov0" title="0">h.respondError(w, http.StatusInternalServerError, "failed to get workflow")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": wf,
        })</span>
}

// Update updates a workflow
func (h *WorkflowHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        workflowID := chi.URLParam(r, "workflowID")

        var input workflow.UpdateWorkflowInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov0" title="0">wf, err := h.service.Update(r.Context(), tenantID, workflowID, input)
        if err != nil </span><span class="cov0" title="0">{
                if err == workflow.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "workflow not found")
                        return
                }</span>
                <span class="cov0" title="0">if _, ok := err.(*workflow.ValidationError); ok </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusBadRequest, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">h.respondError(w, http.StatusInternalServerError, "failed to update workflow")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": wf,
        })</span>
}

// Delete deletes a workflow
func (h *WorkflowHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        workflowID := chi.URLParam(r, "workflowID")

        err := h.service.Delete(r.Context(), tenantID, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                if err == workflow.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "workflow not found")
                        return
                }</span>
                <span class="cov0" title="0">h.respondError(w, http.StatusInternalServerError, "failed to delete workflow")
                return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// Execute triggers a workflow execution
func (h *WorkflowHandler) Execute(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        workflowID := chi.URLParam(r, "workflowID")

        // Parse trigger data from request body
        var triggerData json.RawMessage
        if r.Body != nil </span><span class="cov0" title="0">{
                json.NewDecoder(r.Body).Decode(&amp;triggerData)
        }</span>

        <span class="cov0" title="0">execution, err := h.service.Execute(r.Context(), tenantID, workflowID, "manual", triggerData)
        if err != nil </span><span class="cov0" title="0">{
                if err == workflow.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "workflow not found")
                        return
                }</span>
                <span class="cov0" title="0">h.respondError(w, http.StatusInternalServerError, "failed to execute workflow")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusAccepted, map[string]interface{}{
                "data": execution,
        })</span>
}

// ListExecutions returns executions for the tenant
func (h *WorkflowHandler) ListExecutions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        workflowID := r.URL.Query().Get("workflow_id")

        limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))

        executions, err := h.service.ListExecutions(r.Context(), tenantID, workflowID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.respondError(w, http.StatusInternalServerError, "failed to list executions")
                return
        }</span>

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data":   executions,
                "limit":  limit,
                "offset": offset,
        })</span>
}

// GetExecution retrieves a single execution
func (h *WorkflowHandler) GetExecution(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tenantID := middleware.GetTenantID(r)
        executionID := chi.URLParam(r, "executionID")

        execution, err := h.service.GetExecution(r.Context(), tenantID, executionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == workflow.ErrNotFound </span><span class="cov0" title="0">{
                        h.respondError(w, http.StatusNotFound, "execution not found")
                        return
                }</span>
                <span class="cov0" title="0">h.respondError(w, http.StatusInternalServerError, "failed to get execution")
                return</span>
        }

        <span class="cov0" title="0">h.respondJSON(w, http.StatusOK, map[string]interface{}{
                "data": execution,
        })</span>
}

// Helper methods

func (h *WorkflowHandler) respondJSON(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(data)
}</span>

func (h *WorkflowHandler) respondError(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        h.respondJSON(w, status, map[string]string{
                "error": message,
        })
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "context"
        "encoding/json"
        "net/http"
        "strings"

        "github.com/gorax/gorax/internal/config"
)

type contextKey string

const (
        // UserContextKey is the context key for the authenticated user
        UserContextKey contextKey = "user"
)

// User represents an authenticated user from Kratos
type User struct {
        ID       string                 `json:"id"`
        Email    string                 `json:"email"`
        Traits   map[string]interface{} `json:"traits"`
        TenantID string                 `json:"tenant_id"`
}

// kratosSession represents the session response from Kratos
type kratosSession struct {
        Active   bool `json:"active"`
        Identity struct {
                ID     string                 `json:"id"`
                Traits map[string]interface{} `json:"traits"`
        } `json:"identity"`
}

// KratosAuth returns middleware that validates sessions with Ory Kratos
func KratosAuth(cfg config.KratosConfig) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Extract session token from cookie or Authorization header
                        sessionToken := extractSessionToken(r)
                        if sessionToken == "" </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized: no session token", http.StatusUnauthorized)
                                return
                        }</span>

                        // Validate session with Kratos
                        <span class="cov0" title="0">user, err := validateKratosSession(cfg.PublicURL, sessionToken)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized: invalid session", http.StatusUnauthorized)
                                return
                        }</span>

                        // Add user to context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), UserContextKey, user)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

func extractSessionToken(r *http.Request) string <span class="cov0" title="0">{
        // Try Authorization header first
        authHeader := r.Header.Get("Authorization")
        if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "Bearer ")
        }</span>

        // Try session cookie
        <span class="cov0" title="0">cookie, err := r.Cookie("ory_kratos_session")
        if err == nil </span><span class="cov0" title="0">{
                return cookie.Value
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func validateKratosSession(kratosURL, sessionToken string) (*User, error) <span class="cov0" title="0">{
        // Create request to Kratos whoami endpoint
        req, err := http.NewRequest("GET", kratosURL+"/sessions/whoami", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Session-Token", sessionToken)

        // Make request
        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, ErrInvalidSession
        }</span>

        // Parse response
        <span class="cov0" title="0">var session kratosSession
        if err := json.NewDecoder(resp.Body).Decode(&amp;session); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !session.Active </span><span class="cov0" title="0">{
                return nil, ErrInvalidSession
        }</span>

        // Extract email from traits
        <span class="cov0" title="0">email, _ := session.Identity.Traits["email"].(string)

        // Extract tenant_id from traits (set during registration)
        tenantID, _ := session.Identity.Traits["tenant_id"].(string)

        return &amp;User{
                ID:       session.Identity.ID,
                Email:    email,
                Traits:   session.Identity.Traits,
                TenantID: tenantID,
        }, nil</span>
}

// GetUser extracts the user from the request context
func GetUser(r *http.Request) *User <span class="cov0" title="0">{
        user, _ := r.Context().Value(UserContextKey).(*User)
        return user
}</span>

// Custom errors
type AuthError struct {
        Message string
}

func (e AuthError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

var ErrInvalidSession = AuthError{Message: "invalid session"}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "context"
        "net/http"
        "os"
)

// DevAuth returns middleware for development that bypasses Kratos
// IMPORTANT: This should ONLY be used in development (APP_ENV=development)
func DevAuth() func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Only allow in development mode
                        if os.Getenv("APP_ENV") != "development" </span><span class="cov0" title="0">{
                                http.Error(w, "development auth only available in development mode", http.StatusForbidden)
                                return
                        }</span>

                        // Get tenant ID from header (required)
                        <span class="cov0" title="0">tenantID := r.Header.Get("X-Tenant-ID")
                        if tenantID == "" </span><span class="cov0" title="0">{
                                // Default to test tenant for convenience
                                tenantID = "00000000-0000-0000-0000-000000000001"
                        }</span>

                        // Get user ID from header (optional)
                        <span class="cov0" title="0">userID := r.Header.Get("X-User-ID")
                        if userID == "" </span><span class="cov0" title="0">{
                                userID = "00000000-0000-0000-0000-000000000002"
                        }</span>

                        // Create development user
                        <span class="cov0" title="0">user := &amp;User{
                                ID:       userID,
                                Email:    "dev@example.com",
                                TenantID: tenantID,
                                Traits: map[string]interface{}{
                                        "email":     "dev@example.com",
                                        "tenant_id": tenantID,
                                },
                        }

                        // Add user to context
                        ctx := context.WithValue(r.Context(), UserContextKey, user)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5/middleware"
)

// StructuredLogger returns a middleware that logs requests with slog
func StructuredLogger(logger *slog.Logger) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()
                        ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

                        defer func() </span><span class="cov0" title="0">{
                                logger.Info("http request",
                                        "method", r.Method,
                                        "path", r.URL.Path,
                                        "status", ww.Status(),
                                        "bytes", ww.BytesWritten(),
                                        "duration_ms", time.Since(start).Milliseconds(),
                                        "request_id", middleware.GetReqID(r.Context()),
                                        "remote_addr", r.RemoteAddr,
                                        "user_agent", r.UserAgent(),
                                )
                        }</span>()

                        <span class="cov0" title="0">next.ServeHTTP(ww, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/gorax/gorax/internal/tenant"
)

// QuotaChecker handles tenant quota validation
type QuotaChecker struct {
        tenantService *tenant.Service
        redis         *redis.Client
        logger        *slog.Logger
}

// NewQuotaChecker creates a new quota checker
func NewQuotaChecker(tenantService *tenant.Service, redis *redis.Client, logger *slog.Logger) *QuotaChecker <span class="cov0" title="0">{
        return &amp;QuotaChecker{
                tenantService: tenantService,
                redis:         redis,
                logger:        logger,
        }
}</span>

// CheckQuotas returns middleware that validates tenant quotas before allowing operations
func (qc *QuotaChecker) CheckQuotas() func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get tenant from context
                        t := GetTenant(r)
                        if t == nil </span><span class="cov0" title="0">{
                                http.Error(w, "tenant not found in context", http.StatusInternalServerError)
                                return
                        }</span>

                        // Parse quotas from tenant
                        <span class="cov0" title="0">var quotas tenant.TenantQuotas
                        if err := json.Unmarshal(t.Quotas, &amp;quotas); err != nil </span><span class="cov0" title="0">{
                                qc.logger.Error("failed to parse tenant quotas", "error", err, "tenant_id", t.ID)
                                http.Error(w, "failed to parse quotas", http.StatusInternalServerError)
                                return
                        }</span>

                        // Check which operation is being performed
                        <span class="cov0" title="0">operation := qc.detectOperation(r)

                        // Validate quotas based on operation
                        switch operation </span>{
                        case "create_workflow":<span class="cov0" title="0">
                                if err := qc.checkWorkflowQuota(r.Context(), t.ID, quotas); err != nil </span><span class="cov0" title="0">{
                                        qc.handleQuotaExceeded(w, err)
                                        return
                                }</span>
                        case "execute_workflow":<span class="cov0" title="0">
                                if err := qc.checkExecutionQuota(r.Context(), t.ID, quotas); err != nil </span><span class="cov0" title="0">{
                                        qc.handleQuotaExceeded(w, err)
                                        return
                                }</span>
                        case "api_call":<span class="cov0" title="0">
                                if err := qc.checkAPIRateLimit(r.Context(), t.ID, quotas); err != nil </span><span class="cov0" title="0">{
                                        qc.handleQuotaExceeded(w, err)
                                        return
                                }</span>
                        }

                        // Track API call
                        <span class="cov0" title="0">qc.trackAPICall(r.Context(), t.ID)

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// detectOperation determines what operation is being performed based on the request
func (qc *QuotaChecker) detectOperation(r *http.Request) string <span class="cov0" title="0">{
        path := r.URL.Path
        method := r.Method

        if method == "POST" &amp;&amp; strings.Contains(path, "/workflows") &amp;&amp; !strings.Contains(path, "/execute") </span><span class="cov0" title="0">{
                return "create_workflow"
        }</span>
        <span class="cov0" title="0">if method == "POST" &amp;&amp; strings.Contains(path, "/execute") </span><span class="cov0" title="0">{
                return "execute_workflow"
        }</span>
        <span class="cov0" title="0">return "api_call"</span>
}

// checkWorkflowQuota validates if tenant can create more workflows
func (qc *QuotaChecker) checkWorkflowQuota(ctx context.Context, tenantID string, quotas tenant.TenantQuotas) error <span class="cov0" title="0">{
        // -1 means unlimited
        if quotas.MaxWorkflows == -1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get current workflow count from database
        <span class="cov0" title="0">count, err := qc.tenantService.GetWorkflowCount(ctx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                qc.logger.Error("failed to get workflow count", "error", err, "tenant_id", tenantID)
                return fmt.Errorf("failed to check quota: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt;= quotas.MaxWorkflows </span><span class="cov0" title="0">{
                return fmt.Errorf("workflow quota exceeded: %d/%d workflows used", count, quotas.MaxWorkflows)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkExecutionQuota validates if tenant can execute more workflows today
func (qc *QuotaChecker) checkExecutionQuota(ctx context.Context, tenantID string, quotas tenant.TenantQuotas) error <span class="cov0" title="0">{
        // -1 means unlimited
        if quotas.MaxExecutionsPerDay == -1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check concurrent executions
        <span class="cov0" title="0">if quotas.MaxConcurrentExecutions &gt; 0 </span><span class="cov0" title="0">{
                concurrent, err := qc.getConcurrentExecutions(ctx, tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        qc.logger.Error("failed to get concurrent executions", "error", err, "tenant_id", tenantID)
                }</span> else<span class="cov0" title="0"> if concurrent &gt;= quotas.MaxConcurrentExecutions </span><span class="cov0" title="0">{
                        return fmt.Errorf("concurrent execution quota exceeded: %d/%d concurrent executions", concurrent, quotas.MaxConcurrentExecutions)
                }</span>
        }

        // Get today's execution count from Redis
        <span class="cov0" title="0">key := fmt.Sprintf("quota:executions:daily:%s:%s", tenantID, time.Now().Format("2006-01-02"))
        count, err := qc.redis.Get(ctx, key).Int()
        if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                qc.logger.Error("failed to get execution count from Redis", "error", err, "tenant_id", tenantID)
                return fmt.Errorf("failed to check quota: %w", err)
        }</span>

        <span class="cov0" title="0">if count &gt;= quotas.MaxExecutionsPerDay </span><span class="cov0" title="0">{
                return fmt.Errorf("daily execution quota exceeded: %d/%d executions used today", count, quotas.MaxExecutionsPerDay)
        }</span>

        // Increment counter with expiration (48 hours to handle timezone differences)
        <span class="cov0" title="0">pipe := qc.redis.Pipeline()
        pipe.Incr(ctx, key)
        pipe.Expire(ctx, key, 48*time.Hour)
        _, err = pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                qc.logger.Warn("failed to increment execution counter", "error", err, "tenant_id", tenantID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkAPIRateLimit validates API rate limits
func (qc *QuotaChecker) checkAPIRateLimit(ctx context.Context, tenantID string, quotas tenant.TenantQuotas) error <span class="cov0" title="0">{
        // -1 means unlimited
        if quotas.MaxAPICallsPerMinute == -1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use sliding window rate limiting with Redis
        <span class="cov0" title="0">key := fmt.Sprintf("quota:api:minute:%s", tenantID)
        now := time.Now().Unix()
        windowStart := now - 60

        // Remove old entries and count current
        pipe := qc.redis.Pipeline()
        pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart))
        pipe.ZCard(ctx, key)
        results, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                qc.logger.Error("failed to check rate limit", "error", err, "tenant_id", tenantID)
                return fmt.Errorf("failed to check rate limit: %w", err)
        }</span>

        <span class="cov0" title="0">count := results[1].(*redis.IntCmd).Val()
        if int(count) &gt;= quotas.MaxAPICallsPerMinute </span><span class="cov0" title="0">{
                return fmt.Errorf("API rate limit exceeded: %d/%d calls per minute", count, quotas.MaxAPICallsPerMinute)
        }</span>

        // Add current request
        <span class="cov0" title="0">pipe = qc.redis.Pipeline()
        pipe.ZAdd(ctx, key, redis.Z{Score: float64(now), Member: fmt.Sprintf("%d", now)})
        pipe.Expire(ctx, key, 2*time.Minute)
        _, err = pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                qc.logger.Warn("failed to record API call", "error", err, "tenant_id", tenantID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getConcurrentExecutions returns the number of currently running executions
func (qc *QuotaChecker) getConcurrentExecutions(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        return qc.tenantService.GetConcurrentExecutions(ctx, tenantID)
}</span>

// trackAPICall tracks API call for analytics (non-blocking)
func (qc *QuotaChecker) trackAPICall(ctx context.Context, tenantID string) <span class="cov0" title="0">{
        key := fmt.Sprintf("analytics:api:daily:%s:%s", tenantID, time.Now().Format("2006-01-02"))
        err := qc.redis.Incr(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                qc.logger.Debug("failed to track API call", "error", err, "tenant_id", tenantID)
        }</span>
        <span class="cov0" title="0">qc.redis.Expire(ctx, key, 90*24*time.Hour)</span> // 90 days retention
}

// handleQuotaExceeded returns a 429 response with quota information
func (qc *QuotaChecker) handleQuotaExceeded(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Retry-After", "3600") // Suggest retry after 1 hour
        w.WriteHeader(http.StatusTooManyRequests)

        response := map[string]interface{}{
                "error":   "quota_exceeded",
                "message": err.Error(),
                "retry_after": 3600,
        }
        json.NewEncoder(w).Encode(response)
}</span>

// QuotaExempt returns middleware that bypasses quota checks for specific routes
func QuotaExempt() func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Mark request as quota-exempt in context
                        ctx := context.WithValue(r.Context(), "quota_exempt", true)
                        next.ServeHTTP(w, r.WithContext(ctx))
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/gorax/gorax/internal/ratelimit"
)

// RateLimitConfig holds configuration for rate limiting
type RateLimitConfig struct {
        RequestsPerMinute  int64 // Max requests per minute
        RequestsPerHour    int64 // Max requests per hour
        RequestsPerDay     int64 // Max requests per day
        EnabledForPaths    []string
        ExcludedPaths      []string
}

// DefaultRateLimitConfig returns sensible defaults
func DefaultRateLimitConfig() RateLimitConfig <span class="cov0" title="0">{
        return RateLimitConfig{
                RequestsPerMinute: 60,
                RequestsPerHour:   1000,
                RequestsPerDay:    10000,
                EnabledForPaths:   []string{"/api/"},
                ExcludedPaths:     []string{"/api/health", "/api/metrics"},
        }
}</span>

// RateLimitMiddleware creates a middleware that enforces rate limits per tenant
func RateLimitMiddleware(redisClient *redis.Client, config RateLimitConfig, logger *slog.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        limiter := ratelimit.NewSlidingWindowLimiter(redisClient)

        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get tenant from context
                        tenant := GetTenant(r)
                        if tenant == nil </span><span class="cov0" title="0">{
                                // No tenant, skip rate limiting (e.g., public endpoints)
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">tenantID := tenant.ID

                        // Check if path should be rate limited
                        if shouldSkipRateLimit(r.URL.Path, config) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">ctx := r.Context()

                        // Check rate limits in order: minute, hour, day
                        limits := []struct {
                                name   string
                                limit  int64
                                window time.Duration
                        }{
                                {"per_minute", config.RequestsPerMinute, time.Minute},
                                {"per_hour", config.RequestsPerHour, time.Hour},
                                {"per_day", config.RequestsPerDay, 24 * time.Hour},
                        }

                        for _, limit := range limits </span><span class="cov0" title="0">{
                                if limit.limit &lt;= 0 </span><span class="cov0" title="0">{
                                        continue</span> // Skip disabled limits
                                }

                                <span class="cov0" title="0">allowed, err := limiter.Allow(ctx, tenantID, limit.limit, limit.window)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error("rate limit check failed",
                                                "error", err,
                                                "tenant_id", tenantID,
                                                "limit", limit.name,
                                        )
                                        // On error, allow the request (fail open)
                                        next.ServeHTTP(w, r)
                                        return
                                }</span>

                                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                                        logger.Warn("rate limit exceeded",
                                                "tenant_id", tenantID,
                                                "limit", limit.name,
                                                "path", r.URL.Path,
                                        )

                                        // Get current usage for headers
                                        usage, _ := limiter.GetUsage(ctx, tenantID, limit.window)

                                        // Set rate limit headers
                                        w.Header().Set("X-RateLimit-Limit", formatInt64(limit.limit))
                                        w.Header().Set("X-RateLimit-Remaining", "0")
                                        w.Header().Set("X-RateLimit-Used", formatInt64(usage))
                                        w.Header().Set("X-RateLimit-Window", limit.window.String())
                                        w.Header().Set("Retry-After", formatInt64(int64(limit.window.Seconds())))

                                        http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                                        return
                                }</span>
                        }

                        // All limits passed - add usage headers
                        <span class="cov0" title="0">w.Header().Set("X-RateLimit-Limit-Minute", formatInt64(config.RequestsPerMinute))
                        w.Header().Set("X-RateLimit-Limit-Hour", formatInt64(config.RequestsPerHour))
                        w.Header().Set("X-RateLimit-Limit-Day", formatInt64(config.RequestsPerDay))

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// shouldSkipRateLimit checks if a path should skip rate limiting
func shouldSkipRateLimit(path string, config RateLimitConfig) bool <span class="cov0" title="0">{
        // Check excluded paths
        for _, excluded := range config.ExcludedPaths </span><span class="cov0" title="0">{
                if matchPath(path, excluded) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check if path is in enabled paths
        <span class="cov0" title="0">for _, enabled := range config.EnabledForPaths </span><span class="cov0" title="0">{
                if matchPath(path, enabled) </span><span class="cov0" title="0">{
                        return false // Should be rate limited
                }</span>
        }

        // Not in enabled paths, skip
        <span class="cov0" title="0">return true</span>
}

// matchPath checks if a path matches a pattern (simple prefix matching)
func matchPath(path, pattern string) bool <span class="cov0" title="0">{
        if len(pattern) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Simple prefix match
        <span class="cov0" title="0">if len(path) &gt;= len(pattern) </span><span class="cov0" title="0">{
                return path[:len(pattern)] == pattern
        }</span>

        <span class="cov0" title="0">return false</span>
}

// formatInt64 converts int64 to string for headers
func formatInt64(n int64) string <span class="cov0" title="0">{
        return strconv.FormatInt(n, 10)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "context"
        "net/http"

        "github.com/gorax/gorax/internal/tenant"
)

const (
        // TenantContextKey is the context key for the current tenant
        TenantContextKey contextKey = "tenant"
)

// TenantContext middleware extracts and validates the tenant from the request
func TenantContext(tenantService *tenant.Service) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Get authenticated user
                        user := GetUser(r)
                        if user == nil </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">var tenantID string

                        // Priority 1: User's tenant from Kratos session
                        if user.TenantID != "" </span><span class="cov0" title="0">{
                                tenantID = user.TenantID
                        }</span>

                        // Priority 2: X-Tenant-ID header (for admin/multi-tenant users)
                        <span class="cov0" title="0">if headerTenantID := r.Header.Get("X-Tenant-ID"); headerTenantID != "" </span><span class="cov0" title="0">{
                                // TODO: Verify user has access to this tenant
                                tenantID = headerTenantID
                        }</span>

                        <span class="cov0" title="0">if tenantID == "" </span><span class="cov0" title="0">{
                                http.Error(w, "tenant not found", http.StatusBadRequest)
                                return
                        }</span>

                        // Validate tenant exists and is active
                        <span class="cov0" title="0">t, err := tenantService.GetByID(r.Context(), tenantID)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "tenant not found", http.StatusNotFound)
                                return
                        }</span>

                        <span class="cov0" title="0">if t.Status != "active" </span><span class="cov0" title="0">{
                                http.Error(w, "tenant is not active", http.StatusForbidden)
                                return
                        }</span>

                        // Add tenant to context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), TenantContextKey, t)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// GetTenant extracts the tenant from the request context
func GetTenant(r *http.Request) *tenant.Tenant <span class="cov0" title="0">{
        t, _ := r.Context().Value(TenantContextKey).(*tenant.Tenant)
        return t
}</span>

// GetTenantID extracts just the tenant ID from the request context
func GetTenantID(r *http.Request) string <span class="cov0" title="0">{
        t := GetTenant(r)
        if t != nil </span><span class="cov0" title="0">{
                return t.ID
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package billing

import (
        "bytes"
        "context"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "net/url"
        "sync"
        "time"
)

var (
        // ErrInvalidConfig is returned when webhook config is invalid
        ErrInvalidConfig = errors.New("invalid webhook configuration")
        // ErrWebhookNotFound is returned when webhook is not found
        ErrWebhookNotFound = errors.New("webhook not found")
)

// WebhookConfig holds webhook configuration
type WebhookConfig struct {
        TenantID   string    `json:"tenant_id"`
        URL        string    `json:"url"`
        Secret     string    `json:"secret"`
        Events     []string  `json:"events"`
        Active     bool      `json:"active"`
        MaxRetries int       `json:"max_retries"`
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
}

// Validate validates webhook configuration
func (c *WebhookConfig) Validate() error <span class="cov8" title="1">{
        if c.TenantID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: tenant_id is required", ErrInvalidConfig)
        }</span>

        <span class="cov8" title="1">if c.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: url is required", ErrInvalidConfig)
        }</span>

        // Validate URL format
        <span class="cov8" title="1">parsedURL, err := url.Parse(c.URL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: invalid url format: %v", ErrInvalidConfig, err)
        }</span>
        <span class="cov8" title="1">if parsedURL.Scheme == "" || parsedURL.Host == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: url must have scheme and host", ErrInvalidConfig)
        }</span>

        <span class="cov8" title="1">if len(c.Events) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: at least one event is required", ErrInvalidConfig)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WebhookPayload represents the payload sent to webhooks
type WebhookPayload struct {
        Event     string      `json:"event"`
        TenantID  string      `json:"tenant_id"`
        Timestamp time.Time   `json:"timestamp"`
        Data      interface{} `json:"data"`
}

// ExecutionCompletedPayload represents execution completion data
type ExecutionCompletedPayload struct {
        ExecutionID string `json:"execution_id"`
        WorkflowID  string `json:"workflow_id"`
        Status      string `json:"status"`
        Duration    int64  `json:"duration_ms"`
        StepCount   int    `json:"step_count"`
}

// DeliveryLog represents a webhook delivery attempt
type DeliveryLog struct {
        ID         string    `json:"id"`
        TenantID   string    `json:"tenant_id"`
        Event      string    `json:"event"`
        URL        string    `json:"url"`
        StatusCode int       `json:"status_code"`
        Response   string    `json:"response"`
        Attempts   int       `json:"attempts"`
        CreatedAt  time.Time `json:"created_at"`
        Success    bool      `json:"success"`
}

// WebhookNotifier handles webhook notifications
type WebhookNotifier struct {
        webhooks     map[string][]WebhookConfig
        deliveryLogs map[string][]DeliveryLog
        mu           sync.RWMutex
        client       *http.Client
        logger       *slog.Logger
        retryBackoff time.Duration // For testing
}

// NewWebhookNotifier creates a new webhook notifier
func NewWebhookNotifier() *WebhookNotifier <span class="cov8" title="1">{
        return &amp;WebhookNotifier{
                webhooks:     make(map[string][]WebhookConfig),
                deliveryLogs: make(map[string][]DeliveryLog),
                client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                logger:       slog.Default(),
                retryBackoff: time.Second, // Default 1 second backoff
        }
}</span>

// RegisterWebhook registers a webhook for a tenant
func (n *WebhookNotifier) RegisterWebhook(ctx context.Context, config WebhookConfig) error <span class="cov8" title="1">{
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set defaults
        <span class="cov8" title="1">if config.MaxRetries == 0 </span><span class="cov8" title="1">{
                config.MaxRetries = 3
        }</span>
        <span class="cov8" title="1">if config.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                config.CreatedAt = time.Now()
        }</span>
        <span class="cov8" title="1">config.UpdatedAt = time.Now()

        n.mu.Lock()
        defer n.mu.Unlock()

        n.webhooks[config.TenantID] = append(n.webhooks[config.TenantID], config)

        return nil</span>
}

// UnregisterWebhook removes a webhook for a tenant
func (n *WebhookNotifier) UnregisterWebhook(ctx context.Context, tenantID, url string) error <span class="cov8" title="1">{
        n.mu.Lock()
        defer n.mu.Unlock()

        webhooks := n.webhooks[tenantID]
        filtered := make([]WebhookConfig, 0)

        for _, wh := range webhooks </span><span class="cov8" title="1">{
                if wh.URL != url </span><span class="cov0" title="0">{
                        filtered = append(filtered, wh)
                }</span>
        }

        <span class="cov8" title="1">if len(filtered) == len(webhooks) </span><span class="cov0" title="0">{
                return ErrWebhookNotFound
        }</span>

        <span class="cov8" title="1">n.webhooks[tenantID] = filtered

        return nil</span>
}

// GetWebhooks returns all webhooks for a tenant
func (n *WebhookNotifier) GetWebhooks(ctx context.Context, tenantID string) []WebhookConfig <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        webhooks := n.webhooks[tenantID]
        result := make([]WebhookConfig, len(webhooks))
        copy(result, webhooks)

        return result
}</span>

// SendQuotaThreshold sends a quota threshold notification
func (n *WebhookNotifier) SendQuotaThreshold(ctx context.Context, tenantID string, thresholdPercent int, current, limit int64) error <span class="cov8" title="1">{
        payload := WebhookPayload{
                Event:     "quota.threshold",
                TenantID:  tenantID,
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "threshold_percent": thresholdPercent,
                        "current":           current,
                        "limit":             limit,
                        "percent_used":      (float64(current) / float64(limit)) * 100,
                },
        }

        return n.send(ctx, tenantID, payload)
}</span>

// SendExecutionCompleted sends an execution completed notification
func (n *WebhookNotifier) SendExecutionCompleted(ctx context.Context, tenantID string, execPayload ExecutionCompletedPayload) error <span class="cov8" title="1">{
        payload := WebhookPayload{
                Event:     "execution.completed",
                TenantID:  tenantID,
                Timestamp: time.Now(),
                Data:      execPayload,
        }

        return n.send(ctx, tenantID, payload)
}</span>

// send delivers payload to registered webhooks
func (n *WebhookNotifier) send(ctx context.Context, tenantID string, payload WebhookPayload) error <span class="cov8" title="1">{
        webhooks := n.GetWebhooks(ctx, tenantID)

        for _, webhook := range webhooks </span><span class="cov8" title="1">{
                if !webhook.Active </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if webhook is subscribed to this event
                <span class="cov8" title="1">if !n.isSubscribed(webhook, payload.Event) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Deliver asynchronously
                <span class="cov8" title="1">go n.deliver(ctx, webhook, payload)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isSubscribed checks if webhook is subscribed to an event
func (n *WebhookNotifier) isSubscribed(webhook WebhookConfig, event string) bool <span class="cov8" title="1">{
        for _, e := range webhook.Events </span><span class="cov8" title="1">{
                if e == event </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// deliver delivers payload to a webhook with retry logic
func (n *WebhookNotifier) deliver(ctx context.Context, webhook WebhookConfig, payload WebhookPayload) <span class="cov8" title="1">{
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                n.logger.Error("failed to marshal webhook payload",
                        "error", err,
                        "tenant_id", webhook.TenantID,
                )
                return
        }</span>

        <span class="cov8" title="1">var lastStatusCode int
        var lastResponse string
        var success bool

        for attempt := 1; attempt &lt;= webhook.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                statusCode, response, err := n.deliverOnce(ctx, webhook, payloadBytes)
                lastStatusCode = statusCode
                lastResponse = response

                if err == nil &amp;&amp; statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 </span><span class="cov8" title="1">{
                        success = true
                        break</span>
                }

                <span class="cov8" title="1">if attempt &lt; webhook.MaxRetries </span><span class="cov8" title="1">{
                        // Exponential backoff
                        backoff := time.Duration(attempt) * n.retryBackoff
                        time.Sleep(backoff)
                }</span>

                <span class="cov8" title="1">n.logger.Warn("webhook delivery attempt failed",
                        "attempt", attempt,
                        "tenant_id", webhook.TenantID,
                        "url", webhook.URL,
                        "status", statusCode,
                        "error", err,
                )</span>
        }

        // Log delivery
        <span class="cov8" title="1">log := DeliveryLog{
                ID:         fmt.Sprintf("%d", time.Now().UnixNano()),
                TenantID:   webhook.TenantID,
                Event:      payload.Event,
                URL:        webhook.URL,
                StatusCode: lastStatusCode,
                Response:   lastResponse,
                Attempts:   webhook.MaxRetries,
                CreatedAt:  time.Now(),
                Success:    success,
        }

        n.mu.Lock()
        n.deliveryLogs[webhook.TenantID] = append(n.deliveryLogs[webhook.TenantID], log)
        n.mu.Unlock()</span>
}

// deliverOnce attempts a single webhook delivery
func (n *WebhookNotifier) deliverOnce(ctx context.Context, webhook WebhookConfig, payloadBytes []byte) (int, string, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, webhook.URL, bytes.NewReader(payloadBytes))
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Add headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", "gorax-webhook/1.0")

        // Add signature
        signature := computeSignature(payloadBytes, webhook.Secret)
        req.Header.Set("X-Webhook-Signature", signature)

        resp, err := n.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read response (limited)
        buf := new(bytes.Buffer)
        buf.ReadFrom(resp.Body)
        response := buf.String()

        if len(response) &gt; 1000 </span><span class="cov0" title="0">{
                response = response[:1000]
        }</span>

        <span class="cov8" title="1">return resp.StatusCode, response, nil</span>
}

// GetDeliveryLogs returns delivery logs for a tenant
func (n *WebhookNotifier) GetDeliveryLogs(ctx context.Context, tenantID string, limit int) []DeliveryLog <span class="cov8" title="1">{
        n.mu.RLock()
        defer n.mu.RUnlock()

        logs := n.deliveryLogs[tenantID]
        if len(logs) == 0 </span><span class="cov0" title="0">{
                return []DeliveryLog{}
        }</span>

        // Return most recent logs
        <span class="cov8" title="1">start := len(logs) - limit
        if start &lt; 0 </span><span class="cov8" title="1">{
                start = 0
        }</span>

        <span class="cov8" title="1">result := make([]DeliveryLog, len(logs)-start)
        copy(result, logs[start:])

        // Reverse to show most recent first
        for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                result[i], result[j] = result[j], result[i]
        }</span>

        <span class="cov8" title="1">return result</span>
}

// computeSignature computes HMAC-SHA256 signature
func computeSignature(payload []byte, secret string) string <span class="cov8" title="1">{
        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        signature := hex.EncodeToString(mac.Sum(nil))
        return fmt.Sprintf("sha256=%s", signature)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
)

// Config holds all application configuration
type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        Redis    RedisConfig
        Kratos   KratosConfig
        Worker   WorkerConfig
        AWS      AWSConfig
        Queue    QueueConfig
}

// ServerConfig holds HTTP server configuration
type ServerConfig struct {
        Address string
        Env     string
}

// DatabaseConfig holds PostgreSQL configuration
type DatabaseConfig struct {
        Host     string
        Port     int
        User     string
        Password string
        DBName   string
        SSLMode  string
}

// ConnectionString returns the PostgreSQL connection string
func (d DatabaseConfig) ConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                d.Host, d.Port, d.User, d.Password, d.DBName, d.SSLMode,
        )
}</span>

// RedisConfig holds Redis configuration
type RedisConfig struct {
        Address  string
        Password string
        DB       int
}

// KratosConfig holds Ory Kratos configuration
type KratosConfig struct {
        PublicURL string
        AdminURL  string
}

// WorkerConfig holds worker configuration
type WorkerConfig struct {
        Concurrency             int
        MaxConcurrencyPerTenant int
        HealthPort              string
        QueueURL                string
}

// AWSConfig holds AWS configuration
type AWSConfig struct {
        Region          string
        AccessKeyID     string
        SecretAccessKey string
        Endpoint        string // For LocalStack or custom endpoints
        S3Bucket        string
        SQSQueueURL     string
        SQSDLQueueURL   string // Dead-letter queue URL
}

// QueueConfig holds queue-specific configuration
type QueueConfig struct {
        Enabled            bool
        MaxMessages        int32
        WaitTimeSeconds    int32
        VisibilityTimeout  int32
        MaxRetries         int
        ProcessTimeout     int // in seconds
        PollInterval       int // in seconds
        ConcurrentWorkers  int
        DeleteAfterProcess bool
}

// Load reads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{
                Server: ServerConfig{
                        Address: getEnv("SERVER_ADDRESS", ":8080"),
                        Env:     getEnv("APP_ENV", "development"),
                },
                Database: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "localhost"),
                        Port:     getEnvAsInt("DB_PORT", 5433),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", "postgres"),
                        DBName:   getEnv("DB_NAME", "gorax"),
                        SSLMode:  getEnv("DB_SSLMODE", "disable"),
                },
                Redis: RedisConfig{
                        Address:  getEnv("REDIS_ADDRESS", "localhost:6379"),
                        Password: getEnv("REDIS_PASSWORD", ""),
                        DB:       getEnvAsInt("REDIS_DB", 0),
                },
                Kratos: KratosConfig{
                        PublicURL: getEnv("KRATOS_PUBLIC_URL", "http://localhost:4433"),
                        AdminURL:  getEnv("KRATOS_ADMIN_URL", "http://localhost:4434"),
                },
                Worker: WorkerConfig{
                        Concurrency:             getEnvAsInt("WORKER_CONCURRENCY", 10),
                        MaxConcurrencyPerTenant: getEnvAsInt("WORKER_MAX_CONCURRENCY_PER_TENANT", 10),
                        HealthPort:              getEnv("WORKER_HEALTH_PORT", "8081"),
                        QueueURL:                getEnv("WORKER_QUEUE_URL", ""),
                },
                AWS: AWSConfig{
                        Region:          getEnv("AWS_REGION", "us-east-1"),
                        AccessKeyID:     getEnv("AWS_ACCESS_KEY_ID", ""),
                        SecretAccessKey: getEnv("AWS_SECRET_ACCESS_KEY", ""),
                        Endpoint:        getEnv("AWS_ENDPOINT", ""), // For LocalStack
                        S3Bucket:        getEnv("AWS_S3_BUCKET", "gorax-artifacts"),
                        SQSQueueURL:     getEnv("AWS_SQS_QUEUE_URL", ""),
                        SQSDLQueueURL:   getEnv("AWS_SQS_DLQ_URL", ""),
                },
                Queue: QueueConfig{
                        Enabled:            getEnvAsBool("QUEUE_ENABLED", false),
                        MaxMessages:        int32(getEnvAsInt("QUEUE_MAX_MESSAGES", 10)),
                        WaitTimeSeconds:    int32(getEnvAsInt("QUEUE_WAIT_TIME_SECONDS", 20)),
                        VisibilityTimeout:  int32(getEnvAsInt("QUEUE_VISIBILITY_TIMEOUT", 30)),
                        MaxRetries:         getEnvAsInt("QUEUE_MAX_RETRIES", 3),
                        ProcessTimeout:     getEnvAsInt("QUEUE_PROCESS_TIMEOUT", 300), // 5 minutes
                        PollInterval:       getEnvAsInt("QUEUE_POLL_INTERVAL", 1),
                        ConcurrentWorkers:  getEnvAsInt("QUEUE_CONCURRENT_WORKERS", 10),
                        DeleteAfterProcess: getEnvAsBool("QUEUE_DELETE_AFTER_PROCESS", true),
                },
        }

        return cfg, nil
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package credential

import (
        "errors"
        "time"
)

// Common errors
var (
        ErrUnauthorized  = errors.New("unauthorized access to credential")
        ErrInvalidInput  = errors.New("invalid input")
        ErrAlreadyExists = errors.New("credential already exists")
)

// ValidationError represents a validation error
type ValidationError struct {
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// CredentialType represents the type of credential
type CredentialType string

const (
        TypeAPIKey     CredentialType = "api_key"
        TypeOAuth2     CredentialType = "oauth2"
        TypeBasicAuth  CredentialType = "basic_auth"
        TypeCustom     CredentialType = "custom"
)

// CredentialStatus represents the status of a credential
type CredentialStatus string

const (
        StatusActive    CredentialStatus = "active"
        StatusInactive  CredentialStatus = "inactive"
        StatusRevoked   CredentialStatus = "revoked"
)

// AccessType constants
const (
        AccessTypeRead   = "read"
        AccessTypeUpdate = "update"
        AccessTypeRotate = "rotate"
        AccessTypeDelete = "delete"
)

// Credential represents a credential in the system
// Values are encrypted at rest and should never be returned in API responses except through /value endpoint
type Credential struct {
        ID          string           `json:"id" db:"id"`
        TenantID    string           `json:"tenant_id" db:"tenant_id"`
        Name        string           `json:"name" db:"name"`
        Description string           `json:"description" db:"description"`
        Type        CredentialType   `json:"type" db:"type"`
        Status      CredentialStatus `json:"status" db:"status"`
        CreatedBy   string           `json:"created_by" db:"created_by"`
        CreatedAt   time.Time        `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time        `json:"updated_at" db:"updated_at"`
        LastUsedAt  *time.Time       `json:"last_used_at,omitempty" db:"last_used_at"`
        ExpiresAt   *time.Time       `json:"expires_at,omitempty" db:"expires_at"`

        // Envelope encryption fields
        EncryptedDEK []byte `json:"-" db:"encrypted_dek"` // Never serialize
        Ciphertext   []byte `json:"-" db:"ciphertext"`    // Never serialize
        Nonce        []byte `json:"-" db:"nonce"`         // Never serialize
        AuthTag      []byte `json:"-" db:"auth_tag"`      // Never serialize
        KMSKeyID     string `json:"-" db:"kms_key_id"`    // Never serialize

        // Metadata stored as JSON
        Metadata map[string]interface{} `json:"metadata,omitempty" db:"metadata"`
}

// IsExpired checks if the credential has expired
func (c *Credential) IsExpired() bool <span class="cov0" title="0">{
        if c.ExpiresAt == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return time.Now().After(*c.ExpiresAt)</span>
}

// CredentialData represents plaintext credential data before encryption
// This is used internally by the encryption service
type CredentialData struct {
        Value map[string]interface{} `json:"value"`
}

// EncryptedSecret represents an encrypted credential value using envelope encryption
type EncryptedSecret struct {
        EncryptedDEK []byte `json:"encrypted_dek"` // Data Encryption Key encrypted by KMS
        Ciphertext   []byte `json:"ciphertext"`    // Data encrypted by DEK
        Nonce        []byte `json:"nonce"`         // Nonce for GCM
        AuthTag      []byte `json:"auth_tag"`      // Authentication tag for GCM
        KMSKeyID     string `json:"kms_key_id"`    // KMS key ID used to encrypt DEK
}

// CredentialValue represents the encrypted value of a credential
// This is stored separately and only returned through secure endpoints
type CredentialValue struct {
        ID           string    `json:"id" db:"id"`
        CredentialID string    `json:"credential_id" db:"credential_id"`
        Version      int       `json:"version" db:"version"`
        EncryptedValue string  `json:"-" db:"encrypted_value"` // Never serialize
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
        CreatedBy    string    `json:"created_by" db:"created_by"`
        IsActive     bool      `json:"is_active" db:"is_active"`
}

// AccessLog represents an access log entry for credential usage
type AccessLog struct {
        ID           string    `json:"id" db:"id"`
        CredentialID string    `json:"credential_id" db:"credential_id"`
        TenantID     string    `json:"tenant_id" db:"tenant_id"`
        AccessedBy   string    `json:"accessed_by" db:"accessed_by"`
        AccessType   string    `json:"access_type" db:"access_type"` // "read", "update", "rotate", "delete"
        AccessedAt   time.Time `json:"accessed_at" db:"accessed_at"`
        IPAddress    string    `json:"ip_address,omitempty" db:"ip_address"`
        UserAgent    string    `json:"user_agent,omitempty" db:"user_agent"`
        Success      bool      `json:"success" db:"success"`
        ErrorMessage string    `json:"error_message,omitempty" db:"error_message"`
}

// CreateCredentialInput represents input for creating a credential
type CreateCredentialInput struct {
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Type        CredentialType         `json:"type"`
        Value       map[string]interface{} `json:"value"` // Will be encrypted
        ExpiresAt   *time.Time             `json:"expires_at,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// UpdateCredentialInput represents input for updating credential metadata
// Note: This does NOT update the value - use Rotate for that
type UpdateCredentialInput struct {
        Name        *string                `json:"name,omitempty"`
        Description *string                `json:"description,omitempty"`
        Status      *CredentialStatus      `json:"status,omitempty"`
        ExpiresAt   *time.Time             `json:"expires_at,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// RotateCredentialInput represents input for rotating a credential value
type RotateCredentialInput struct {
        Value map[string]interface{} `json:"value"` // New value to encrypt
}

// CredentialListFilter represents filters for listing credentials
type CredentialListFilter struct {
        Type   CredentialType   `json:"type,omitempty"`
        Status CredentialStatus `json:"status,omitempty"`
        Search string           `json:"search,omitempty"` // Search in name/description
}

// DecryptedValue represents a decrypted credential value
// Only used internally and in the /value endpoint response
type DecryptedValue struct {
        Version   int                    `json:"version"`
        Value     map[string]interface{} `json:"value"`
        CreatedAt time.Time              `json:"created_at"`
}

// Validate validates CreateCredentialInput
func (c *CreateCredentialInput) Validate() error <span class="cov0" title="0">{
        if c.Name == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "name is required"}
        }</span>
        <span class="cov0" title="0">if len(c.Name) &gt; 255 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "name must be less than 255 characters"}
        }</span>
        <span class="cov0" title="0">if c.Type == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "type is required"}
        }</span>
        <span class="cov0" title="0">if c.Type != TypeAPIKey &amp;&amp; c.Type != TypeOAuth2 &amp;&amp; c.Type != TypeBasicAuth &amp;&amp; c.Type != TypeCustom </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "invalid credential type"}
        }</span>
        <span class="cov0" title="0">if c.Value == nil || len(c.Value) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "value is required"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Validate validates UpdateCredentialInput
func (u *UpdateCredentialInput) Validate() error <span class="cov0" title="0">{
        if u.Name != nil &amp;&amp; len(*u.Name) &gt; 255 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "name must be less than 255 characters"}
        }</span>
        <span class="cov0" title="0">if u.Status != nil </span><span class="cov0" title="0">{
                if *u.Status != StatusActive &amp;&amp; *u.Status != StatusInactive &amp;&amp; *u.Status != StatusRevoked </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Message: "invalid status"}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Validate validates RotateCredentialInput
func (r *RotateCredentialInput) Validate() error <span class="cov0" title="0">{
        if r.Value == nil || len(r.Value) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "value is required"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package credential

import (
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/json"
        "fmt"
        "io"
)

const (
        // NonceSize is the size of GCM nonce in bytes (96 bits)
        NonceSize = 12
)

// EncryptionService handles envelope encryption for credentials
type EncryptionService struct {
        kmsClient KMSClientInterface
}

// NewEncryptionService creates a new encryption service
func NewEncryptionService(kmsClient KMSClientInterface) *EncryptionService <span class="cov0" title="0">{
        return &amp;EncryptionService{
                kmsClient: kmsClient,
        }
}</span>

// Encrypt encrypts credential data using envelope encryption
// Returns the encrypted data (ciphertext + nonce combined) and encrypted data key
func (s *EncryptionService) Encrypt(ctx context.Context, data *CredentialData) ([]byte, []byte, error) <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: ErrEmptyCredentialData,
                }
        }</span>

        // Serialize credential data to JSON
        <span class="cov0" title="0">plaintext, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to marshal credential data: %w", err),
                }
        }</span>

        // Generate data encryption key via KMS
        // Note: In a real implementation, we'd pass the KMS key ID and encryption context
        <span class="cov0" title="0">plainKey, encryptedKey, err := s.kmsClient.GenerateDataKey(ctx, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to generate data key: %w", err),
                }
        }</span>

        // Ensure key is cleared after use
        <span class="cov0" title="0">defer ClearKey(plainKey)

        // Encrypt data with AES-256-GCM
        encryptedData, err := s.encryptWithAESGCM(plaintext, plainKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to encrypt data: %w", err),
                }
        }</span>

        <span class="cov0" title="0">return encryptedData, encryptedKey, nil</span>
}

// Decrypt decrypts credential data using envelope encryption
func (s *EncryptionService) Decrypt(ctx context.Context, encryptedData, encryptedKey []byte) (*CredentialData, error) <span class="cov0" title="0">{
        if len(encryptedData) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: ErrInvalidCiphertext,
                }
        }</span>

        <span class="cov0" title="0">if len(encryptedKey) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: ErrInvalidCiphertext,
                }
        }</span>

        // Decrypt the data encryption key using KMS
        <span class="cov0" title="0">plainKey, err := s.kmsClient.DecryptDataKey(ctx, encryptedKey, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to decrypt data key: %w", err),
                }
        }</span>

        // Ensure key is cleared after use
        <span class="cov0" title="0">defer ClearKey(plainKey)

        // Decrypt data with AES-256-GCM
        plaintext, err := s.decryptWithAESGCM(encryptedData, plainKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to decrypt data: %w", err),
                }
        }</span>

        // Deserialize credential data
        <span class="cov0" title="0">var data CredentialData
        if err := json.Unmarshal(plaintext, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to unmarshal credential data: %w", err),
                }
        }</span>

        <span class="cov0" title="0">return &amp;data, nil</span>
}

// encryptWithAESGCM encrypts plaintext using AES-256-GCM
// Returns nonce prepended to ciphertext for convenience
func (s *EncryptionService) encryptWithAESGCM(plaintext, key []byte) ([]byte, error) <span class="cov0" title="0">{
        // Create AES cipher
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // Create GCM mode
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Generate random nonce
        <span class="cov0" title="0">nonce := make([]byte, NonceSize)
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Encrypt data (includes authentication tag)
        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, nonce, plaintext, nil)

        // Prepend nonce to ciphertext for easy retrieval during decryption
        result := make([]byte, len(nonce)+len(ciphertext))
        copy(result[:NonceSize], nonce)
        copy(result[NonceSize:], ciphertext)

        return result, nil</span>
}

// decryptWithAESGCM decrypts ciphertext using AES-256-GCM
// Expects nonce to be prepended to ciphertext
func (s *EncryptionService) decryptWithAESGCM(encryptedData, key []byte) ([]byte, error) <span class="cov0" title="0">{
        // Validate minimum length (nonce + at least 1 byte + auth tag)
        if len(encryptedData) &lt; NonceSize+1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidCiphertext
        }</span>

        // Extract nonce and ciphertext
        <span class="cov0" title="0">nonce := encryptedData[:NonceSize]
        ciphertext := encryptedData[NonceSize:]

        // Create AES cipher
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // Create GCM mode
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Decrypt and verify authentication tag
        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt or verify: %w", err)
        }</span>

        <span class="cov0" title="0">return plaintext, nil</span>
}

// EncryptWithContext encrypts credential data with encryption context
func (s *EncryptionService) EncryptWithContext(ctx context.Context, data *CredentialData, keyID string, encryptionContext map[string]string) ([]byte, []byte, error) <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "EncryptWithContext",
                        Err: ErrEmptyCredentialData,
                }
        }</span>

        <span class="cov0" title="0">if keyID == "" </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "EncryptWithContext",
                        Err: ErrInvalidKeyID,
                }
        }</span>

        // Serialize credential data to JSON
        <span class="cov0" title="0">plaintext, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "EncryptWithContext",
                        Err: fmt.Errorf("failed to marshal credential data: %w", err),
                }
        }</span>

        // Generate data encryption key via KMS with context
        <span class="cov0" title="0">plainKey, encryptedKey, err := s.kmsClient.GenerateDataKey(ctx, keyID, encryptionContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "EncryptWithContext",
                        Err: fmt.Errorf("failed to generate data key: %w", err),
                }
        }</span>

        // Ensure key is cleared after use
        <span class="cov0" title="0">defer ClearKey(plainKey)

        // Encrypt data with AES-256-GCM
        encryptedData, err := s.encryptWithAESGCM(plaintext, plainKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;EncryptionError{
                        Op:  "EncryptWithContext",
                        Err: fmt.Errorf("failed to encrypt data: %w", err),
                }
        }</span>

        <span class="cov0" title="0">return encryptedData, encryptedKey, nil</span>
}

// DecryptWithContext decrypts credential data with encryption context
func (s *EncryptionService) DecryptWithContext(ctx context.Context, encryptedData, encryptedKey []byte, encryptionContext map[string]string) (*CredentialData, error) <span class="cov0" title="0">{
        if len(encryptedData) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "DecryptWithContext",
                        Err: ErrInvalidCiphertext,
                }
        }</span>

        <span class="cov0" title="0">if len(encryptedKey) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "DecryptWithContext",
                        Err: ErrInvalidCiphertext,
                }
        }</span>

        // Decrypt the data encryption key using KMS with context
        <span class="cov0" title="0">plainKey, err := s.kmsClient.DecryptDataKey(ctx, encryptedKey, encryptionContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "DecryptWithContext",
                        Err: fmt.Errorf("failed to decrypt data key: %w", err),
                }
        }</span>

        // Ensure key is cleared after use
        <span class="cov0" title="0">defer ClearKey(plainKey)

        // Decrypt data with AES-256-GCM
        plaintext, err := s.decryptWithAESGCM(encryptedData, plainKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "DecryptWithContext",
                        Err: fmt.Errorf("failed to decrypt data: %w", err),
                }
        }</span>

        // Deserialize credential data
        <span class="cov0" title="0">var data CredentialData
        if err := json.Unmarshal(plaintext, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "DecryptWithContext",
                        Err: fmt.Errorf("failed to unmarshal credential data: %w", err),
                }
        }</span>

        <span class="cov0" title="0">return &amp;data, nil</span>
}

// SimpleEncryptionService provides testing/development encryption without KMS
// Uses a fixed master key to encrypt DEKs instead of AWS KMS
type SimpleEncryptionService struct {
        masterKey []byte
}

// NewSimpleEncryptionService creates a new simple encryption service for testing
// masterKey must be exactly 32 bytes (256 bits)
func NewSimpleEncryptionService(masterKey []byte) (*SimpleEncryptionService, error) <span class="cov8" title="1">{
        if len(masterKey) != 32 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("master key must be exactly 32 bytes, got %d", len(masterKey))
        }</span>

        // Make a copy to prevent external modification
        <span class="cov8" title="1">keyCopy := make([]byte, 32)
        copy(keyCopy, masterKey)

        return &amp;SimpleEncryptionService{
                masterKey: keyCopy,
        }, nil</span>
}

// Encrypt encrypts credential data using envelope encryption with a fixed master key
func (s *SimpleEncryptionService) Encrypt(ctx context.Context, tenantID string, data *CredentialData) (*EncryptedSecret, error) <span class="cov8" title="1">{
        if data == nil </span><span class="cov8" title="1">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: ErrEmptyCredentialData,
                }
        }</span>

        // Serialize credential data to JSON
        <span class="cov8" title="1">plaintext, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to marshal credential data: %w", err),
                }
        }</span>

        // Generate random DEK (32 bytes for AES-256)
        <span class="cov8" title="1">dek := make([]byte, 32)
        if _, err := io.ReadFull(rand.Reader, dek); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to generate DEK: %w", err),
                }
        }</span>
        <span class="cov8" title="1">defer ClearKey(dek)

        // Encrypt DEK with master key
        block, err := aes.NewCipher(s.masterKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to create cipher for DEK encryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to create GCM for DEK encryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">dekNonce := make([]byte, NonceSize)
        if _, err := io.ReadFull(rand.Reader, dekNonce); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to generate DEK nonce: %w", err),
                }
        }</span>

        // Encrypt DEK (includes auth tag)
        <span class="cov8" title="1">encryptedDEK := gcm.Seal(nil, dekNonce, dek, nil)

        // Prepend nonce to encrypted DEK
        encryptedDEKWithNonce := make([]byte, len(dekNonce)+len(encryptedDEK))
        copy(encryptedDEKWithNonce, dekNonce)
        copy(encryptedDEKWithNonce[len(dekNonce):], encryptedDEK)

        // Encrypt credential data with DEK
        dataBlock, err := aes.NewCipher(dek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to create cipher for data encryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">dataGCM, err := cipher.NewGCM(dataBlock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to create GCM for data encryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, NonceSize)
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("failed to generate nonce: %w", err),
                }
        }</span>

        // Encrypt and get ciphertext with auth tag
        <span class="cov8" title="1">ciphertextWithTag := dataGCM.Seal(nil, nonce, plaintext, nil)

        // Split ciphertext and auth tag
        // GCM auth tag is always the last 16 bytes
        authTagSize := dataGCM.Overhead()
        if len(ciphertextWithTag) &lt; authTagSize </span><span class="cov0" title="0">{
                return nil, &amp;EncryptionError{
                        Op:  "Encrypt",
                        Err: fmt.Errorf("ciphertext too short"),
                }
        }</span>

        <span class="cov8" title="1">ciphertext := ciphertextWithTag[:len(ciphertextWithTag)-authTagSize]
        authTag := ciphertextWithTag[len(ciphertextWithTag)-authTagSize:]

        return &amp;EncryptedSecret{
                EncryptedDEK: encryptedDEKWithNonce,
                Ciphertext:   ciphertext,
                Nonce:        nonce,
                AuthTag:      authTag,
                KMSKeyID:     "simple-encryption", // Identifier for non-KMS encryption
        }, nil</span>
}

// Decrypt decrypts credential data using envelope encryption with a fixed master key
func (s *SimpleEncryptionService) Decrypt(ctx context.Context, encrypted *EncryptedSecret) (*CredentialData, error) <span class="cov8" title="1">{
        if encrypted == nil </span><span class="cov8" title="1">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: ErrInvalidCiphertext,
                }
        }</span>

        // Validate encrypted data
        <span class="cov8" title="1">if len(encrypted.EncryptedDEK) &lt; NonceSize+1 </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("encrypted DEK too short"),
                }
        }</span>

        <span class="cov8" title="1">if len(encrypted.Nonce) != NonceSize </span><span class="cov8" title="1">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: ErrInvalidNonce,
                }
        }</span>

        // Extract nonce and encrypted DEK
        <span class="cov8" title="1">dekNonce := encrypted.EncryptedDEK[:NonceSize]
        encryptedDEK := encrypted.EncryptedDEK[NonceSize:]

        // Decrypt DEK with master key
        block, err := aes.NewCipher(s.masterKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to create cipher for DEK decryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to create GCM for DEK decryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">dek, err := gcm.Open(nil, dekNonce, encryptedDEK, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to decrypt DEK: %w", err),
                }
        }</span>
        <span class="cov8" title="1">defer ClearKey(dek)

        // Validate DEK size
        if len(dek) != 32 </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("invalid DEK size: got %d, want 32", len(dek)),
                }
        }</span>

        // Decrypt credential data with DEK
        <span class="cov8" title="1">dataBlock, err := aes.NewCipher(dek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to create cipher for data decryption: %w", err),
                }
        }</span>

        <span class="cov8" title="1">dataGCM, err := cipher.NewGCM(dataBlock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to create GCM for data decryption: %w", err),
                }
        }</span>

        // Combine ciphertext and auth tag for GCM
        <span class="cov8" title="1">ciphertextWithTag := make([]byte, len(encrypted.Ciphertext)+len(encrypted.AuthTag))
        copy(ciphertextWithTag, encrypted.Ciphertext)
        copy(ciphertextWithTag[len(encrypted.Ciphertext):], encrypted.AuthTag)

        // Decrypt and verify
        plaintext, err := dataGCM.Open(nil, encrypted.Nonce, ciphertextWithTag, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to decrypt data: %w", err),
                }
        }</span>

        // Deserialize credential data
        <span class="cov8" title="1">var data CredentialData
        if err := json.Unmarshal(plaintext, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;DecryptionError{
                        Op:  "Decrypt",
                        Err: fmt.Errorf("failed to unmarshal credential data: %w", err),
                }
        }</span>

        <span class="cov8" title="1">return &amp;data, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package credential

import (
        "errors"
        "fmt"
)

var (
        // ErrNotFound is returned when a credential is not found
        ErrNotFound = errors.New("credential not found")

        // ErrInvalidTenantID is returned when tenant ID is empty or invalid
        ErrInvalidTenantID = errors.New("tenant ID cannot be empty")

        // ErrInvalidCredentialID is returned when credential ID is empty or invalid
        ErrInvalidCredentialID = errors.New("credential ID cannot be empty")

        // ErrInvalidCredentialName is returned when credential name is empty or invalid
        ErrInvalidCredentialName = errors.New("credential name cannot be empty")

        // ErrInvalidCredentialType is returned when credential type is invalid
        ErrInvalidCredentialType = errors.New("credential type is invalid")

        // ErrEmptyCredentialData is returned when credential data is empty
        ErrEmptyCredentialData = errors.New("credential data cannot be empty")

        // ErrDuplicateCredential is returned when a credential with the same name already exists
        ErrDuplicateCredential = errors.New("credential with this name already exists")

        // ErrEncryptionFailed is returned when encryption operation fails
        ErrEncryptionFailed = errors.New("encryption failed")

        // ErrDecryptionFailed is returned when decryption operation fails
        ErrDecryptionFailed = errors.New("decryption failed")

        // ErrKMSOperationFailed is returned when KMS operation fails
        ErrKMSOperationFailed = errors.New("KMS operation failed")

        // ErrInvalidEncryptionContext is returned when encryption context is invalid
        ErrInvalidEncryptionContext = errors.New("encryption context is invalid")

        // ErrInvalidKeyID is returned when KMS key ID is empty or invalid
        ErrInvalidKeyID = errors.New("KMS key ID cannot be empty")

        // ErrDataKeyGenerationFailed is returned when DEK generation fails
        ErrDataKeyGenerationFailed = errors.New("data key generation failed")

        // ErrInvalidCiphertext is returned when ciphertext is invalid or corrupted
        ErrInvalidCiphertext = errors.New("invalid or corrupted ciphertext")

        // ErrInvalidNonce is returned when nonce is invalid
        ErrInvalidNonce = errors.New("invalid nonce")
)

// EncryptionError wraps an error with additional context
type EncryptionError struct {
        Op  string // Operation being performed
        Err error  // Underlying error
}

func (e *EncryptionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("encryption error during %s: %v", e.Op, e.Err)
}</span>

func (e *EncryptionError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// DecryptionError wraps an error with additional context
type DecryptionError struct {
        Op  string // Operation being performed
        Err error  // Underlying error
}

func (e *DecryptionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("decryption error during %s: %v", e.Op, e.Err)
}</span>

func (e *DecryptionError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// KMSError wraps an error with additional context
type KMSError struct {
        Op    string // Operation being performed (GenerateDataKey, Decrypt, etc.)
        KeyID string // KMS key ID
        Err   error  // Underlying error
}

func (e *KMSError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("KMS error during %s (key: %s): %v", e.Op, e.KeyID, e.Err)
}</span>

func (e *KMSError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package credential

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
)

// credentialReferenceRegex matches {{credentials.name}} patterns
var credentialReferenceRegex = regexp.MustCompile(`\{\{credentials\.([a-zA-Z0-9_-]+)\}\}`)

// RepositoryInterface defines the interface for credential repository operations
type RepositoryInterface interface {
        ValidateAndGet(ctx context.Context, tenantID, name string) (*Credential, error)
        UpdateAccessTime(ctx context.Context, tenantID, credentialID string) error
        LogAccess(ctx context.Context, log *AccessLog) error
}

// EncryptionServiceInterface defines the interface for encryption operations
type EncryptionServiceInterface interface {
        Decrypt(ctx context.Context, encryptedData, encryptedKey []byte) (*CredentialData, error)
}

// Injector handles credential injection into workflow actions
type Injector struct {
        repo       RepositoryInterface
        encryption EncryptionServiceInterface
        masker     *Masker
}

// NewInjector creates a new credential injector
func NewInjector(repo RepositoryInterface, encryption EncryptionServiceInterface) *Injector <span class="cov0" title="0">{
        return &amp;Injector{
                repo:       repo,
                encryption: encryption,
                masker:     NewMasker(),
        }
}</span>

// InjectionContext holds context for credential injection
type InjectionContext struct {
        TenantID    string
        WorkflowID  string
        ExecutionID string
        AccessedBy  string
}

// InjectResult holds the result of credential injection
type InjectResult struct {
        Config json.RawMessage // Config with credentials injected
        Values []string        // Decrypted credential values for masking
}

// InjectCredentials extracts credential references from config and injects decrypted values
func (i *Injector) InjectCredentials(ctx context.Context, config json.RawMessage, injCtx *InjectionContext) (*InjectResult, error) <span class="cov0" title="0">{
        // Parse config to extract credential references
        credentialRefs, err := i.ExtractCredentialReferences(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract credential references: %w", err)
        }</span>

        // If no credentials referenced, return original config
        <span class="cov0" title="0">if len(credentialRefs) == 0 </span><span class="cov0" title="0">{
                return &amp;InjectResult{
                        Config: config,
                        Values: []string{},
                }, nil
        }</span>

        // Fetch and decrypt all referenced credentials
        <span class="cov0" title="0">credentials := make(map[string]string)
        var values []string

        for _, credName := range credentialRefs </span><span class="cov0" title="0">{
                value, err := i.getCredentialValue(ctx, injCtx.TenantID, credName, injCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get credential '%s': %w", credName, err)
                }</span>
                <span class="cov0" title="0">credentials[credName] = value
                values = append(values, value)</span>
        }

        // Inject credentials into config
        <span class="cov0" title="0">injectedConfig, err := i.injectValues(config, credentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inject credentials: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;InjectResult{
                Config: injectedConfig,
                Values: values,
        }, nil</span>
}

// ExtractCredentialReferences extracts unique credential names from config
func (i *Injector) ExtractCredentialReferences(config json.RawMessage) ([]string, error) <span class="cov0" title="0">{
        // Convert to string to search for patterns
        configStr := string(config)

        // Find all credential references
        matches := credentialReferenceRegex.FindAllStringSubmatch(configStr, -1)

        // Extract unique credential names
        credNames := make(map[string]bool)
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        credNames[match[1]] = true
                }</span>
        }

        // Convert map to slice
        <span class="cov0" title="0">var result []string
        for name := range credNames </span><span class="cov0" title="0">{
                result = append(result, name)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// getCredentialValue retrieves and decrypts a credential value
func (i *Injector) getCredentialValue(ctx context.Context, tenantID, name string, injCtx *InjectionContext) (string, error) <span class="cov0" title="0">{
        // Validate and get credential
        cred, err := i.repo.ValidateAndGet(ctx, tenantID, name)
        if err != nil </span><span class="cov0" title="0">{
                // Log failed access
                _ = i.repo.LogAccess(ctx, &amp;AccessLog{
                        TenantID:     tenantID,
                        CredentialID: name,
                        AccessedBy:   injCtx.AccessedBy,
                        AccessType:   AccessTypeRead,
                        Success:      false,
                        ErrorMessage: err.Error(),
                })
                return "", err
        }</span>

        // Decrypt the value using envelope encryption
        // The Ciphertext field contains the encrypted data (nonce + ciphertext + tag combined)
        <span class="cov0" title="0">credData, err := i.encryption.Decrypt(ctx, cred.Ciphertext, cred.EncryptedDEK)
        if err != nil </span><span class="cov0" title="0">{
                // Log failed decryption
                _ = i.repo.LogAccess(ctx, &amp;AccessLog{
                        TenantID:     tenantID,
                        CredentialID: cred.ID,
                        AccessedBy:   injCtx.AccessedBy,
                        AccessType:   AccessTypeRead,
                        Success:      false,
                        ErrorMessage: err.Error(),
                })
                return "", fmt.Errorf("failed to decrypt credential: %w", err)
        }</span>

        // Extract the actual credential value
        // For injection, we typically need a string representation
        // The credData.Value map might have a "key" or "token" field depending on the credential type
        <span class="cov0" title="0">value := i.extractCredentialValue(credData.Value)

        // Update access time
        _ = i.repo.UpdateAccessTime(ctx, tenantID, cred.ID)

        // Log successful access
        _ = i.repo.LogAccess(ctx, &amp;AccessLog{
                TenantID:     tenantID,
                CredentialID: cred.ID,
                AccessedBy:   injCtx.AccessedBy,
                AccessType:   AccessTypeRead,
                Success:      true,
        })

        return value, nil</span>
}

// extractCredentialValue extracts a usable string value from credential data
// For different credential types, the value might be in different fields
func (i *Injector) extractCredentialValue(value map[string]interface{}) string <span class="cov0" title="0">{
        // Try common field names based on credential type
        if v, ok := value["api_key"]; ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", v)
        }</span>
        <span class="cov0" title="0">if v, ok := value["token"]; ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", v)
        }</span>
        <span class="cov0" title="0">if v, ok := value["secret"]; ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", v)
        }</span>
        <span class="cov0" title="0">if v, ok := value["key"]; ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", v)
        }</span>
        <span class="cov0" title="0">if v, ok := value["password"]; ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%v", v)
        }</span>

        // If none of the common fields found, marshal the entire value as JSON
        <span class="cov0" title="0">data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

// injectValues replaces credential references with actual values
func (i *Injector) injectValues(config json.RawMessage, credentials map[string]string) (json.RawMessage, error) <span class="cov0" title="0">{
        // Parse config to interface{}
        var data interface{}
        if err := json.Unmarshal(config, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Recursively inject credentials
        <span class="cov0" title="0">injected := i.injectValue(data, credentials)

        // Marshal back to JSON
        result, err := json.Marshal(injected)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// injectValue recursively injects credentials into a value
func (i *Injector) injectValue(value interface{}, credentials map[string]string) interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                // Replace credential references in strings
                return i.replaceCredentialReferences(v, credentials)</span>

        case map[string]interface{}:<span class="cov0" title="0">
                // Recursively inject into map values
                result := make(map[string]interface{})
                for key, val := range v </span><span class="cov0" title="0">{
                        result[key] = i.injectValue(val, credentials)
                }</span>
                <span class="cov0" title="0">return result</span>

        case []interface{}:<span class="cov0" title="0">
                // Recursively inject into array elements
                result := make([]interface{}, len(v))
                for idx, val := range v </span><span class="cov0" title="0">{
                        result[idx] = i.injectValue(val, credentials)
                }</span>
                <span class="cov0" title="0">return result</span>

        default:<span class="cov0" title="0">
                // Return non-string types as-is
                return v</span>
        }
}

// replaceCredentialReferences replaces {{credentials.name}} with actual values
func (i *Injector) replaceCredentialReferences(input string, credentials map[string]string) string <span class="cov0" title="0">{
        return credentialReferenceRegex.ReplaceAllStringFunc(input, func(match string) string </span><span class="cov0" title="0">{
                // Extract credential name
                submatch := credentialReferenceRegex.FindStringSubmatch(match)
                if len(submatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match // Return original if no match
                }</span>

                <span class="cov0" title="0">credName := submatch[1]

                // Look up credential value
                if value, exists := credentials[credName]; exists </span><span class="cov0" title="0">{
                        return value
                }</span>

                // Return original if credential not found (should not happen if extraction worked correctly)
                <span class="cov0" title="0">return match</span>
        })
}

// MaskOutput masks credential values in output data
func (i *Injector) MaskOutput(data interface{}, credentialValues []string) interface{} <span class="cov0" title="0">{
        return i.masker.maskValue(data, credentialValues)
}</span>

// MaskOutputJSON masks credential values in JSON output
func (i *Injector) MaskOutputJSON(data json.RawMessage, credentialValues []string) (json.RawMessage, error) <span class="cov0" title="0">{
        return i.masker.MaskRawJSON(data, credentialValues)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package credential

import (
        "context"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/kms"
)

const (
        // DataKeySize is the size of AES-256 key in bytes
        DataKeySize = 32
        // DataKeyCacheTTL is the time-to-live for cached data keys
        DataKeyCacheTTL = 5 * time.Minute
)

// KMSClientInterface defines the interface for KMS operations
type KMSClientInterface interface {
        GenerateDataKey(ctx context.Context, keyID string, encryptionContext map[string]string) ([]byte, []byte, error)
        DecryptDataKey(ctx context.Context, encryptedKey []byte, encryptionContext map[string]string) ([]byte, error)
}

// KMSClient wraps AWS KMS client for envelope encryption
type KMSClient struct {
        client *kms.Client
        keyID  string
        cache  *dataKeyCache
}

// dataKeyCache caches data keys to reduce KMS calls
type dataKeyCache struct {
        mu      sync.RWMutex
        entries map[string]*cacheEntry
}

type cacheEntry struct {
        plainKey     []byte
        encryptedKey []byte
        expiresAt    time.Time
}

// NewKMSClient creates a new KMS client wrapper with LocalStack support
func NewKMSClient(ctx context.Context, keyID string) (*KMSClient, error) <span class="cov0" title="0">{
        if keyID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidKeyID
        }</span>

        // Load AWS config with LocalStack support
        <span class="cov0" title="0">cfg, err := loadAWSConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;KMSError{
                        Op:    "NewKMSClient",
                        KeyID: keyID,
                        Err:   fmt.Errorf("failed to load AWS config: %w", err),
                }
        }</span>

        // Create KMS client
        <span class="cov0" title="0">kmsClient := kms.NewFromConfig(cfg)

        return &amp;KMSClient{
                client: kmsClient,
                keyID:  keyID,
                cache: &amp;dataKeyCache{
                        entries: make(map[string]*cacheEntry),
                },
        }, nil</span>
}

// loadAWSConfig loads AWS configuration with LocalStack support
func loadAWSConfig(ctx context.Context) (aws.Config, error) <span class="cov0" title="0">{
        // Check if running in LocalStack mode
        localStackEndpoint := os.Getenv("LOCALSTACK_ENDPOINT")

        if localStackEndpoint != "" </span><span class="cov0" title="0">{
                // LocalStack configuration
                cfg, err := config.LoadDefaultConfig(ctx,
                        config.WithRegion("us-east-1"),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return aws.Config{}, err
                }</span>

                // Override endpoint for LocalStack
                <span class="cov0" title="0">cfg.BaseEndpoint = aws.String(localStackEndpoint)

                return cfg, nil</span>
        }

        // Standard AWS configuration
        <span class="cov0" title="0">return config.LoadDefaultConfig(ctx)</span>
}

// GenerateDataKey generates a new AES-256 data encryption key
func (c *KMSClient) GenerateDataKey(ctx context.Context, keyID string, encryptionContext map[string]string) ([]byte, []byte, error) <span class="cov0" title="0">{
        if keyID == "" </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidKeyID
        }</span>

        // Check cache first
        <span class="cov0" title="0">if plainKey, encryptedKey := c.getCachedKey(keyID, encryptionContext); plainKey != nil </span><span class="cov0" title="0">{
                return plainKey, encryptedKey, nil
        }</span>

        // Convert encryption context
        <span class="cov0" title="0">kmsContext := convertEncryptionContext(encryptionContext)

        // Generate data key via KMS
        input := &amp;kms.GenerateDataKeyInput{
                KeyId:             aws.String(keyID),
                NumberOfBytes:     aws.Int32(DataKeySize),
                EncryptionContext: kmsContext,
        }

        result, err := c.client.GenerateDataKey(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, &amp;KMSError{
                        Op:    "GenerateDataKey",
                        KeyID: keyID,
                        Err:   fmt.Errorf("KMS GenerateDataKey failed: %w", err),
                }
        }</span>

        // Validate result
        <span class="cov0" title="0">if len(result.Plaintext) != DataKeySize </span><span class="cov0" title="0">{
                return nil, nil, &amp;KMSError{
                        Op:    "GenerateDataKey",
                        KeyID: keyID,
                        Err:   fmt.Errorf("invalid data key size: got %d, want %d", len(result.Plaintext), DataKeySize),
                }
        }</span>

        // Cache the key
        <span class="cov0" title="0">c.cacheKey(keyID, encryptionContext, result.Plaintext, result.CiphertextBlob)

        // Return copies to prevent cache modification
        plainKey := make([]byte, len(result.Plaintext))
        copy(plainKey, result.Plaintext)

        encryptedKey := make([]byte, len(result.CiphertextBlob))
        copy(encryptedKey, result.CiphertextBlob)

        return plainKey, encryptedKey, nil</span>
}

// DecryptDataKey decrypts an encrypted data key using KMS
func (c *KMSClient) DecryptDataKey(ctx context.Context, encryptedKey []byte, encryptionContext map[string]string) ([]byte, error) <span class="cov0" title="0">{
        if len(encryptedKey) == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidCiphertext
        }</span>

        // Convert encryption context
        <span class="cov0" title="0">kmsContext := convertEncryptionContext(encryptionContext)

        // Decrypt via KMS
        input := &amp;kms.DecryptInput{
                CiphertextBlob:    encryptedKey,
                EncryptionContext: kmsContext,
        }

        result, err := c.client.Decrypt(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;KMSError{
                        Op:    "DecryptDataKey",
                        KeyID: c.keyID,
                        Err:   fmt.Errorf("KMS Decrypt failed: %w", err),
                }
        }</span>

        // Validate result
        <span class="cov0" title="0">if len(result.Plaintext) != DataKeySize </span><span class="cov0" title="0">{
                return nil, &amp;KMSError{
                        Op:    "DecryptDataKey",
                        KeyID: c.keyID,
                        Err:   fmt.Errorf("invalid decrypted key size: got %d, want %d", len(result.Plaintext), DataKeySize),
                }
        }</span>

        <span class="cov0" title="0">return result.Plaintext, nil</span>
}

// getCachedKey retrieves a cached data key if available and not expired
func (c *KMSClient) getCachedKey(keyID string, encryptionContext map[string]string) ([]byte, []byte) <span class="cov0" title="0">{
        cacheKey := buildCacheKey(keyID, encryptionContext)

        c.cache.mu.RLock()
        defer c.cache.mu.RUnlock()

        entry, exists := c.cache.entries[cacheKey]
        if !exists || time.Now().After(entry.expiresAt) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Return copies to prevent cache modification
        <span class="cov0" title="0">plainKey := make([]byte, len(entry.plainKey))
        copy(plainKey, entry.plainKey)

        encryptedKey := make([]byte, len(entry.encryptedKey))
        copy(encryptedKey, entry.encryptedKey)

        return plainKey, encryptedKey</span>
}

// cacheKey stores a data key in cache
func (c *KMSClient) cacheKey(keyID string, encryptionContext map[string]string, plainKey, encryptedKey []byte) <span class="cov0" title="0">{
        cacheKey := buildCacheKey(keyID, encryptionContext)

        c.cache.mu.Lock()
        defer c.cache.mu.Unlock()

        // Store copies to prevent external modification
        plainKeyCopy := make([]byte, len(plainKey))
        copy(plainKeyCopy, plainKey)

        encryptedKeyCopy := make([]byte, len(encryptedKey))
        copy(encryptedKeyCopy, encryptedKey)

        c.cache.entries[cacheKey] = &amp;cacheEntry{
                plainKey:     plainKeyCopy,
                encryptedKey: encryptedKeyCopy,
                expiresAt:    time.Now().Add(DataKeyCacheTTL),
        }
}</span>

// buildCacheKey creates a cache key from key ID and encryption context
func buildCacheKey(keyID string, encryptionContext map[string]string) string <span class="cov0" title="0">{
        // Simple cache key - in production, might want to include sorted context
        key := keyID
        if len(encryptionContext) &gt; 0 </span><span class="cov0" title="0">{
                for k, v := range encryptionContext </span><span class="cov0" title="0">{
                        key += fmt.Sprintf(":%s=%s", k, v)
                }</span>
        }
        <span class="cov0" title="0">return key</span>
}

// convertEncryptionContext converts map[string]string to map[string]*string for KMS API
func convertEncryptionContext(ctx map[string]string) map[string]string <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // AWS SDK v2 uses map[string]string directly
        <span class="cov0" title="0">return ctx</span>
}

// ClearKey securely zeros out a key in memory
func ClearKey(key []byte) <span class="cov8" title="1">{
        for i := range key </span><span class="cov8" title="1">{
                key[i] = 0
        }</span>
}

// ClearCache clears all cached keys and zeros them out
func (c *KMSClient) ClearCache() <span class="cov0" title="0">{
        c.cache.mu.Lock()
        defer c.cache.mu.Unlock()

        for key, entry := range c.cache.entries </span><span class="cov0" title="0">{
                // Zero out sensitive data
                ClearKey(entry.plainKey)
                ClearKey(entry.encryptedKey)
                delete(c.cache.entries, key)
        }</span>
}

// EvictExpiredKeys removes expired entries from cache
func (c *KMSClient) EvictExpiredKeys() <span class="cov0" title="0">{
        c.cache.mu.Lock()
        defer c.cache.mu.Unlock()

        now := time.Now()
        for key, entry := range c.cache.entries </span><span class="cov0" title="0">{
                if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                        // Zero out sensitive data
                        ClearKey(entry.plainKey)
                        ClearKey(entry.encryptedKey)
                        delete(c.cache.entries, key)
                }</span>
        }
}

// GetKeyID returns the default KMS key ID
func (c *KMSClient) GetKeyID() string <span class="cov0" title="0">{
        return c.keyID
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package credential

import (
        "encoding/json"
        "strings"
)

const DefaultMask = "***MASKED***"

// Masker handles masking of sensitive credential values in logs and outputs
type Masker struct {
        mask string
}

// NewMasker creates a new masker with default mask string
func NewMasker() *Masker <span class="cov8" title="1">{
        return &amp;Masker{
                mask: DefaultMask,
        }
}</span>

// NewMaskerWithMask creates a new masker with custom mask string
func NewMaskerWithMask(mask string) *Masker <span class="cov8" title="1">{
        return &amp;Masker{
                mask: mask,
        }
}</span>

// MaskString replaces all occurrences of secrets in the input string with the mask
func (m *Masker) MaskString(input string, secrets []string) string <span class="cov8" title="1">{
        if input == "" || len(secrets) == 0 </span><span class="cov8" title="1">{
                return input
        }</span>

        <span class="cov8" title="1">result := input
        for _, secret := range secrets </span><span class="cov8" title="1">{
                if secret != "" </span><span class="cov8" title="1">{
                        result = strings.ReplaceAll(result, secret, m.mask)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// MaskJSON recursively masks secrets in a JSON structure
func (m *Masker) MaskJSON(data map[string]interface{}, secrets []string) map[string]interface{} <span class="cov8" title="1">{
        if len(secrets) == 0 </span><span class="cov0" title="0">{
                return data
        }</span>

        <span class="cov8" title="1">result := make(map[string]interface{})
        for key, value := range data </span><span class="cov8" title="1">{
                result[key] = m.maskValue(value, secrets)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// maskValue recursively masks a value
func (m *Masker) maskValue(value interface{}, secrets []string) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return m.MaskString(v, secrets)</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return m.MaskJSON(v, secrets)</span>
        case []interface{}:<span class="cov8" title="1">
                result := make([]interface{}, len(v))
                for i, item := range v </span><span class="cov8" title="1">{
                        result[i] = m.maskValue(item, secrets)
                }</span>
                <span class="cov8" title="1">return result</span>
        default:<span class="cov8" title="1">
                // Preserve non-string types as-is
                return v</span>
        }
}

// MaskRawJSON masks secrets in raw JSON data
func (m *Masker) MaskRawJSON(data json.RawMessage, secrets []string) (json.RawMessage, error) <span class="cov8" title="1">{
        if len(data) == 0 || len(secrets) == 0 </span><span class="cov0" title="0">{
                return data, nil
        }</span>

        <span class="cov8" title="1">var parsed interface{}
        if err := json.Unmarshal(data, &amp;parsed); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">masked := m.maskValue(parsed, secrets)

        result, err := json.Marshal(masked)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// ExtractSecrets recursively extracts all string values from a data structure
// This is useful for extracting credential values that need to be masked
func (m *Masker) ExtractSecrets(value interface{}) []string <span class="cov8" title="1">{
        var secrets []string

        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                if v != "" </span><span class="cov8" title="1">{
                        secrets = append(secrets, v)
                }</span>
        case map[string]interface{}:<span class="cov8" title="1">
                for _, val := range v </span><span class="cov8" title="1">{
                        secrets = append(secrets, m.ExtractSecrets(val)...)
                }</span>
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        secrets = append(secrets, m.ExtractSecrets(item)...)
                }</span>
        }

        <span class="cov8" title="1">return secrets</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package credential

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
        "github.com/lib/pq"
)

// Repository handles credential database operations
type Repository struct {
        db *sqlx.DB
}

// NewRepository creates a new credential repository
func NewRepository(db *sqlx.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{db: db}
}</span>

// Create inserts a new credential
func (r *Repository) Create(ctx context.Context, tenantID, createdBy string, cred *Credential) (*Credential, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if createdBy == "" </span><span class="cov0" title="0">{
                return nil, errors.New("created_by cannot be empty")
        }</span>

        <span class="cov0" title="0">if cred == nil </span><span class="cov0" title="0">{
                return nil, ErrEmptyCredentialData
        }</span>

        <span class="cov0" title="0">if cred.Name == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentialName
        }</span>

        // Validate credential type
        <span class="cov0" title="0">if cred.Type != TypeAPIKey &amp;&amp; cred.Type != TypeOAuth2 &amp;&amp; cred.Type != TypeBasicAuth &amp;&amp; cred.Type != TypeCustom </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentialType
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">if cred.ID == "" </span><span class="cov0" title="0">{
                cred.ID = uuid.NewString()
        }</span>

        <span class="cov0" title="0">now := time.Now()

        // Set status if not provided
        if cred.Status == "" </span><span class="cov0" title="0">{
                cred.Status = StatusActive
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO credentials (
                        id, tenant_id, name, type, description, status,
                        encrypted_dek, ciphertext, nonce, auth_tag, kms_key_id,
                        metadata, created_by, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6,
                        $7, $8, $9, $10, $11,
                        $12, $13, $14, $15
                ) RETURNING *
        `

        var created Credential
        err := r.db.QueryRowxContext(
                ctx, query,
                cred.ID, tenantID, cred.Name, cred.Type, cred.Description, cred.Status,
                cred.EncryptedDEK, cred.Ciphertext, cred.Nonce, cred.AuthTag, cred.KMSKeyID,
                cred.Metadata, createdBy, now, now,
        ).StructScan(&amp;created)

        if err != nil </span><span class="cov0" title="0">{
                // Check for duplicate name constraint
                if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                        if pqErr.Code == "23505" </span><span class="cov0" title="0">{ // unique_violation
                                return nil, ErrDuplicateCredential
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to create credential: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;created, nil</span>
}

// GetByID retrieves a credential by ID (tenant-scoped)
func (r *Repository) GetByID(ctx context.Context, tenantID, id string) (*Credential, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentialID
        }</span>

        <span class="cov0" title="0">query := `SELECT * FROM credentials WHERE id = $1 AND tenant_id = $2`

        var cred Credential
        err := r.db.GetContext(ctx, &amp;cred, query, id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get credential: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;cred, nil</span>
}

// GetByName retrieves a credential by name (tenant-scoped)
func (r *Repository) GetByName(ctx context.Context, tenantID, name string) (*Credential, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if name == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentialName
        }</span>

        <span class="cov0" title="0">query := `SELECT * FROM credentials WHERE name = $1 AND tenant_id = $2`

        var cred Credential
        err := r.db.GetContext(ctx, &amp;cred, query, name, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get credential: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;cred, nil</span>
}

// Update updates a credential
func (r *Repository) Update(ctx context.Context, tenantID, id string, input *UpdateCredentialInput) (*Credential, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentialID
        }</span>

        <span class="cov0" title="0">if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("update input cannot be nil")
        }</span>

        // First check if credential exists
        <span class="cov0" title="0">_, err := r.GetByID(ctx, tenantID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build dynamic update query
        <span class="cov0" title="0">updates := []string{}
        args := []interface{}{}
        argIndex := 1

        if input.Name != nil &amp;&amp; *input.Name != "" </span><span class="cov0" title="0">{
                updates = append(updates, fmt.Sprintf("name = $%d", argIndex))
                args = append(args, *input.Name)
                argIndex++
        }</span>

        <span class="cov0" title="0">if input.Description != nil </span><span class="cov0" title="0">{
                updates = append(updates, fmt.Sprintf("description = $%d", argIndex))
                args = append(args, *input.Description)
                argIndex++
        }</span>

        <span class="cov0" title="0">if input.Status != nil </span><span class="cov0" title="0">{
                updates = append(updates, fmt.Sprintf("status = $%d", argIndex))
                args = append(args, *input.Status)
                argIndex++
        }</span>

        <span class="cov0" title="0">if input.Metadata != nil </span><span class="cov0" title="0">{
                metadataJSON, err := json.Marshal(input.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal metadata: %w", err)
                }</span>
                <span class="cov0" title="0">updates = append(updates, fmt.Sprintf("metadata = $%d", argIndex))
                args = append(args, metadataJSON)
                argIndex++</span>
        }

        // Always update updated_at
        <span class="cov0" title="0">updates = append(updates, fmt.Sprintf("updated_at = $%d", argIndex))
        args = append(args, time.Now())
        argIndex++

        if len(updates) == 1 </span><span class="cov0" title="0">{ // Only updated_at was set
                return nil, errors.New("no fields to update")
        }</span>

        // Add WHERE clause parameters
        <span class="cov0" title="0">args = append(args, id, tenantID)

        query := fmt.Sprintf(`
                UPDATE credentials
                SET %s
                WHERE id = $%d AND tenant_id = $%d
                RETURNING *
        `, joinUpdates(updates), argIndex, argIndex+1)

        var updated Credential
        err = r.db.QueryRowxContext(ctx, query, args...).StructScan(&amp;updated)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update credential: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;updated, nil</span>
}

// Delete deletes a credential
func (r *Repository) Delete(ctx context.Context, tenantID, id string) error <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return ErrInvalidCredentialID
        }</span>

        <span class="cov0" title="0">query := `DELETE FROM credentials WHERE id = $1 AND tenant_id = $2`

        result, err := r.db.ExecContext(ctx, query, id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete credential: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// List retrieves all credentials for a tenant with optional filtering
func (r *Repository) List(ctx context.Context, tenantID string, filter CredentialListFilter) ([]*Credential, error) <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">query := `SELECT * FROM credentials WHERE tenant_id = $1`
        args := []interface{}{tenantID}
        argIndex := 2

        // Apply type filter
        if filter.Type != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND type = $%d", argIndex)
                args = append(args, filter.Type)
                argIndex++
        }</span>

        // Apply status filter
        <span class="cov0" title="0">if filter.Status != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND status = $%d", argIndex)
                args = append(args, filter.Status)
                argIndex++
        }</span>

        // Apply search filter (searches in name and description)
        <span class="cov0" title="0">if filter.Search != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND (name ILIKE $%d OR description ILIKE $%d)", argIndex, argIndex)
                searchPattern := "%" + filter.Search + "%"
                args = append(args, searchPattern)
                argIndex++
        }</span>

        <span class="cov0" title="0">query += " ORDER BY created_at DESC"

        var credentials []*Credential
        err := r.db.SelectContext(ctx, &amp;credentials, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list credentials: %w", err)
        }</span>

        <span class="cov0" title="0">if credentials == nil </span><span class="cov0" title="0">{
                credentials = []*Credential{}
        }</span>

        <span class="cov0" title="0">return credentials, nil</span>
}

// UpdateLastUsedAt updates the last_used_at timestamp
func (r *Repository) UpdateLastUsedAt(ctx context.Context, tenantID, id string) error <span class="cov0" title="0">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                return ErrInvalidCredentialID
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE credentials
                SET last_used_at = $1
                WHERE id = $2 AND tenant_id = $3
        `

        result, err := r.db.ExecContext(ctx, query, time.Now(), id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update last_used_at: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogAccess logs a credential access event
func (r *Repository) LogAccess(ctx context.Context, log *AccessLog) error <span class="cov0" title="0">{
        if log == nil </span><span class="cov0" title="0">{
                return errors.New("access log cannot be nil")
        }</span>

        <span class="cov0" title="0">if log.CredentialID == "" </span><span class="cov0" title="0">{
                return ErrInvalidCredentialID
        }</span>

        <span class="cov0" title="0">if log.TenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>

        <span class="cov0" title="0">if log.AccessedBy == "" </span><span class="cov0" title="0">{
                return errors.New("accessed_by cannot be empty")
        }</span>

        <span class="cov0" title="0">if log.ID == "" </span><span class="cov0" title="0">{
                log.ID = uuid.NewString()
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO credential_access_log (
                        id, credential_id, tenant_id, accessed_by, access_type,
                        accessed_at, ip_address, user_agent, success, error_message
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
                )
        `

        now := time.Now()

        _, err := r.db.ExecContext(
                ctx, query,
                log.ID, log.CredentialID, log.TenantID, log.AccessedBy, log.AccessType,
                now, log.IPAddress, log.UserAgent, log.Success, log.ErrorMessage,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to log access: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// joinUpdates joins SQL SET clauses with commas
func joinUpdates(updates []string) string <span class="cov0" title="0">{
        result := ""
        for i, update := range updates </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += ", "
                }</span>
                <span class="cov0" title="0">result += update</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package credential

import (
        "context"
        "fmt"
        "time"
)

// ServiceRepositoryInterface defines the repository operations needed by the service
type ServiceRepositoryInterface interface {
        GetByID(ctx context.Context, tenantID, id string) (*Credential, error)
        UpdateLastUsedAt(ctx context.Context, tenantID, id string) error
        LogAccess(ctx context.Context, log *AccessLog) error
}

// ServiceImpl implements the Service interface
type ServiceImpl struct {
        repo       ServiceRepositoryInterface
        encryption EncryptionServiceInterface
}

// NewServiceImpl creates a new credential service implementation
func NewServiceImpl(repo ServiceRepositoryInterface, encryption EncryptionServiceInterface) Service <span class="cov8" title="1">{
        return &amp;ServiceImpl{
                repo:       repo,
                encryption: encryption,
        }
}</span>

// GetValue retrieves and decrypts a credential value
func (s *ServiceImpl) GetValue(ctx context.Context, tenantID, credentialID, userID string) (*DecryptedValue, error) <span class="cov8" title="1">{
        // Retrieve credential from repository
        cred, err := s.repo.GetByID(ctx, tenantID, credentialID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve credential: %w", err)
        }</span>

        // Check if credential has encrypted data
        <span class="cov8" title="1">if len(cred.Ciphertext) == 0 || len(cred.EncryptedDEK) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no credential value found for credential %s", credentialID)
        }</span>

        // Prepare encrypted secret for decryption
        <span class="cov8" title="1">encryptedSecret := &amp;EncryptedSecret{
                EncryptedDEK: cred.EncryptedDEK,
                Ciphertext:   cred.Ciphertext,
                Nonce:        cred.Nonce,
                AuthTag:      cred.AuthTag,
                KMSKeyID:     cred.KMSKeyID,
        }

        // Decrypt the credential value
        decryptedData, err := s.encryption.Decrypt(ctx, encryptedSecret.Ciphertext, encryptedSecret.EncryptedDEK)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decrypt credential: %w", err)
        }</span>

        // Update last used time (synchronous for now - could be made async)
        <span class="cov8" title="1">if err := s.repo.UpdateLastUsedAt(ctx, tenantID, credentialID); err != nil </span>{<span class="cov0" title="0">
                // Log error but don't fail the request
                // In production, this should use a proper logger
        }</span>

        // Log access
        <span class="cov8" title="1">accessLog := &amp;AccessLog{
                CredentialID: credentialID,
                TenantID:     tenantID,
                AccessedBy:   userID,
                AccessType:   AccessTypeRead,
                AccessedAt:   time.Now().UTC(),
                Success:      true,
        }
        if err := s.repo.LogAccess(ctx, accessLog); err != nil </span>{<span class="cov0" title="0">
                // Log error but don't fail the request
                // In production, this should use a proper logger
        }</span>

        // Build and return decrypted value
        <span class="cov8" title="1">return &amp;DecryptedValue{
                Version:   1, // Version tracking can be added later
                Value:     decryptedData.Value,
                CreatedAt: cred.CreatedAt,
        }, nil</span>
}

// Create creates a new credential with encrypted value
func (s *ServiceImpl) Create(ctx context.Context, tenantID, userID string, input CreateCredentialInput) (*Credential, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// List returns credentials for a tenant (metadata only, no values)
func (s *ServiceImpl) List(ctx context.Context, tenantID string, filter CredentialListFilter, limit, offset int) ([]*Credential, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// GetByID returns credential metadata by ID
func (s *ServiceImpl) GetByID(ctx context.Context, tenantID, credentialID string) (*Credential, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// Update updates credential metadata (not the value)
func (s *ServiceImpl) Update(ctx context.Context, tenantID, credentialID, userID string, input UpdateCredentialInput) (*Credential, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// Delete soft-deletes a credential
func (s *ServiceImpl) Delete(ctx context.Context, tenantID, credentialID, userID string) error <span class="cov0" title="0">{
        return fmt.Errorf("not implemented")
}</span>

// Rotate creates a new version of the credential value
func (s *ServiceImpl) Rotate(ctx context.Context, tenantID, credentialID, userID string, input RotateCredentialInput) (*Credential, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// ListVersions returns all versions of a credential
func (s *ServiceImpl) ListVersions(ctx context.Context, tenantID, credentialID string) ([]*CredentialValue, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>

// GetAccessLog returns access log entries for a credential
func (s *ServiceImpl) GetAccessLog(ctx context.Context, tenantID, credentialID string, limit, offset int) ([]*AccessLog, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package database

import (
        "context"
        "database/sql/driver"
        "fmt"
        "strings"

        "github.com/jmoiron/sqlx"
)

// TenantContextKey is the context key for storing tenant ID
type TenantContextKey string

const (
        // ContextKeyTenantID is the key used to store tenant ID in context
        ContextKeyTenantID TenantContextKey = "tenant_id"
)

// TenantDB wraps sqlx.DB with tenant-aware hooks
type TenantDB struct {
        *sqlx.DB
}

// NewTenantDB creates a new tenant-aware database wrapper
func NewTenantDB(db *sqlx.DB) *TenantDB <span class="cov0" title="0">{
        return &amp;TenantDB{DB: db}
}</span>

// ExecContext executes a query with automatic tenant_id injection
func (db *TenantDB) ExecContext(ctx context.Context, query string, args ...interface{}) (driver.Result, error) <span class="cov0" title="0">{
        tenantID := GetTenantIDFromContext(ctx)
        if tenantID != "" &amp;&amp; shouldInjectTenantID(query) </span><span class="cov0" title="0">{
                // Set tenant context in session before executing query
                _, err := db.DB.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set tenant context: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return db.DB.ExecContext(ctx, query, args...)</span>
}

// QueryContext executes a query with automatic tenant_id injection
func (db *TenantDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) <span class="cov0" title="0">{
        tenantID := GetTenantIDFromContext(ctx)
        if tenantID != "" &amp;&amp; shouldInjectTenantID(query) </span><span class="cov0" title="0">{
                // Set tenant context in session before executing query
                _, err := db.DB.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set tenant context: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return db.DB.QueryxContext(ctx, query, args...)</span>
}

// QueryRowContext executes a query returning a single row with automatic tenant_id injection
func (db *TenantDB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row <span class="cov0" title="0">{
        tenantID := GetTenantIDFromContext(ctx)
        if tenantID != "" &amp;&amp; shouldInjectTenantID(query) </span><span class="cov0" title="0">{
                // Set tenant context in session before executing query
                _, err := db.DB.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        // Return a row with the error
                        return db.DB.QueryRowxContext(ctx, "SELECT $1::text", err.Error())
                }</span>
        }
        <span class="cov0" title="0">return db.DB.QueryRowxContext(ctx, query, args...)</span>
}

// GetContext is a helper that uses QueryRowContext
func (db *TenantDB) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov0" title="0">{
        tenantID := GetTenantIDFromContext(ctx)
        if tenantID != "" &amp;&amp; shouldInjectTenantID(query) </span><span class="cov0" title="0">{
                // Set tenant context in session before executing query
                _, err := db.DB.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set tenant context: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return db.DB.GetContext(ctx, dest, query, args...)</span>
}

// SelectContext is a helper that uses QueryContext
func (db *TenantDB) SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov0" title="0">{
        tenantID := GetTenantIDFromContext(ctx)
        if tenantID != "" &amp;&amp; shouldInjectTenantID(query) </span><span class="cov0" title="0">{
                // Set tenant context in session before executing query
                _, err := db.DB.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set tenant context: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return db.DB.SelectContext(ctx, dest, query, args...)</span>
}

// BeginTxx begins a transaction with tenant context
func (db *TenantDB) BeginTxx(ctx context.Context, opts *driver.TxOptions) (*sqlx.Tx, error) <span class="cov0" title="0">{
        tx, err := db.DB.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set tenant context in transaction
        <span class="cov0" title="0">tenantID := GetTenantIDFromContext(ctx)
        if tenantID != "" </span><span class="cov0" title="0">{
                _, err = tx.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return nil, fmt.Errorf("failed to set tenant context in transaction: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return tx, nil</span>
}

// TenantScoped returns a new context with the tenant ID set
func TenantScoped(ctx context.Context, tenantID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, ContextKeyTenantID, tenantID)
}</span>

// GetTenantIDFromContext extracts the tenant ID from the context
func GetTenantIDFromContext(ctx context.Context) string <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">tenantID, _ := ctx.Value(ContextKeyTenantID).(string)
        return tenantID</span>
}

// shouldInjectTenantID checks if the query needs tenant_id injection
// This is a simple heuristic - skip admin queries and DDL statements
func shouldInjectTenantID(query string) bool <span class="cov0" title="0">{
        queryLower := strings.ToLower(strings.TrimSpace(query))

        // Skip if querying tenants table itself (admin operations)
        if strings.Contains(queryLower, "from tenants") || strings.Contains(queryLower, "into tenants") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Skip DDL statements
        <span class="cov0" title="0">if strings.HasPrefix(queryLower, "create") ||
                strings.HasPrefix(queryLower, "alter") ||
                strings.HasPrefix(queryLower, "drop") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Skip if already setting tenant context
        <span class="cov0" title="0">if strings.Contains(queryLower, "app.current_tenant_id") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Skip SHOW/SET statements
        <span class="cov0" title="0">if strings.HasPrefix(queryLower, "show") || strings.HasPrefix(queryLower, "set") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// WithTenantID is a helper to wrap a database operation with tenant context
func WithTenantID(ctx context.Context, tenantID string, fn func(context.Context) error) error <span class="cov0" title="0">{
        tenantCtx := TenantScoped(ctx, tenantID)
        return fn(tenantCtx)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package executor

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/gorax/gorax/internal/executor/actions"
        "github.com/gorax/gorax/internal/workflow"
)

// executeHTTPAction executes an HTTP request action with circuit breaker
func (e *Executor) executeHTTPAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov0" title="0">{
        // Extract config from node data
        configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for HTTP action")
        }</span>

        // Parse node config
        <span class="cov0" title="0">var config actions.HTTPActionConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTTP action config: %w", err)
        }</span>

        // Build execution context for interpolation
        <span class="cov0" title="0">execContext := buildInterpolationContext(execCtx)

        // Get or create circuit breaker for this URL/host
        circuitBreakerName := fmt.Sprintf("http:%s", config.URL)
        circuitBreaker := e.circuitBreakers.GetOrCreate(circuitBreakerName)

        // Execute HTTP request through circuit breaker
        result, err := circuitBreaker.ExecuteWithResult(ctx, func(reqCtx context.Context) (interface{}, error) </span><span class="cov0" title="0">{
                return actions.ExecuteHTTP(reqCtx, config, execContext)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// executeTransformAction executes a data transformation action
func (e *Executor) executeTransformAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov0" title="0">{
        // Extract config from node data
        configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for transform action")
        }</span>

        // Parse node config
        <span class="cov0" title="0">var config actions.TransformActionConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse transform action config: %w", err)
        }</span>

        // Build execution context for interpolation
        <span class="cov0" title="0">context := buildInterpolationContext(execCtx)

        // Execute transformation
        result, err := actions.ExecuteTransform(ctx, config, context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// executeFormulaAction executes a formula evaluation action
func (e *Executor) executeFormulaAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov0" title="0">{
        // Extract config from node data
        configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for formula action")
        }</span>

        // Create formula action
        <span class="cov0" title="0">action := &amp;actions.FormulaAction{}

        // Build execution context
        context := buildInterpolationContext(execCtx)

        // Create action input
        input := actions.NewActionInput(configData, context)

        // Execute formula action
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.Data, nil</span>
}

// executeCodeAction executes a custom code/script action
func (e *Executor) executeCodeAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov0" title="0">{
        // Extract config from node data
        configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for code action")
        }</span>

        // Create script action
        <span class="cov0" title="0">action := &amp;actions.ScriptAction{}

        // Build execution context
        context := buildInterpolationContext(execCtx)

        // Create action input
        input := actions.NewActionInput(configData, context)

        // Execute script action
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.Data, nil</span>
}

// buildInterpolationContext builds the context map for template interpolation
func buildInterpolationContext(execCtx *ExecutionContext) map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "trigger": execCtx.TriggerData,
                "steps":   execCtx.StepOutputs,
                "env": map[string]interface{}{
                        "tenant_id":    execCtx.TenantID,
                        "execution_id": execCtx.ExecutionID,
                        "workflow_id":  execCtx.WorkflowID,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package actions

import (
        "context"
)

// Action represents a workflow action that can be executed
type Action interface {
        // Execute runs the action with the given context and input
        // Returns the action output or an error if execution fails
        Execute(ctx context.Context, input *ActionInput) (*ActionOutput, error)
}

// ActionInput represents the input data for an action execution
type ActionInput struct {
        // Config contains the action-specific configuration
        Config interface{}
        // Context contains data from previous steps and trigger
        Context map[string]interface{}
}

// ActionOutput represents the result of an action execution
type ActionOutput struct {
        // Data contains the output data from the action
        Data interface{}
        // Metadata contains additional information about the execution
        Metadata map[string]interface{}
}

// ActionFactory is a function that creates an action instance
type ActionFactory func() Action

// NewActionInput creates a new ActionInput
func NewActionInput(config interface{}, context map[string]interface{}) *ActionInput <span class="cov8" title="1">{
        if context == nil </span><span class="cov8" title="1">{
                context = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">return &amp;ActionInput{
                Config:  config,
                Context: context,
        }</span>
}

// NewActionOutput creates a new ActionOutput
func NewActionOutput(data interface{}) *ActionOutput <span class="cov8" title="1">{
        return &amp;ActionOutput{
                Data:     data,
                Metadata: make(map[string]interface{}),
        }
}</span>

// WithMetadata adds metadata to the output
func (o *ActionOutput) WithMetadata(key string, value interface{}) *ActionOutput <span class="cov8" title="1">{
        o.Metadata[key] = value
        return o
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package actions

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/gorax/gorax/internal/workflow/formula"
)

// FormulaAction implements the Action interface for formula evaluation
type FormulaAction struct {
        evaluator *formula.Evaluator
}

// FormulaActionConfig represents the configuration for a formula action
type FormulaActionConfig struct {
        // Expression is the formula expression to evaluate
        Expression string `json:"expression"`
        // OutputVariable is the name to store the result (optional, defaults to "result")
        OutputVariable string `json:"output_variable,omitempty"`
}

// Execute implements the Action interface
func (a *FormulaAction) Execute(ctx context.Context, input *ActionInput) (*ActionOutput, error) <span class="cov8" title="1">{
        // Initialize evaluator if not already done
        if a.evaluator == nil </span><span class="cov8" title="1">{
                a.evaluator = formula.NewEvaluator()
        }</span>

        // Parse config
        <span class="cov8" title="1">configBytes, err := json.Marshal(input.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">var config FormulaActionConfig
        if err := json.Unmarshal(configBytes, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse formula action config: %w", err)
        }</span>

        // Validate expression
        <span class="cov8" title="1">if config.Expression == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expression cannot be empty")
        }</span>

        // Evaluate the formula with execution context
        <span class="cov8" title="1">result, err := a.evaluator.Evaluate(config.Expression, input.Context)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to evaluate formula: %w", err)
        }</span>

        // Create output
        <span class="cov8" title="1">output := NewActionOutput(result)

        // Add metadata
        output.WithMetadata("expression", config.Expression)
        output.WithMetadata("output_variable", config.OutputVariable)

        return output, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package actions

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
)

// HTTPAction implements the Action interface for HTTP requests
type HTTPAction struct{}

// HTTPActionConfig represents the configuration for an HTTP action
type HTTPActionConfig struct {
        Method   string            `json:"method"`
        URL      string            `json:"url"`
        Headers  map[string]string `json:"headers,omitempty"`
        Body     json.RawMessage   `json:"body,omitempty"`
        Timeout  int               `json:"timeout,omitempty"`  // seconds
        Auth     *HTTPAuth         `json:"auth,omitempty"`     // authentication config
        FollowRedirects bool       `json:"follow_redirects,omitempty"` // default: true
}

// HTTPAuth represents HTTP authentication configuration
type HTTPAuth struct {
        Type     string `json:"type"`      // basic, bearer, api_key
        Username string `json:"username,omitempty"` // for basic auth
        Password string `json:"password,omitempty"` // for basic auth
        Token    string `json:"token,omitempty"`    // for bearer auth
        APIKey   string `json:"api_key,omitempty"`  // for api_key auth
        Header   string `json:"header,omitempty"`   // header name for api_key
}

// HTTPActionResult represents the result of an HTTP action
type HTTPActionResult struct {
        StatusCode int               `json:"status_code"`
        Headers    map[string]string `json:"headers"`
        Body       interface{}       `json:"body"`
}

// Execute implements the Action interface
func (a *HTTPAction) Execute(ctx context.Context, input *ActionInput) (*ActionOutput, error) <span class="cov8" title="1">{
        // Parse config
        configBytes, err := json.Marshal(input.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">var config HTTPActionConfig
        if err := json.Unmarshal(configBytes, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTTP action config: %w", err)
        }</span>

        // Execute HTTP request
        <span class="cov8" title="1">result, err := a.executeHTTP(ctx, config, input.Context)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return NewActionOutput(result), nil</span>
}

// executeHTTP executes an HTTP request
func (a *HTTPAction) executeHTTP(ctx context.Context, config HTTPActionConfig, execContext map[string]interface{}) (*HTTPActionResult, error) <span class="cov8" title="1">{
        // Validate method
        method := strings.ToUpper(config.Method)
        if method == "" </span><span class="cov0" title="0">{
                method = "GET"
        }</span>
        <span class="cov8" title="1">if !isValidHTTPMethod(method) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid HTTP method: %s", method)
        }</span>

        // Default timeout
        <span class="cov8" title="1">timeout := 30 * time.Second
        if config.Timeout &gt; 0 </span><span class="cov8" title="1">{
                timeout = time.Duration(config.Timeout) * time.Second
        }</span>

        // Create context with timeout
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Configure HTTP client
        client := &amp;http.Client{
                Timeout: timeout,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        if !config.FollowRedirects &amp;&amp; len(via) &gt; 0 </span><span class="cov0" title="0">{
                                return http.ErrUseLastResponse
                        }</span>
                        <span class="cov0" title="0">if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                                return fmt.Errorf("too many redirects")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }

        // Interpolate URL
        <span class="cov8" title="1">url := InterpolateString(config.URL, execContext)
        if url == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("URL is required")
        }</span>

        // Prepare request body
        <span class="cov8" title="1">var bodyReader io.Reader
        if config.Body != nil &amp;&amp; len(config.Body) &gt; 0 </span><span class="cov8" title="1">{
                interpolatedBody := InterpolateJSON(config.Body, execContext)
                bodyBytes, err := json.Marshal(interpolatedBody)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov8" title="1">bodyReader = bytes.NewReader(bodyBytes)</span>
        }

        // Create request
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(timeoutCtx, method, url, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set default content type for requests with body
        <span class="cov8" title="1">if bodyReader != nil </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        // Set custom headers
        <span class="cov8" title="1">for key, value := range config.Headers </span><span class="cov8" title="1">{
                req.Header.Set(key, InterpolateString(value, execContext))
        }</span>

        // Apply authentication
        <span class="cov8" title="1">if err := a.applyAuth(req, config.Auth, execContext); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply authentication: %w", err)
        }</span>

        // Execute request
        <span class="cov8" title="1">resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read response body
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Parse response body
        <span class="cov8" title="1">var parsedBody interface{}
        contentType := resp.Header.Get("Content-Type")
        if strings.Contains(contentType, "application/json") </span><span class="cov8" title="1">{
                if err := json.Unmarshal(respBody, &amp;parsedBody); err != nil </span><span class="cov0" title="0">{
                        // If JSON parsing fails, use raw string
                        parsedBody = string(respBody)
                }</span>
        } else<span class="cov8" title="1"> {
                parsedBody = string(respBody)
        }</span>

        // Build response headers map
        <span class="cov8" title="1">respHeaders := make(map[string]string)
        for key := range resp.Header </span><span class="cov8" title="1">{
                respHeaders[key] = resp.Header.Get(key)
        }</span>

        <span class="cov8" title="1">return &amp;HTTPActionResult{
                StatusCode: resp.StatusCode,
                Headers:    respHeaders,
                Body:       parsedBody,
        }, nil</span>
}

// applyAuth applies authentication to the request
func (a *HTTPAction) applyAuth(req *http.Request, auth *HTTPAuth, context map[string]interface{}) error <span class="cov8" title="1">{
        if auth == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch strings.ToLower(auth.Type) </span>{
        case "basic":<span class="cov8" title="1">
                username := InterpolateString(auth.Username, context)
                password := InterpolateString(auth.Password, context)
                req.SetBasicAuth(username, password)</span>

        case "bearer":<span class="cov8" title="1">
                token := InterpolateString(auth.Token, context)
                if token == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("bearer token is required")
                }</span>
                <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+token)</span>

        case "api_key":<span class="cov8" title="1">
                apiKey := InterpolateString(auth.APIKey, context)
                if apiKey == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("API key is required")
                }</span>
                <span class="cov8" title="1">header := auth.Header
                if header == "" </span><span class="cov8" title="1">{
                        header = "X-API-Key"
                }</span>
                <span class="cov8" title="1">req.Header.Set(header, apiKey)</span>

        case "":<span class="cov0" title="0">
                // No auth
                return nil</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported auth type: %s", auth.Type)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isValidHTTPMethod checks if the method is valid
func isValidHTTPMethod(method string) bool <span class="cov8" title="1">{
        validMethods := []string{"GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"}
        for _, m := range validMethods </span><span class="cov8" title="1">{
                if method == m </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Legacy function for backward compatibility
func ExecuteHTTP(ctx context.Context, config HTTPActionConfig, context map[string]interface{}) (*HTTPActionResult, error) <span class="cov8" title="1">{
        action := &amp;HTTPAction{}
        input := NewActionInput(config, context)
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result, ok := output.Data.(*HTTPActionResult)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected output type")
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package actions

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

var (
        // interpolationRegex matches {{expression}} patterns
        interpolationRegex = regexp.MustCompile(`\{\{([^}]+)\}\}`)
        // arrayIndexRegex matches array[index] patterns
        arrayIndexRegex = regexp.MustCompile(`^(.+)\[(\d+)\]$`)
)

// InterpolateString replaces {{path.to.value}} with actual values from context
// Supports JSONPath-like syntax: steps.http-1.body.users[0].name
func InterpolateString(template string, context map[string]interface{}) string <span class="cov8" title="1">{
        return interpolationRegex.ReplaceAllStringFunc(template, func(match string) string </span><span class="cov8" title="1">{
                // Extract expression from {{...}}
                expression := strings.TrimSpace(match[2 : len(match)-2])

                value, err := GetValueByPath(context, expression)
                if err != nil </span><span class="cov8" title="1">{
                        // Return original if path not found
                        return match
                }</span>

                // Convert value to string
                <span class="cov8" title="1">return toString(value)</span>
        })
}

// InterpolateJSON recursively interpolates values in a JSON structure
func InterpolateJSON(data json.RawMessage, context map[string]interface{}) interface{} <span class="cov8" title="1">{
        var parsed interface{}
        if err := json.Unmarshal(data, &amp;parsed); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return interpolateValue(parsed, context)</span>
}

// interpolateValue recursively interpolates a value
func interpolateValue(value interface{}, context map[string]interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return InterpolateString(v, context)</span>
        case map[string]interface{}:<span class="cov8" title="1">
                result := make(map[string]interface{})
                for key, val := range v </span><span class="cov8" title="1">{
                        result[key] = interpolateValue(val, context)
                }</span>
                <span class="cov8" title="1">return result</span>
        case []interface{}:<span class="cov8" title="1">
                result := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov8" title="1">{
                        result[i] = interpolateValue(val, context)
                }</span>
                <span class="cov8" title="1">return result</span>
        default:<span class="cov0" title="0">
                return v</span>
        }
}

// GetValueByPath retrieves a value from a nested map using dot notation
// Supports array indexing: "steps.node1.body.users[0].name"
func GetValueByPath(data map[string]interface{}, path string) (interface{}, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return data, nil
        }</span>

        <span class="cov8" title="1">current := interface{}(data)
        parts := splitPath(path)

        for i, part := range parts </span><span class="cov8" title="1">{
                // Check for array indexing
                if matches := arrayIndexRegex.FindStringSubmatch(part); matches != nil </span><span class="cov8" title="1">{
                        // Handle array access like "users[0]"
                        arrayKey := matches[1]
                        index, err := strconv.Atoi(matches[2])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid array index '%s'", matches[2])
                        }</span>

                        // Get the array first
                        <span class="cov8" title="1">switch v := current.(type) </span>{
                        case map[string]interface{}:<span class="cov8" title="1">
                                current = v[arrayKey]</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("cannot access key '%s' on non-object type", arrayKey)</span>
                        }

                        // Then access the index
                        <span class="cov8" title="1">switch arr := current.(type) </span>{
                        case []interface{}:<span class="cov8" title="1">
                                if index &lt; 0 || index &gt;= len(arr) </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("array index %d out of bounds", index)
                                }</span>
                                <span class="cov8" title="1">current = arr[index]</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("cannot index non-array type at '%s'", arrayKey)</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // Regular object property access
                <span class="cov8" title="1">switch v := current.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        var exists bool
                        current, exists = v[part]
                        if !exists </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("key '%s' not found at path position %d", part, i)
                        }</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("cannot traverse into non-object type at '%s'", part)</span>
                }
        }

        <span class="cov8" title="1">return current, nil</span>
}

// splitPath splits a path string by dots, handling escaped dots
func splitPath(path string) []string <span class="cov8" title="1">{
        var parts []string
        var current strings.Builder
        escaped := false

        for i := 0; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                char := path[i]

                if char == '\\' &amp;&amp; i+1 &lt; len(path) &amp;&amp; path[i+1] == '.' </span><span class="cov8" title="1">{
                        // Escaped dot
                        current.WriteByte('.')
                        i++ // Skip next char
                        escaped = true
                        continue</span>
                }

                <span class="cov8" title="1">if char == '.' &amp;&amp; !escaped </span><span class="cov8" title="1">{
                        if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                                parts = append(parts, current.String())
                                current.Reset()
                        }</span>
                } else<span class="cov8" title="1"> {
                        current.WriteByte(char)
                }</span>
                <span class="cov8" title="1">escaped = false</span>
        }

        <span class="cov8" title="1">if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                parts = append(parts, current.String())
        }</span>

        <span class="cov8" title="1">return parts</span>
}

// toString converts a value to its string representation
func toString(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case float32, float64:<span class="cov8" title="1">
                return fmt.Sprintf("%v", v)</span>
        case bool:<span class="cov8" title="1">
                return fmt.Sprintf("%t", v)</span>
        case nil:<span class="cov8" title="1">
                return ""</span>
        default:<span class="cov8" title="1">
                // For complex types, marshal to JSON
                if bytes, err := json.Marshal(v); err == nil </span><span class="cov8" title="1">{
                        return string(bytes)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%v", v)</span>
        }
}

// DeepCopy creates a deep copy of a value
func DeepCopy(src interface{}) (interface{}, error) <span class="cov8" title="1">{
        if src == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Use JSON marshaling for deep copy
        <span class="cov8" title="1">data, err := json.Marshal(src)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var dst interface{}
        if err := json.Unmarshal(data, &amp;dst); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return dst, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package actions

import (
        "fmt"
        "sync"
)

// Registry manages action type registration and creation
type Registry struct {
        factories map[string]ActionFactory
        mu        sync.RWMutex
}

// NewRegistry creates a new action registry
func NewRegistry() *Registry <span class="cov8" title="1">{
        r := &amp;Registry{
                factories: make(map[string]ActionFactory),
        }

        // Register built-in actions
        r.Register("action:http", func() Action </span><span class="cov8" title="1">{ return &amp;HTTPAction{} }</span>)
        <span class="cov8" title="1">r.Register("action:transform", func() Action </span><span class="cov8" title="1">{ return &amp;TransformAction{} }</span>)
        <span class="cov8" title="1">r.Register("action:formula", func() Action </span><span class="cov0" title="0">{ return &amp;FormulaAction{} }</span>)
        <span class="cov8" title="1">r.Register("action:code", func() Action </span><span class="cov0" title="0">{ return &amp;ScriptAction{} }</span>)

        <span class="cov8" title="1">return r</span>
}

// Register registers an action factory for a given action type
func (r *Registry) Register(actionType string, factory ActionFactory) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.factories[actionType] = factory
}</span>

// Create creates a new action instance for the given action type
func (r *Registry) Create(actionType string) (Action, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        factory, exists := r.factories[actionType]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unknown action type: %s", actionType)
        }</span>

        <span class="cov8" title="1">return factory(), nil</span>
}

// IsRegistered checks if an action type is registered
func (r *Registry) IsRegistered(actionType string) bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        _, exists := r.factories[actionType]
        return exists
}</span>

// RegisteredTypes returns a list of all registered action types
func (r *Registry) RegisteredTypes() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        types := make([]string, 0, len(r.factories))
        for actionType := range r.factories </span><span class="cov8" title="1">{
                types = append(types, actionType)
        }</span>
        <span class="cov8" title="1">return types</span>
}

// DefaultRegistry is the global action registry
var DefaultRegistry = NewRegistry()
</pre>
		
		<pre class="file" id="file37" style="display: none">package actions

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/dop251/goja"
)

// ScriptAction implements the Action interface for sandboxed JavaScript execution
//
// Security Considerations:
// - Uses goja runtime which is completely sandboxed (no file system, network, or goroutines)
// - Enforces execution timeout to prevent infinite loops
// - Memory limits can be configured (future enhancement with goja runtime options)
// - No access to Go stdlib or external modules unless explicitly provided
// - Scripts run in isolated VM instances (no shared state between executions)
type ScriptAction struct{}

// ScriptActionConfig represents the configuration for a script action
type ScriptActionConfig struct {
        Script      string `json:"script"`                 // JavaScript code to execute
        Timeout     int    `json:"timeout,omitempty"`      // Max execution time in seconds (default: 30)
        MemoryLimit int    `json:"memory_limit,omitempty"` // Max memory in MB (future enhancement)
}

// ScriptActionResult represents the result of a script execution
type ScriptActionResult struct {
        Result interface{} `json:"result"` // The value returned by the script
}

const (
        defaultScriptTimeout = 30 // seconds
)

// Execute implements the Action interface
func (a *ScriptAction) Execute(ctx context.Context, input *ActionInput) (*ActionOutput, error) <span class="cov8" title="1">{
        startTime := time.Now()

        // Parse config
        configBytes, err := json.Marshal(input.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">var config ScriptActionConfig
        if err := json.Unmarshal(configBytes, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse script action config: %w", err)
        }</span>

        // Validate script
        <span class="cov8" title="1">if config.Script == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("script is required")
        }</span>

        // Determine timeout
        <span class="cov8" title="1">timeout := time.Duration(config.Timeout) * time.Second
        if timeout &lt;= 0 </span><span class="cov8" title="1">{
                timeout = defaultScriptTimeout * time.Second
        }</span>

        // Execute script with timeout
        <span class="cov8" title="1">result, err := a.executeScript(ctx, config.Script, input.Context, timeout)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Calculate execution time
        <span class="cov8" title="1">executionTime := time.Since(startTime).Milliseconds()

        // Create output
        output := NewActionOutput(&amp;ScriptActionResult{
                Result: result,
        })
        output.WithMetadata("execution_time_ms", executionTime)

        return output, nil</span>
}

// executeScript executes JavaScript code in a sandboxed environment
func (a *ScriptAction) executeScript(ctx context.Context, script string, execContext map[string]interface{}, timeout time.Duration) (interface{}, error) <span class="cov8" title="1">{
        // Create new goja runtime (isolated sandbox)
        vm := goja.New()

        // Set up timeout mechanism
        timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Channel to receive result or error
        type result struct {
                value interface{}
                err   error
        }
        resultChan := make(chan result, 1)

        // Execute script in goroutine to support timeout
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                resultChan &lt;- result{
                                        err: fmt.Errorf("script panic: %v", r),
                                }
                        }</span>
                }()

                // Inject context into the VM
                <span class="cov8" title="1">if err := a.injectContext(vm, execContext); err != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- result{err: err}
                        return
                }</span>

                // Enable interrupts for timeout support
                <span class="cov8" title="1">vm.SetMaxCallStackSize(1000) // Prevent stack overflow attacks

                // Wrap script in an IIFE (Immediately Invoked Function Expression)
                // This allows 'return' statements to work properly
                wrappedScript := "(function() {\n" + script + "\n})();"

                // Run the script
                val, err := vm.RunString(wrappedScript)
                if err != nil </span><span class="cov8" title="1">{
                        resultChan &lt;- result{err: fmt.Errorf("script execution failed: %w", err)}
                        return
                }</span>

                // Export result to Go value
                <span class="cov8" title="1">exported := a.exportValue(val)
                resultChan &lt;- result{value: exported}</span>
        }()

        // Wait for result or timeout
        <span class="cov8" title="1">select </span>{
        case res := &lt;-resultChan:<span class="cov8" title="1">
                return res.value, res.err</span>
        case &lt;-timeoutCtx.Done():<span class="cov8" title="1">
                // Attempt to interrupt the VM
                vm.Interrupt("execution timeout")
                return nil, fmt.Errorf("script execution timeout after %v", timeout)</span>
        }
}

// injectContext injects the execution context into the JavaScript VM
func (a *ScriptAction) injectContext(vm *goja.Runtime, execContext map[string]interface{}) error <span class="cov8" title="1">{
        // Create context object in JavaScript
        contextObj := vm.NewObject()

        // Convert execContext map to goja values
        for key, value := range execContext </span><span class="cov8" title="1">{
                gojaValue := vm.ToValue(value)
                if err := contextObj.Set(key, gojaValue); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set context.%s: %w", key, err)
                }</span>
        }

        // Set context as global variable
        <span class="cov8" title="1">if err := vm.Set("context", contextObj); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set context global: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// exportValue converts a goja.Value to a Go interface{} value
func (a *ScriptAction) exportValue(val goja.Value) interface{} <span class="cov8" title="1">{
        if val == nil || goja.IsUndefined(val) || goja.IsNull(val) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">exported := val.Export()

        // Handle special cases for better JSON serialization
        switch v := exported.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                // Already correct type
                return v</span>
        case []interface{}:<span class="cov8" title="1">
                // Already correct type
                return v</span>
        case string, int, int32, int64, float32, float64, bool:<span class="cov8" title="1">
                // Primitive types
                return v</span>
        default:<span class="cov0" title="0">
                // For other types, try to convert to primitive
                return exported</span>
        }
}

// Helper function for creating script actions (for testing)
func NewScriptAction() *ScriptAction <span class="cov0" title="0">{
        return &amp;ScriptAction{}
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package actions

import (
        "context"
        "encoding/json"
        "fmt"
)

// TransformAction implements the Action interface for data transformation
type TransformAction struct{}

// TransformActionConfig represents the configuration for a transform action
type TransformActionConfig struct {
        // Expression is a JSONPath expression to extract a value
        Expression string `json:"expression,omitempty"`
        // Mapping defines field mappings from source paths to target keys
        Mapping map[string]string `json:"mapping,omitempty"`
        // Default value to use if extraction fails
        Default interface{} `json:"default,omitempty"`
}

// Execute implements the Action interface
func (a *TransformAction) Execute(ctx context.Context, input *ActionInput) (*ActionOutput, error) <span class="cov8" title="1">{
        // Parse config
        configBytes, err := json.Marshal(input.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">var config TransformActionConfig
        if err := json.Unmarshal(configBytes, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse transform action config: %w", err)
        }</span>

        // Execute transformation
        <span class="cov8" title="1">result, err := a.executeTransform(ctx, config, input.Context)
        if err != nil </span><span class="cov8" title="1">{
                // If default is specified and transformation fails, use default
                if config.Default != nil </span><span class="cov8" title="1">{
                        return NewActionOutput(config.Default), nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return NewActionOutput(result), nil</span>
}

// executeTransform executes the transformation
func (a *TransformAction) executeTransform(ctx context.Context, config TransformActionConfig, execContext map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        // If mapping is provided, create output from mapping
        if len(config.Mapping) &gt; 0 </span><span class="cov8" title="1">{
                return a.executeMapping(config.Mapping, execContext)
        }</span>

        // If expression is provided, evaluate it
        <span class="cov8" title="1">if config.Expression != "" </span><span class="cov8" title="1">{
                return a.executeExpression(config.Expression, execContext)
        }</span>

        // Return input context if no transformation specified
        <span class="cov8" title="1">return execContext, nil</span>
}

// executeMapping creates a new object based on the mapping configuration
func (a *TransformAction) executeMapping(mapping map[string]string, context map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for targetKey, sourcePath := range mapping </span><span class="cov8" title="1">{
                value, err := GetValueByPath(context, sourcePath)
                if err != nil </span><span class="cov8" title="1">{
                        // Use nil for missing values instead of failing
                        result[targetKey] = nil
                        continue</span>
                }
                <span class="cov8" title="1">result[targetKey] = value</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// executeExpression evaluates a JSONPath expression
func (a *TransformAction) executeExpression(expression string, context map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        value, err := GetValueByPath(context, expression)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to evaluate expression '%s': %w", expression, err)
        }</span>

        <span class="cov8" title="1">return value, nil</span>
}

// Legacy function for backward compatibility
func ExecuteTransform(ctx context.Context, config TransformActionConfig, executionContext map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        action := &amp;TransformAction{}
        input := NewActionInput(config, executionContext)
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return output.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package executor

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "sync"
        "time"
)

var (
        // ErrCircuitOpen is returned when the circuit breaker is open
        ErrCircuitOpen = errors.New("circuit breaker is open")
        // ErrTooManyRequests is returned when the circuit breaker is half-open and at capacity
        ErrTooManyRequests = errors.New("circuit breaker is half-open: too many requests")
)

// CircuitState represents the state of a circuit breaker
type CircuitState int

const (
        // StateClosed allows all requests through
        StateClosed CircuitState = iota
        // StateOpen blocks all requests
        StateOpen
        // StateHalfOpen allows limited requests to test if the service has recovered
        StateHalfOpen
)

// String returns the string representation of the circuit state
func (s CircuitState) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StateClosed:<span class="cov8" title="1">
                return "closed"</span>
        case StateOpen:<span class="cov8" title="1">
                return "open"</span>
        case StateHalfOpen:<span class="cov8" title="1">
                return "half-open"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// CircuitBreakerConfig holds configuration for circuit breaker behavior
type CircuitBreakerConfig struct {
        // MaxFailures is the number of consecutive failures before opening the circuit
        MaxFailures int
        // Timeout is how long to wait before transitioning from Open to Half-Open
        Timeout time.Duration
        // MaxRequests is the max concurrent requests allowed in Half-Open state
        MaxRequests int
        // FailureThreshold is the ratio of failures to trigger open state (0.0-1.0)
        FailureThreshold float64
        // SlidingWindowSize is the number of recent requests to consider
        SlidingWindowSize int
}

// DefaultCircuitBreakerConfig returns the default circuit breaker configuration
func DefaultCircuitBreakerConfig() CircuitBreakerConfig <span class="cov8" title="1">{
        return CircuitBreakerConfig{
                MaxFailures:       5,
                Timeout:           60 * time.Second,
                MaxRequests:       3,
                FailureThreshold:  0.5,
                SlidingWindowSize: 10,
        }
}</span>

// CircuitBreaker implements the circuit breaker pattern
type CircuitBreaker struct {
        name   string
        config CircuitBreakerConfig
        logger *slog.Logger

        mu            sync.RWMutex
        state         CircuitState
        failures      int
        lastFailTime  time.Time
        lastStateTime time.Time
        halfOpenReqs  int

        // Sliding window for tracking recent requests
        window        []bool // true = success, false = failure
        windowIndex   int
        windowFilled  bool
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(name string, config CircuitBreakerConfig, logger *slog.Logger) *CircuitBreaker <span class="cov8" title="1">{
        return &amp;CircuitBreaker{
                name:          name,
                config:        config,
                logger:        logger,
                state:         StateClosed,
                lastStateTime: time.Now(),
                window:        make([]bool, config.SlidingWindowSize),
        }
}</span>

// Execute runs an operation through the circuit breaker
func (cb *CircuitBreaker) Execute(ctx context.Context, operation func(context.Context) error) error <span class="cov8" title="1">{
        // Check if we can execute
        if err := cb.beforeRequest(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Execute the operation
        <span class="cov8" title="1">err := operation(ctx)

        // Record the result
        cb.afterRequest(err)

        return err</span>
}

// ExecuteWithResult runs an operation that returns a result through the circuit breaker
func (cb *CircuitBreaker) ExecuteWithResult(ctx context.Context, operation func(context.Context) (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        // Check if we can execute
        if err := cb.beforeRequest(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute the operation
        <span class="cov8" title="1">result, err := operation(ctx)

        // Record the result
        cb.afterRequest(err)

        return result, err</span>
}

// beforeRequest checks if a request can proceed based on circuit state
func (cb *CircuitBreaker) beforeRequest() error <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        now := time.Now()

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                // Allow request
                return nil</span>

        case StateOpen:<span class="cov8" title="1">
                // Check if timeout has elapsed to transition to half-open
                if now.Sub(cb.lastStateTime) &gt;= cb.config.Timeout </span><span class="cov8" title="1">{
                        cb.setState(StateHalfOpen)
                        cb.halfOpenReqs = 0
                        cb.logger.Info("circuit breaker transitioning to half-open",
                                "name", cb.name,
                                "timeout", cb.config.Timeout,
                        )
                        return nil
                }</span>
                // Still open, reject request
                <span class="cov8" title="1">return ErrCircuitOpen</span>

        case StateHalfOpen:<span class="cov8" title="1">
                // Allow limited concurrent requests
                if cb.halfOpenReqs &gt;= cb.config.MaxRequests </span><span class="cov8" title="1">{
                        return ErrTooManyRequests
                }</span>
                <span class="cov8" title="1">cb.halfOpenReqs++
                return nil</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown circuit state: %v", cb.state)</span>
        }
}

// afterRequest records the result of a request and updates circuit state
func (cb *CircuitBreaker) afterRequest(err error) <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        success := err == nil

        // Add to sliding window
        cb.window[cb.windowIndex] = success
        cb.windowIndex = (cb.windowIndex + 1) % len(cb.window)
        if cb.windowIndex == 0 </span><span class="cov8" title="1">{
                cb.windowFilled = true
        }</span>

        <span class="cov8" title="1">if cb.state == StateHalfOpen </span><span class="cov8" title="1">{
                cb.halfOpenReqs--
        }</span>

        <span class="cov8" title="1">if success </span><span class="cov8" title="1">{
                cb.onSuccess()
        }</span> else<span class="cov8" title="1"> {
                cb.onFailure()
        }</span>
}

// onSuccess handles a successful request
func (cb *CircuitBreaker) onSuccess() <span class="cov8" title="1">{
        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                // Reset failure count on success
                if cb.failures &gt; 0 </span><span class="cov0" title="0">{
                        cb.failures = 0
                }</span>

        case StateHalfOpen:<span class="cov8" title="1">
                // Check if we should transition to closed
                successCount, totalCount := cb.getWindowStats()
                if totalCount &gt;= cb.config.SlidingWindowSize </span><span class="cov8" title="1">{
                        failureRatio := 1.0 - (float64(successCount) / float64(totalCount))
                        if failureRatio &lt; cb.config.FailureThreshold </span><span class="cov8" title="1">{
                                cb.setState(StateClosed)
                                cb.failures = 0
                                cb.logger.Info("circuit breaker closed after recovery",
                                        "name", cb.name,
                                        "success_count", successCount,
                                        "total_count", totalCount,
                                )
                        }</span>
                }
        }
}

// onFailure handles a failed request
func (cb *CircuitBreaker) onFailure() <span class="cov8" title="1">{
        cb.failures++
        cb.lastFailTime = time.Now()

        switch cb.state </span>{
        case StateClosed:<span class="cov8" title="1">
                // Check if we should open the circuit
                if cb.shouldOpen() </span><span class="cov8" title="1">{
                        cb.setState(StateOpen)
                        cb.logger.Warn("circuit breaker opened due to failures",
                                "name", cb.name,
                                "failures", cb.failures,
                                "max_failures", cb.config.MaxFailures,
                        )
                }</span>

        case StateHalfOpen:<span class="cov8" title="1">
                // Any failure in half-open state reopens the circuit
                cb.setState(StateOpen)
                cb.logger.Warn("circuit breaker reopened after half-open failure",
                        "name", cb.name,
                )</span>
        }
}

// shouldOpen determines if the circuit should open based on failure criteria
func (cb *CircuitBreaker) shouldOpen() bool <span class="cov8" title="1">{
        // Check consecutive failures
        if cb.failures &gt;= cb.config.MaxFailures </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check failure threshold in sliding window
        <span class="cov8" title="1">if cb.windowFilled || cb.windowIndex &gt;= cb.config.SlidingWindowSize </span><span class="cov0" title="0">{
                successCount, totalCount := cb.getWindowStats()
                if totalCount &gt; 0 </span><span class="cov0" title="0">{
                        failureRatio := 1.0 - (float64(successCount) / float64(totalCount))
                        if failureRatio &gt;= cb.config.FailureThreshold </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// getWindowStats returns the success count and total count from the sliding window
func (cb *CircuitBreaker) getWindowStats() (successCount, totalCount int) <span class="cov8" title="1">{
        limit := len(cb.window)
        if !cb.windowFilled </span><span class="cov8" title="1">{
                limit = cb.windowIndex
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                if cb.window[i] </span><span class="cov8" title="1">{
                        successCount++
                }</span>
                <span class="cov8" title="1">totalCount++</span>
        }

        <span class="cov8" title="1">return successCount, totalCount</span>
}

// setState changes the circuit breaker state
func (cb *CircuitBreaker) setState(state CircuitState) <span class="cov8" title="1">{
        if cb.state != state </span><span class="cov8" title="1">{
                oldState := cb.state
                cb.state = state
                cb.lastStateTime = time.Now()
                cb.logger.Info("circuit breaker state changed",
                        "name", cb.name,
                        "old_state", oldState.String(),
                        "new_state", state.String(),
                )
        }</span>
}

// GetState returns the current state of the circuit breaker
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov8" title="1">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        return cb.state
}</span>

// GetFailureCount returns the current failure count
func (cb *CircuitBreaker) GetFailureCount() int <span class="cov8" title="1">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()
        return cb.failures
}</span>

// Reset resets the circuit breaker to closed state
func (cb *CircuitBreaker) Reset() <span class="cov8" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.setState(StateClosed)
        cb.failures = 0
        cb.halfOpenReqs = 0
        cb.windowIndex = 0
        cb.windowFilled = false
        cb.window = make([]bool, cb.config.SlidingWindowSize)

        cb.logger.Info("circuit breaker reset",
                "name", cb.name,
        )
}</span>

// CircuitBreakerRegistry manages multiple circuit breakers
type CircuitBreakerRegistry struct {
        mu       sync.RWMutex
        breakers map[string]*CircuitBreaker
        config   CircuitBreakerConfig
        logger   *slog.Logger
}

// NewCircuitBreakerRegistry creates a new circuit breaker registry
func NewCircuitBreakerRegistry(config CircuitBreakerConfig, logger *slog.Logger) *CircuitBreakerRegistry <span class="cov8" title="1">{
        return &amp;CircuitBreakerRegistry{
                breakers: make(map[string]*CircuitBreaker),
                config:   config,
                logger:   logger,
        }
}</span>

// GetOrCreate gets an existing circuit breaker or creates a new one
func (r *CircuitBreakerRegistry) GetOrCreate(name string) *CircuitBreaker <span class="cov8" title="1">{
        r.mu.RLock()
        breaker, exists := r.breakers[name]
        r.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                return breaker
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        // Double-check after acquiring write lock
        if breaker, exists := r.breakers[name]; exists </span><span class="cov0" title="0">{
                return breaker
        }</span>

        // Create new circuit breaker
        <span class="cov8" title="1">breaker = NewCircuitBreaker(name, r.config, r.logger)
        r.breakers[name] = breaker

        return breaker</span>
}

// Get retrieves a circuit breaker by name
func (r *CircuitBreakerRegistry) Get(name string) (*CircuitBreaker, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        breaker, exists := r.breakers[name]
        return breaker, exists
}</span>

// Reset resets all circuit breakers
func (r *CircuitBreakerRegistry) Reset() <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for _, breaker := range r.breakers </span><span class="cov8" title="1">{
                breaker.Reset()
        }</span>
}

// GetStats returns statistics for all circuit breakers
func (r *CircuitBreakerRegistry) GetStats() map[string]CircuitBreakerStats <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        stats := make(map[string]CircuitBreakerStats)
        for name, breaker := range r.breakers </span><span class="cov8" title="1">{
                breaker.mu.RLock()
                stats[name] = CircuitBreakerStats{
                        Name:         name,
                        State:        breaker.state.String(),
                        Failures:     breaker.failures,
                        LastFailTime: breaker.lastFailTime,
                }
                breaker.mu.RUnlock()
        }</span>

        <span class="cov8" title="1">return stats</span>
}

// CircuitBreakerStats holds statistics for a circuit breaker
type CircuitBreakerStats struct {
        Name         string    `json:"name"`
        State        string    `json:"state"`
        Failures     int       `json:"failures"`
        LastFailTime time.Time `json:"last_fail_time"`
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package executor

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/gorax/gorax/internal/executor/expression"
        "github.com/gorax/gorax/internal/workflow"
)

// ConditionalBranchResult represents the result of evaluating a conditional node
type ConditionalBranchResult struct {
        Condition      string
        Result         bool
        TakenBranch    string // "true" or "false"
        NextNodes      []string
        StopExecution  bool
}

// executeConditionalAction executes a conditional (if/else) action
func (e *Executor) executeConditionalAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext, definition *workflow.WorkflowDefinition) (*ConditionalBranchResult, error) <span class="cov0" title="0">{
        // Extract config from node data
        configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for conditional action")
        }</span>

        // Parse node config
        <span class="cov0" title="0">var config workflow.ConditionalActionConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse conditional action config: %w", err)
        }</span>

        <span class="cov0" title="0">if config.Condition == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("condition expression is required")
        }</span>

        // Build evaluation context
        <span class="cov0" title="0">evalContext := expression.BuildContext(
                execCtx.TriggerData,
                execCtx.StepOutputs,
                map[string]interface{}{
                        "tenant_id":    execCtx.TenantID,
                        "execution_id": execCtx.ExecutionID,
                        "workflow_id":  execCtx.WorkflowID,
                },
        )

        // Evaluate the condition
        evaluator := expression.NewEvaluator()
        result, err := evaluator.EvaluateCondition(config.Condition, evalContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to evaluate condition: %w", err)
        }</span>

        <span class="cov0" title="0">e.logger.Info("conditional expression evaluated",
                "node_id", node.ID,
                "condition", config.Condition,
                "result", result,
        )

        // Determine which branch to take
        branchResult := &amp;ConditionalBranchResult{
                Condition:   config.Condition,
                Result:      result,
                TakenBranch: "false",
                NextNodes:   []string{},
        }

        if result </span><span class="cov0" title="0">{
                branchResult.TakenBranch = "true"
                branchResult.StopExecution = config.StopOnTrue

                // Find nodes connected via "true" branch
                branchResult.NextNodes = e.findConditionalBranch(node.ID, "true", definition.Edges)
        }</span> else<span class="cov0" title="0"> {
                branchResult.TakenBranch = "false"
                branchResult.StopExecution = config.StopOnFalse

                // Find nodes connected via "false" branch
                branchResult.NextNodes = e.findConditionalBranch(node.ID, "false", definition.Edges)
        }</span>

        <span class="cov0" title="0">e.logger.Info("conditional branch determined",
                "node_id", node.ID,
                "taken_branch", branchResult.TakenBranch,
                "next_nodes", branchResult.NextNodes,
                "stop_execution", branchResult.StopExecution,
        )

        return branchResult, nil</span>
}

// findConditionalBranch finds the target nodes for a specific branch label
func (e *Executor) findConditionalBranch(sourceNodeID string, branchLabel string, edges []workflow.Edge) []string <span class="cov8" title="1">{
        var targets []string

        for _, edge := range edges </span><span class="cov8" title="1">{
                if edge.Source == sourceNodeID &amp;&amp; edge.Label == branchLabel </span><span class="cov8" title="1">{
                        targets = append(targets, edge.Target)
                }</span>
        }

        <span class="cov8" title="1">return targets</span>
}

// buildConditionalExecutionPlan builds an execution plan that respects conditional branches
// Instead of simple topological sort, this builds a plan that can handle branching
func (e *Executor) buildConditionalExecutionPlan(nodes []workflow.Node, edges []workflow.Edge) (*ExecutionPlan, error) <span class="cov0" title="0">{
        plan := &amp;ExecutionPlan{
                AllNodes:     buildNodeMap(nodes),
                Edges:        edges,
                ConditionalNodes: make(map[string]bool),
        }

        // Identify conditional nodes
        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.Type == string(workflow.NodeTypeControlIf) </span><span class="cov0" title="0">{
                        plan.ConditionalNodes[node.ID] = true
                }</span>
        }

        // Find start nodes (nodes with no incoming edges or trigger nodes)
        <span class="cov0" title="0">plan.StartNodes = e.findStartNodes(nodes, edges)

        if len(plan.StartNodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no start nodes found in workflow")
        }</span>

        <span class="cov0" title="0">return plan, nil</span>
}

// findStartNodes finds all nodes that can start execution
func (e *Executor) findStartNodes(nodes []workflow.Node, edges []workflow.Edge) []string <span class="cov0" title="0">{
        inDegree := make(map[string]int)

        // Initialize in-degree for all nodes
        for _, node := range nodes </span><span class="cov0" title="0">{
                inDegree[node.ID] = 0
        }</span>

        // Count incoming edges
        <span class="cov0" title="0">for _, edge := range edges </span><span class="cov0" title="0">{
                inDegree[edge.Target]++
        }</span>

        // Find nodes with no incoming edges
        <span class="cov0" title="0">var startNodes []string
        for _, node := range nodes </span><span class="cov0" title="0">{
                if inDegree[node.ID] == 0 </span><span class="cov0" title="0">{
                        startNodes = append(startNodes, node.ID)
                }</span>
        }

        <span class="cov0" title="0">return startNodes</span>
}

// ExecutionPlan represents a conditional execution plan
type ExecutionPlan struct {
        AllNodes         map[string]workflow.Node
        Edges            []workflow.Edge
        StartNodes       []string
        ConditionalNodes map[string]bool
}

// getNextNodes returns the next nodes to execute based on current node
// For conditional nodes, this will be determined at runtime
// For regular nodes, this returns all connected nodes
func (plan *ExecutionPlan) getNextNodes(nodeID string, conditionalResult *ConditionalBranchResult) []string <span class="cov0" title="0">{
        // If this was a conditional node and we have a result, use it
        if conditionalResult != nil &amp;&amp; plan.ConditionalNodes[nodeID] </span><span class="cov0" title="0">{
                return conditionalResult.NextNodes
        }</span>

        // For non-conditional nodes, return all targets
        <span class="cov0" title="0">var targets []string
        for _, edge := range plan.Edges </span><span class="cov0" title="0">{
                if edge.Source == nodeID </span><span class="cov0" title="0">{
                        targets = append(targets, edge.Target)
                }</span>
        }

        <span class="cov0" title="0">return targets</span>
}

// hasAllDependenciesCompleted checks if all dependencies of a node are completed
func (plan *ExecutionPlan) hasAllDependenciesCompleted(nodeID string, completedNodes map[string]bool, skippedNodes map[string]bool) bool <span class="cov0" title="0">{
        // Find all nodes that have edges pointing to this node
        for _, edge := range plan.Edges </span><span class="cov0" title="0">{
                if edge.Target == nodeID </span><span class="cov0" title="0">{
                        sourceNode := edge.Source
                        // Dependency must be either completed or skipped
                        if !completedNodes[sourceNode] &amp;&amp; !skippedNodes[sourceNode] </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

// findNodesToSkip finds all nodes that should be skipped based on conditional branching
// This performs a traversal from the conditional node along the non-taken branch
func (e *Executor) findNodesToSkip(conditionalNodeID string, takenBranch string, edges []workflow.Edge, allNodes map[string]workflow.Node) map[string]bool <span class="cov0" title="0">{
        skipped := make(map[string]bool)

        // Find the branch that was NOT taken
        notTakenBranch := "false"
        if takenBranch == "false" </span><span class="cov0" title="0">{
                notTakenBranch = "true"
        }</span>

        // Find all nodes reachable from the non-taken branch
        // These should be marked as skipped
        <span class="cov0" title="0">notTakenTargets := []string{}
        for _, edge := range edges </span><span class="cov0" title="0">{
                if edge.Source == conditionalNodeID &amp;&amp; edge.Label == notTakenBranch </span><span class="cov0" title="0">{
                        notTakenTargets = append(notTakenTargets, edge.Target)
                }</span>
        }

        // BFS to find all nodes reachable from non-taken branch
        <span class="cov0" title="0">visited := make(map[string]bool)
        queue := notTakenTargets

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                if visited[current] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">visited[current] = true
                skipped[current] = true

                // Add all children of this node to the queue
                // But only if they are exclusively reachable from this branch
                for _, edge := range edges </span><span class="cov0" title="0">{
                        if edge.Source == current </span><span class="cov0" title="0">{
                                // Check if this target has other incoming edges from nodes not in skipped set
                                hasOtherParents := false
                                for _, checkEdge := range edges </span><span class="cov0" title="0">{
                                        if checkEdge.Target == edge.Target &amp;&amp; checkEdge.Source != current &amp;&amp; !skipped[checkEdge.Source] </span><span class="cov0" title="0">{
                                                hasOtherParents = true
                                                break</span>
                                        }
                                }

                                // Only skip if this node has no other non-skipped parents
                                <span class="cov0" title="0">if !hasOtherParents </span><span class="cov0" title="0">{
                                        queue = append(queue, edge.Target)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return skipped</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package executor

import (
        "context"
        "errors"
        "fmt"
        "net"
        "net/http"
        "strings"
        "syscall"
)

// ErrorClassification defines the type of error for retry handling
type ErrorClassification int

const (
        // ErrorClassificationUnknown is for errors that cannot be classified
        ErrorClassificationUnknown ErrorClassification = iota
        // ErrorClassificationTransient are temporary errors that can be retried
        ErrorClassificationTransient
        // ErrorClassificationPermanent are permanent errors that should not be retried
        ErrorClassificationPermanent
)

// ExecutionError wraps an error with classification and context
type ExecutionError struct {
        // Original error
        Err error
        // Classification of the error
        Classification ErrorClassification
        // NodeID where the error occurred
        NodeID string
        // NodeType where the error occurred
        NodeType string
        // Additional context
        Context map[string]interface{}
        // Retry count when this error occurred
        RetryCount int
}

// Error implements the error interface
func (e *ExecutionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("execution error in node %s (%s): %v", e.NodeID, e.NodeType, e.Err)
}</span>

// Unwrap implements the errors.Unwrap interface
func (e *ExecutionError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// IsRetryable returns true if the error is transient and can be retried
func (e *ExecutionError) IsRetryable() bool <span class="cov8" title="1">{
        return e.Classification == ErrorClassificationTransient
}</span>

// NewExecutionError creates a new ExecutionError with automatic classification
func NewExecutionError(err error, nodeID, nodeType string, retryCount int) *ExecutionError <span class="cov8" title="1">{
        return &amp;ExecutionError{
                Err:            err,
                Classification: ClassifyError(err),
                NodeID:         nodeID,
                NodeType:       nodeType,
                Context:        make(map[string]interface{}),
                RetryCount:     retryCount,
        }
}</span>

// WithContext adds context to the error
func (e *ExecutionError) WithContext(key string, value interface{}) *ExecutionError <span class="cov8" title="1">{
        e.Context[key] = value
        return e
}</span>

// ClassifyError determines if an error is transient or permanent
func ClassifyError(err error) ErrorClassification <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ErrorClassificationUnknown
        }</span>

        // Check for timeout errors
        <span class="cov8" title="1">if errors.Is(err, syscall.ETIMEDOUT) </span><span class="cov0" title="0">{
                return ErrorClassificationTransient
        }</span>

        // Check for context errors
        <span class="cov8" title="1">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                return ErrorClassificationTransient
        }</span>
        <span class="cov8" title="1">if errors.Is(err, context.Canceled) </span><span class="cov8" title="1">{
                return ErrorClassificationPermanent // User canceled, don't retry
        }</span>

        // Check for network errors
        <span class="cov8" title="1">var netErr net.Error
        if errors.As(err, &amp;netErr) </span><span class="cov8" title="1">{
                if netErr.Timeout() </span><span class="cov8" title="1">{
                        return ErrorClassificationTransient
                }</span>
                <span class="cov8" title="1">if netErr.Temporary() </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
        }

        // Check for DNS errors
        <span class="cov8" title="1">var dnsErr *net.DNSError
        if errors.As(err, &amp;dnsErr) </span><span class="cov0" title="0">{
                if dnsErr.IsTimeout </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
                // DNS not found is permanent
                <span class="cov0" title="0">if dnsErr.IsNotFound </span><span class="cov0" title="0">{
                        return ErrorClassificationPermanent
                }</span>
                // Temporary DNS issues can be retried
                <span class="cov0" title="0">if dnsErr.Temporary() </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
        }

        // Check for connection errors
        <span class="cov8" title="1">var opErr *net.OpError
        if errors.As(err, &amp;opErr) </span><span class="cov0" title="0">{
                // Connection refused might be temporary (service starting up)
                if errors.Is(opErr.Err, syscall.ECONNREFUSED) </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
                // Connection reset can be transient
                <span class="cov0" title="0">if errors.Is(opErr.Err, syscall.ECONNRESET) </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
                // Network unreachable is transient
                <span class="cov0" title="0">if errors.Is(opErr.Err, syscall.ENETUNREACH) </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
                // Host unreachable is transient
                <span class="cov0" title="0">if errors.Is(opErr.Err, syscall.EHOSTUNREACH) </span><span class="cov0" title="0">{
                        return ErrorClassificationTransient
                }</span>
        }

        // Check for syscall errors
        <span class="cov8" title="1">if errors.Is(err, syscall.ECONNREFUSED) ||
                errors.Is(err, syscall.ECONNRESET) ||
                errors.Is(err, syscall.ECONNABORTED) ||
                errors.Is(err, syscall.ENETUNREACH) ||
                errors.Is(err, syscall.EHOSTUNREACH) </span><span class="cov8" title="1">{
                return ErrorClassificationTransient
        }</span>

        // Check error message for common patterns
        <span class="cov8" title="1">errMsg := strings.ToLower(err.Error())

        // Transient error patterns
        transientPatterns := []string{
                "timeout",
                "timed out",
                "temporary failure",
                "connection refused",
                "connection reset",
                "connection aborted",
                "network is unreachable",
                "host is unreachable",
                "too many connections",
                "service unavailable",
                "rate limit exceeded",
                "throttle",
                "try again",
                "temporarily unavailable",
                "gateway timeout",
                "bad gateway",
        }

        for _, pattern := range transientPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errMsg, pattern) </span><span class="cov8" title="1">{
                        return ErrorClassificationTransient
                }</span>
        }

        // Permanent error patterns
        <span class="cov8" title="1">permanentPatterns := []string{
                "invalid",
                "malformed",
                "parse error",
                "syntax error",
                "unauthorized",
                "forbidden",
                "not found",
                "bad request",
                "authentication failed",
                "permission denied",
                "access denied",
                "unsupported",
                "not implemented",
                "method not allowed",
                "conflict",
                "precondition failed",
                "unprocessable entity",
                "payload too large",
                "uri too long",
                "expectation failed",
        }

        for _, pattern := range permanentPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errMsg, pattern) </span><span class="cov8" title="1">{
                        return ErrorClassificationPermanent
                }</span>
        }

        // Default to unknown classification
        <span class="cov8" title="1">return ErrorClassificationUnknown</span>
}

// ClassifyHTTPStatusCode classifies an HTTP status code
func ClassifyHTTPStatusCode(statusCode int) ErrorClassification <span class="cov8" title="1">{
        // 2xx and 3xx are successful, not errors
        if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400 </span><span class="cov8" title="1">{
                return ErrorClassificationUnknown
        }</span>

        // 4xx Client Errors - mostly permanent
        <span class="cov8" title="1">if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 </span><span class="cov8" title="1">{
                switch statusCode </span>{
                case http.StatusRequestTimeout:<span class="cov8" title="1"> // 408
                        return ErrorClassificationTransient</span>
                case http.StatusTooManyRequests:<span class="cov8" title="1"> // 429
                        return ErrorClassificationTransient</span>
                case http.StatusConflict:<span class="cov8" title="1"> // 409 - might be transient depending on use case
                        return ErrorClassificationTransient</span>
                default:<span class="cov8" title="1">
                        return ErrorClassificationPermanent</span>
                }
        }

        // 5xx Server Errors - mostly transient
        <span class="cov8" title="1">if statusCode &gt;= 500 &amp;&amp; statusCode &lt; 600 </span><span class="cov8" title="1">{
                switch statusCode </span>{
                case http.StatusNotImplemented:<span class="cov8" title="1"> // 501
                        return ErrorClassificationPermanent</span>
                case http.StatusHTTPVersionNotSupported:<span class="cov0" title="0"> // 505
                        return ErrorClassificationPermanent</span>
                default:<span class="cov8" title="1">
                        // 500, 502, 503, 504 and others are transient
                        return ErrorClassificationTransient</span>
                }
        }

        <span class="cov0" title="0">return ErrorClassificationUnknown</span>
}

// ShouldRetry determines if an operation should be retried based on the error and retry count
func ShouldRetry(err error, currentRetry, maxRetries int) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if currentRetry &gt;= maxRetries </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">classification := ClassifyError(err)
        return classification == ErrorClassificationTransient</span>
}

// WrapError wraps an error with execution context
func WrapError(err error, nodeID, nodeType string, retryCount int) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If already an ExecutionError, update retry count
        <span class="cov8" title="1">var execErr *ExecutionError
        if errors.As(err, &amp;execErr) </span><span class="cov0" title="0">{
                execErr.RetryCount = retryCount
                return execErr
        }</span>

        <span class="cov8" title="1">return NewExecutionError(err, nodeID, nodeType, retryCount)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package executor

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "time"

        "github.com/gorax/gorax/internal/credential"
        "github.com/gorax/gorax/internal/workflow"
)

// Broadcaster defines the interface for broadcasting execution events
type Broadcaster interface {
        BroadcastExecutionStarted(tenantID, workflowID, executionID string, totalSteps int)
        BroadcastExecutionCompleted(tenantID, workflowID, executionID string, output json.RawMessage)
        BroadcastExecutionFailed(tenantID, workflowID, executionID string, errorMsg string)
        BroadcastStepStarted(tenantID, workflowID, executionID, nodeID, nodeType string)
        BroadcastStepCompleted(tenantID, workflowID, executionID, nodeID string, output json.RawMessage, durationMs int)
        BroadcastStepFailed(tenantID, workflowID, executionID, nodeID string, errorMsg string)
        BroadcastProgress(tenantID, workflowID, executionID string, completedSteps, totalSteps int)
}

// Executor handles workflow execution
type Executor struct {
        repo               *workflow.Repository
        logger             *slog.Logger
        broadcaster        Broadcaster
        retryStrategy      *RetryStrategy
        circuitBreakers    *CircuitBreakerRegistry
        defaultRetryConfig NodeRetryConfig
        credentialInjector *credential.Injector // Optional credential injector
        credentialService  credential.Service   // Optional credential service for Slack actions
}

// New creates a new executor without broadcasting
func New(repo *workflow.Repository, logger *slog.Logger) *Executor <span class="cov0" title="0">{
        retryConfig := DefaultRetryConfig()
        circuitConfig := DefaultCircuitBreakerConfig()

        return &amp;Executor{
                repo:               repo,
                logger:             logger,
                broadcaster:        nil,
                retryStrategy:      NewRetryStrategy(retryConfig, logger),
                circuitBreakers:    NewCircuitBreakerRegistry(circuitConfig, logger),
                defaultRetryConfig: DefaultNodeRetryConfig(),
        }
}</span>

// NewWithBroadcaster creates a new executor with event broadcasting
func NewWithBroadcaster(repo *workflow.Repository, logger *slog.Logger, broadcaster Broadcaster) *Executor <span class="cov0" title="0">{
        retryConfig := DefaultRetryConfig()
        circuitConfig := DefaultCircuitBreakerConfig()

        return &amp;Executor{
                repo:               repo,
                logger:             logger,
                broadcaster:        broadcaster,
                retryStrategy:      NewRetryStrategy(retryConfig, logger),
                circuitBreakers:    NewCircuitBreakerRegistry(circuitConfig, logger),
                defaultRetryConfig: DefaultNodeRetryConfig(),
        }
}</span>

// NewWithCredentials creates a new executor with credential injection support
func NewWithCredentials(repo *workflow.Repository, logger *slog.Logger, broadcaster Broadcaster, injector *credential.Injector, credService credential.Service) *Executor <span class="cov0" title="0">{
        retryConfig := DefaultRetryConfig()
        circuitConfig := DefaultCircuitBreakerConfig()

        return &amp;Executor{
                repo:               repo,
                logger:             logger,
                broadcaster:        broadcaster,
                retryStrategy:      NewRetryStrategy(retryConfig, logger),
                circuitBreakers:    NewCircuitBreakerRegistry(circuitConfig, logger),
                defaultRetryConfig: DefaultNodeRetryConfig(),
                credentialInjector: injector,
                credentialService:  credService,
        }
}</span>

// ExecutionContext holds context for a workflow execution
type ExecutionContext struct {
        TenantID          string
        ExecutionID       string
        WorkflowID        string
        TriggerData       map[string]interface{}
        StepOutputs       map[string]interface{}
        CredentialValues  []string // Decrypted credential values for masking
}

// Execute runs a workflow execution
func (e *Executor) Execute(ctx context.Context, execution *workflow.Execution) error <span class="cov0" title="0">{
        e.logger.Info("starting workflow execution",
                "execution_id", execution.ID,
                "workflow_id", execution.WorkflowID,
        )

        // Update status to running
        if err := e.repo.UpdateExecutionStatus(ctx, execution.ID, workflow.ExecutionStatusRunning, nil, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load workflow definition
        <span class="cov0" title="0">wf, err := e.repo.GetByID(ctx, execution.TenantID, execution.WorkflowID)
        if err != nil </span><span class="cov0" title="0">{
                return e.failExecution(ctx, execution)
        }</span>

        // Parse workflow definition
        <span class="cov0" title="0">var definition workflow.WorkflowDefinition
        if err := json.Unmarshal(wf.Definition, &amp;definition); err != nil </span><span class="cov0" title="0">{
                return e.failExecution(ctx, execution, fmt.Errorf("failed to parse workflow definition: %w", err))
        }</span>

        // Validate workflow has nodes
        <span class="cov0" title="0">if len(definition.Nodes) == 0 </span><span class="cov0" title="0">{
                return e.failExecution(ctx, execution, fmt.Errorf("workflow has no nodes to execute"))
        }</span>

        // Count non-trigger nodes for progress tracking
        <span class="cov0" title="0">totalSteps := 0
        for _, node := range definition.Nodes </span><span class="cov0" title="0">{
                if !isTriggerNode(node.Type) </span><span class="cov0" title="0">{
                        totalSteps++
                }</span>
        }

        // Broadcast execution started with total steps
        <span class="cov0" title="0">if e.broadcaster != nil </span><span class="cov0" title="0">{
                e.broadcaster.BroadcastExecutionStarted(execution.TenantID, execution.WorkflowID, execution.ID, totalSteps)
        }</span>

        // Parse trigger data
        <span class="cov0" title="0">var triggerData map[string]interface{}
        if execution.TriggerData != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal(*execution.TriggerData, &amp;triggerData); err != nil </span><span class="cov0" title="0">{
                        triggerData = make(map[string]interface{})
                }</span>
        } else<span class="cov0" title="0"> {
                triggerData = make(map[string]interface{})
        }</span>

        // Create execution context
        <span class="cov0" title="0">execCtx := &amp;ExecutionContext{
                TenantID:         execution.TenantID,
                ExecutionID:      execution.ID,
                WorkflowID:       execution.WorkflowID,
                TriggerData:      triggerData,
                StepOutputs:      make(map[string]interface{}),
                CredentialValues: []string{}, // Will be populated during execution
        }

        // Build execution order from DAG
        nodeMap := buildNodeMap(definition.Nodes)
        executionOrder, err := topologicalSort(definition.Nodes, definition.Edges)
        if err != nil </span><span class="cov0" title="0">{
                return e.failExecution(ctx, execution, fmt.Errorf("failed to determine execution order: %w", err))
        }</span>

        <span class="cov0" title="0">e.logger.Info("determined execution order",
                "execution_id", execution.ID,
                "node_count", len(executionOrder),
                "order", executionOrder,
        )

        // Execute nodes in order
        completedSteps := 0
        for _, nodeID := range executionOrder </span><span class="cov0" title="0">{
                node, exists := nodeMap[nodeID]
                if !exists </span><span class="cov0" title="0">{
                        e.logger.Warn("node not found in map", "node_id", nodeID)
                        continue</span>
                }

                <span class="cov0" title="0">e.logger.Info("executing node", "node_id", node.ID, "node_type", node.Type)

                // Skip triggers (they've already fired)
                if isTriggerNode(node.Type) </span><span class="cov0" title="0">{
                        execCtx.StepOutputs[node.ID] = triggerData
                        e.logger.Info("skipping trigger node", "node_id", node.ID)
                        continue</span>
                }

                // Broadcast step started
                <span class="cov0" title="0">if e.broadcaster != nil </span><span class="cov0" title="0">{
                        e.broadcaster.BroadcastStepStarted(execution.TenantID, execution.WorkflowID, execution.ID, node.ID, node.Type)
                }</span>

                // Execute the node with step tracking
                <span class="cov0" title="0">startTime := time.Now()
                var output interface{}
                var err error

                // Handle loop nodes specially
                if node.Type == string(workflow.NodeTypeControlLoop) </span><span class="cov0" title="0">{
                        output, err = e.executeLoopAction(ctx, node, execCtx, &amp;definition)
                }</span> else<span class="cov0" title="0"> {
                        output, err = e.executeNodeWithTracking(ctx, node, execCtx)
                }</span>
                <span class="cov0" title="0">durationMs := int(time.Since(startTime).Milliseconds())

                if err != nil </span><span class="cov0" title="0">{
                        e.logger.Error("node execution failed", "node_id", node.ID, "error", err)
                        // Broadcast step failure
                        if e.broadcaster != nil </span><span class="cov0" title="0">{
                                e.broadcaster.BroadcastStepFailed(execution.TenantID, execution.WorkflowID, execution.ID, node.ID, err.Error())
                        }</span>
                        <span class="cov0" title="0">return e.failExecution(ctx, execution, fmt.Errorf("node %s failed: %w", node.ID, err))</span>
                }

                // Store output for downstream nodes
                <span class="cov0" title="0">execCtx.StepOutputs[node.ID] = output

                // Broadcast step completion
                if e.broadcaster != nil </span><span class="cov0" title="0">{
                        outputJSON, _ := json.Marshal(output)
                        e.broadcaster.BroadcastStepCompleted(execution.TenantID, execution.WorkflowID, execution.ID, node.ID, outputJSON, durationMs)
                }</span>

                // Update and broadcast progress
                <span class="cov0" title="0">completedSteps++
                if e.broadcaster != nil </span><span class="cov0" title="0">{
                        e.broadcaster.BroadcastProgress(execution.TenantID, execution.WorkflowID, execution.ID, completedSteps, totalSteps)
                }</span>
        }

        // Mark execution as completed
        <span class="cov0" title="0">outputData, _ := json.Marshal(execCtx.StepOutputs)
        if err := e.repo.UpdateExecutionStatus(ctx, execution.ID, workflow.ExecutionStatusCompleted, outputData, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Broadcast execution completed
        <span class="cov0" title="0">if e.broadcaster != nil </span><span class="cov0" title="0">{
                e.broadcaster.BroadcastExecutionCompleted(execution.TenantID, execution.WorkflowID, execution.ID, outputData)
        }</span>

        <span class="cov0" title="0">e.logger.Info("workflow execution completed", "execution_id", execution.ID)
        return nil</span>
}

// executeNodeWithTracking executes a node and tracks the execution in the database
func (e *Executor) executeNodeWithTracking(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov0" title="0">{
        // Prepare input data for the node
        inputData := buildInputData(execCtx)
        inputDataJSON, _ := json.Marshal(inputData)

        // Create step execution record
        stepExecution, err := e.repo.CreateStepExecution(ctx, execCtx.ExecutionID, node.ID, node.Type, inputDataJSON)
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Error("failed to create step execution record", "error", err, "node_id", node.ID)
                // Continue execution even if we can't track it
        }</span>

        // Parse retry configuration from node data if available
        <span class="cov0" title="0">retryConfig := e.defaultRetryConfig
        // Try to parse retry config from node data
        var configMap map[string]interface{}
        if len(node.Data.Config) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(node.Data.Config, &amp;configMap); err == nil </span><span class="cov0" title="0">{
                        if retryData, exists := configMap["retry"]; exists </span><span class="cov0" title="0">{
                                // Parse custom retry config from node
                                retryConfig = e.parseRetryConfig(retryData)
                        }</span>
                }
        }

        // Execute the node with retry logic
        <span class="cov0" title="0">var output interface{}
        var execErr error
        retryCount := 0

        if retryConfig.Enabled </span><span class="cov0" title="0">{
                // Create retry strategy for this node
                nodeRetryStrategy := NewRetryStrategy(retryConfig.RetryConfig, e.logger)

                // Execute with retry
                result, err := nodeRetryStrategy.ExecuteWithResult(ctx, func(ctx context.Context, attempt int) (interface{}, error) </span><span class="cov0" title="0">{
                        retryCount = attempt
                        return e.executeNode(ctx, node, execCtx)
                }</span>)
                <span class="cov0" title="0">output = result
                execErr = err</span>
        } else<span class="cov0" title="0"> {
                // Execute without retry
                output, execErr = e.executeNode(ctx, node, execCtx)
        }</span>

        // Wrap error with execution context
        <span class="cov0" title="0">if execErr != nil </span><span class="cov0" title="0">{
                execErr = WrapError(execErr, node.ID, node.Type, retryCount)
        }</span>

        // Update step execution record
        <span class="cov0" title="0">if stepExecution != nil </span><span class="cov0" title="0">{
                var status string
                var errorMsg *string

                if execErr != nil </span><span class="cov0" title="0">{
                        status = "failed"
                        errStr := execErr.Error()
                        errorMsg = &amp;errStr

                        // Add error classification to the error message
                        if execError, ok := execErr.(*ExecutionError); ok </span><span class="cov0" title="0">{
                                classificationStr := "unknown"
                                switch execError.Classification </span>{
                                case ErrorClassificationTransient:<span class="cov0" title="0">
                                        classificationStr = "transient"</span>
                                case ErrorClassificationPermanent:<span class="cov0" title="0">
                                        classificationStr = "permanent"</span>
                                }
                                <span class="cov0" title="0">detailedErr := fmt.Sprintf("%s (classification: %s, retry_count: %d)", errStr, classificationStr, retryCount)
                                errorMsg = &amp;detailedErr</span>
                        }
                } else<span class="cov0" title="0"> {
                        status = "completed"
                }</span>

                <span class="cov0" title="0">outputDataJSON, _ := json.Marshal(output)
                if err := e.repo.UpdateStepExecution(ctx, stepExecution.ID, status, outputDataJSON, errorMsg); err != nil </span><span class="cov0" title="0">{
                        e.logger.Error("failed to update step execution record", "error", err, "step_id", stepExecution.ID)
                }</span>
        }

        <span class="cov0" title="0">return output, execErr</span>
}

// parseRetryConfig parses retry configuration from node data
func (e *Executor) parseRetryConfig(data interface{}) NodeRetryConfig <span class="cov0" title="0">{
        config := e.defaultRetryConfig

        if retryMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if enabled, ok := retryMap["enabled"].(bool); ok </span><span class="cov0" title="0">{
                        config.Enabled = enabled
                }</span>
                <span class="cov0" title="0">if maxRetries, ok := retryMap["max_retries"].(float64); ok </span><span class="cov0" title="0">{
                        config.MaxRetries = int(maxRetries)
                }</span>
                <span class="cov0" title="0">if initialBackoff, ok := retryMap["initial_backoff_ms"].(float64); ok </span><span class="cov0" title="0">{
                        config.InitialBackoff = time.Duration(initialBackoff) * time.Millisecond
                }</span>
                <span class="cov0" title="0">if maxBackoff, ok := retryMap["max_backoff_ms"].(float64); ok </span><span class="cov0" title="0">{
                        config.MaxBackoff = time.Duration(maxBackoff) * time.Millisecond
                }</span>
                <span class="cov0" title="0">if multiplier, ok := retryMap["backoff_multiplier"].(float64); ok </span><span class="cov0" title="0">{
                        config.BackoffMultiplier = multiplier
                }</span>
        }

        <span class="cov0" title="0">return config</span>
}

// executeNode executes a single node
func (e *Executor) executeNode(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Inject credentials if injector is available
        nodeToExecute := node
        var credentialValues []string

        if e.credentialInjector != nil &amp;&amp; len(node.Data.Config) &gt; 0 </span><span class="cov0" title="0">{
                injCtx := &amp;credential.InjectionContext{
                        TenantID:    execCtx.TenantID,
                        WorkflowID:  execCtx.WorkflowID,
                        ExecutionID: execCtx.ExecutionID,
                        AccessedBy:  "system", // TODO: Get actual user ID
                }

                injectResult, err := e.credentialInjector.InjectCredentials(ctx, node.Data.Config, injCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to inject credentials: %w", err)
                }</span>

                // Update node config with injected credentials
                <span class="cov0" title="0">nodeToExecute = node
                nodeToExecute.Data.Config = injectResult.Config

                // Store credential values for masking
                credentialValues = injectResult.Values
                execCtx.CredentialValues = append(execCtx.CredentialValues, credentialValues...)</span>
        }

        <span class="cov0" title="0">var output interface{}
        var err error

        switch nodeToExecute.Type </span>{
        case string(workflow.NodeTypeActionHTTP):<span class="cov0" title="0">
                output, err = e.executeHTTPAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionTransform):<span class="cov0" title="0">
                output, err = e.executeTransformAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionFormula):<span class="cov0" title="0">
                output, err = e.executeFormulaAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionCode):<span class="cov0" title="0">
                output, err = e.executeCodeAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionSlackSendMessage):<span class="cov0" title="0">
                output, err = e.executeSlackSendMessageAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionSlackSendDM):<span class="cov0" title="0">
                output, err = e.executeSlackSendDMAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionSlackUpdateMessage):<span class="cov0" title="0">
                output, err = e.executeSlackUpdateMessageAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeActionSlackAddReaction):<span class="cov0" title="0">
                output, err = e.executeSlackAddReactionAction(ctx, nodeToExecute, execCtx)</span>
        case string(workflow.NodeTypeControlLoop):<span class="cov0" title="0">
                // Loop nodes need access to workflow definition
                // For now, return error - will be handled separately in execution flow
                err = fmt.Errorf("loop nodes must be handled in execution flow, not as individual nodes")</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unknown node type: %s", nodeToExecute.Type)</span>
        }

        // Mask credentials in output if any were injected
        <span class="cov0" title="0">if len(credentialValues) &gt; 0 &amp;&amp; e.credentialInjector != nil </span><span class="cov0" title="0">{
                output = e.credentialInjector.MaskOutput(output, credentialValues)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)
        e.logger.Info("node executed",
                "node_id", node.ID,
                "node_type", node.Type,
                "duration_ms", duration.Milliseconds(),
                "success", err == nil,
        )

        return output, err</span>
}

// failExecution marks an execution as failed
func (e *Executor) failExecution(ctx context.Context, execution *workflow.Execution, err ...error) error <span class="cov0" title="0">{
        var errMsg string
        if len(err) &gt; 0 &amp;&amp; err[0] != nil </span><span class="cov0" title="0">{
                errMsg = err[0].Error()
        }</span> else<span class="cov0" title="0"> {
                errMsg = "execution failed"
        }</span>

        <span class="cov0" title="0">e.repo.UpdateExecutionStatus(ctx, execution.ID, workflow.ExecutionStatusFailed, nil, &amp;errMsg)

        // Broadcast execution failure
        if e.broadcaster != nil </span><span class="cov0" title="0">{
                e.broadcaster.BroadcastExecutionFailed(execution.TenantID, execution.WorkflowID, execution.ID, errMsg)
        }</span>

        <span class="cov0" title="0">if len(err) &gt; 0 &amp;&amp; err[0] != nil </span><span class="cov0" title="0">{
                return err[0]
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("%s", errMsg)</span>
}

// Helper functions

func buildNodeMap(nodes []workflow.Node) map[string]workflow.Node <span class="cov8" title="1">{
        nodeMap := make(map[string]workflow.Node)
        for _, node := range nodes </span><span class="cov8" title="1">{
                nodeMap[node.ID] = node
        }</span>
        <span class="cov8" title="1">return nodeMap</span>
}

func isTriggerNode(nodeType string) bool <span class="cov0" title="0">{
        return nodeType == string(workflow.NodeTypeTriggerWebhook) ||
                nodeType == string(workflow.NodeTypeTriggerSchedule)
}</span>

// topologicalSort performs a topological sort on the workflow DAG
func topologicalSort(nodes []workflow.Node, edges []workflow.Edge) ([]string, error) <span class="cov8" title="1">{
        // Build adjacency list and in-degree map
        inDegree := make(map[string]int)
        adjList := make(map[string][]string)

        for _, node := range nodes </span><span class="cov8" title="1">{
                inDegree[node.ID] = 0
                adjList[node.ID] = []string{}
        }</span>

        <span class="cov8" title="1">for _, edge := range edges </span><span class="cov8" title="1">{
                adjList[edge.Source] = append(adjList[edge.Source], edge.Target)
                inDegree[edge.Target]++
        }</span>

        // Find nodes with no incoming edges (start nodes)
        <span class="cov8" title="1">var queue []string
        for nodeID, degree := range inDegree </span><span class="cov8" title="1">{
                if degree == 0 </span><span class="cov8" title="1">{
                        queue = append(queue, nodeID)
                }</span>
        }

        // Process nodes in topological order
        <span class="cov8" title="1">var result []string
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                nodeID := queue[0]
                queue = queue[1:]
                result = append(result, nodeID)

                for _, neighbor := range adjList[nodeID] </span><span class="cov8" title="1">{
                        inDegree[neighbor]--
                        if inDegree[neighbor] == 0 </span><span class="cov8" title="1">{
                                queue = append(queue, neighbor)
                        }</span>
                }
        }

        // Check for cycles
        <span class="cov8" title="1">if len(result) != len(nodes) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("workflow contains cycles")
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// buildInputData creates the input data context for a node execution
func buildInputData(execCtx *ExecutionContext) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "trigger": execCtx.TriggerData,
                "steps":   execCtx.StepOutputs,
                "env": map[string]interface{}{
                        "tenant_id":    execCtx.TenantID,
                        "execution_id": execCtx.ExecutionID,
                        "workflow_id":  execCtx.WorkflowID,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package expression

import (
        "fmt"
        "reflect"

        "github.com/expr-lang/expr"
        "github.com/expr-lang/expr/vm"
)

// Evaluator evaluates boolean expressions with support for operators
type Evaluator struct {
        parser *Parser
}

// NewEvaluator creates a new expression evaluator
func NewEvaluator() *Evaluator <span class="cov8" title="1">{
        return &amp;Evaluator{
                parser: NewParser(),
        }
}</span>

// EvaluateCondition evaluates a boolean condition expression
// Returns true/false based on the evaluation result
func (e *Evaluator) EvaluateCondition(expression string, context map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov8" title="1">{
                return false, fmt.Errorf("empty expression")
        }</span>

        // Parse the expression
        <span class="cov8" title="1">parsed, err := e.parser.Parse(expression)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse expression: %w", err)
        }</span>

        // Prepare the expression for evaluation
        <span class="cov8" title="1">exprContent := parsed.Content

        // Compile and evaluate directly with context (expr library handles variable resolution)
        // No need to resolve template variables manually
        program, err := expr.Compile(exprContent, expr.Env(context), expr.AsBool())
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to compile expression: %w", err)
        }</span>

        // Execute the compiled expression
        <span class="cov8" title="1">result, err := expr.Run(program, context)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to evaluate expression: %w", err)
        }</span>

        // Convert result to boolean
        <span class="cov8" title="1">boolResult, ok := result.(bool)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("expression did not evaluate to boolean, got %T", result)
        }</span>

        <span class="cov8" title="1">return boolResult, nil</span>
}

// Evaluate evaluates any expression and returns the result
// This is more flexible than EvaluateCondition and can return any type
func (e *Evaluator) Evaluate(expression string, context map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty expression")
        }</span>

        // Parse the expression
        <span class="cov8" title="1">parsed, err := e.parser.Parse(expression)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse expression: %w", err)
        }</span>

        // Prepare the expression for evaluation
        <span class="cov8" title="1">exprContent := parsed.Content

        // Compile and evaluate directly with context (expr library handles variable resolution)
        program, err := expr.Compile(exprContent, expr.Env(context))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compile expression: %w", err)
        }</span>

        // Execute the compiled expression
        <span class="cov8" title="1">result, err := expr.Run(program, context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to evaluate expression: %w", err)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// EvaluateWithProgram evaluates a pre-compiled expression program
// This is more efficient when evaluating the same expression multiple times
func (e *Evaluator) EvaluateWithProgram(program *vm.Program, context map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        result, err := expr.Run(program, context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to evaluate expression: %w", err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// CompileExpression compiles an expression for later evaluation
// This is useful for caching compiled expressions
func (e *Evaluator) CompileExpression(expression string, context map[string]interface{}) (*vm.Program, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty expression")
        }</span>

        // Parse the expression
        <span class="cov8" title="1">parsed, err := e.parser.Parse(expression)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse expression: %w", err)
        }</span>

        // Compile the expression directly (expr library handles variable resolution at runtime)
        <span class="cov8" title="1">program, err := expr.Compile(parsed.Content, expr.Env(context))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compile expression: %w", err)
        }</span>

        <span class="cov8" title="1">return program, nil</span>
}

// ValidateCondition validates that an expression is a valid boolean condition
func (e *Evaluator) ValidateCondition(expression string) error <span class="cov8" title="1">{
        if expression == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("expression cannot be empty")
        }</span>

        // Parse the expression
        <span class="cov8" title="1">parsed, err := e.parser.Parse(expression)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse expression: %w", err)
        }</span>

        // Validate basic syntax
        <span class="cov8" title="1">if err := e.parser.ValidateExpression(expression); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try to compile with a mock context to catch syntax errors
        <span class="cov8" title="1">mockContext := map[string]interface{}{
                "steps": map[string]interface{}{
                        "test": map[string]interface{}{
                                "status": "success",
                                "output": map[string]interface{}{
                                        "count": 10,
                                        "data":  []interface{}{1, 2, 3},
                                },
                        },
                },
                "trigger": map[string]interface{}{
                        "body": map[string]interface{}{
                                "field": "value",
                        },
                },
                "env": map[string]interface{}{
                        "tenant_id": "test-tenant",
                },
        }

        // Try to compile the expression with mock context
        _, err = expr.Compile(parsed.Content, expr.Env(mockContext), expr.AsBool())
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid condition expression: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// EvaluateBooleanExpression is a convenience method for evaluating simple boolean expressions
// It handles common comparison operators and logical operators
func (e *Evaluator) EvaluateBooleanExpression(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        switch operator </span>{
        case "==", "equals":<span class="cov8" title="1">
                return compareEqual(left, right), nil</span>
        case "!=", "not_equals":<span class="cov8" title="1">
                return !compareEqual(left, right), nil</span>
        case "&gt;", "greater_than":<span class="cov8" title="1">
                return compareGreater(left, right)</span>
        case "&gt;=", "greater_or_equal":<span class="cov8" title="1">
                result, err := compareGreater(left, right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">return result || compareEqual(left, right), nil</span>
        case "&lt;", "less_than":<span class="cov8" title="1">
                return compareLess(left, right)</span>
        case "&lt;=", "less_or_equal":<span class="cov8" title="1">
                result, err := compareLess(left, right)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">return result || compareEqual(left, right), nil</span>
        case "contains":<span class="cov8" title="1">
                return compareContains(left, right)</span>
        case "starts_with":<span class="cov8" title="1">
                return compareStartsWith(left, right)</span>
        case "ends_with":<span class="cov8" title="1">
                return compareEndsWith(left, right)</span>
        default:<span class="cov8" title="1">
                return false, fmt.Errorf("unsupported operator: %s", operator)</span>
        }
}

// Helper comparison functions

func compareEqual(left, right interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(left, right)
}</span>

func compareGreater(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        leftNum, err := toFloat64(left)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">rightNum, err := toFloat64(right)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return leftNum &gt; rightNum, nil</span>
}

func compareLess(left, right interface{}) (bool, error) <span class="cov8" title="1">{
        leftNum, err := toFloat64(left)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">rightNum, err := toFloat64(right)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return leftNum &lt; rightNum, nil</span>
}

func compareContains(haystack, needle interface{}) (bool, error) <span class="cov8" title="1">{
        haystackStr, ok := haystack.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("contains operator requires string haystack, got %T", haystack)
        }</span>
        <span class="cov8" title="1">needleStr := fmt.Sprintf("%v", needle)
        return contains(haystackStr, needleStr), nil</span>
}

func compareStartsWith(str, prefix interface{}) (bool, error) <span class="cov8" title="1">{
        strVal, ok := str.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("starts_with operator requires string, got %T", str)
        }</span>
        <span class="cov8" title="1">prefixStr := fmt.Sprintf("%v", prefix)
        return startsWith(strVal, prefixStr), nil</span>
}

func compareEndsWith(str, suffix interface{}) (bool, error) <span class="cov8" title="1">{
        strVal, ok := str.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ends_with operator requires string, got %T", str)
        }</span>
        <span class="cov8" title="1">suffixStr := fmt.Sprintf("%v", suffix)
        return endsWith(strVal, suffixStr), nil</span>
}

// Helper conversion functions

func toFloat64(v interface{}) (float64, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case float64:<span class="cov0" title="0">
                return val, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int:<span class="cov8" title="1">
                return float64(val), nil</span>
        case int8:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int16:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint8:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint16:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case uint64:<span class="cov0" title="0">
                return float64(val), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert %T to number", v)</span>
        }
}

// String helper functions
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; indexOf(s, substr) &gt;= 0
}</span>

func indexOf(s, substr string) int <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func startsWith(s, prefix string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix
}</span>

func endsWith(s, suffix string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(suffix) &amp;&amp; s[len(s)-len(suffix):] == suffix
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package expression

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

var (
        // templateRegex matches {{expression}} patterns
        templateRegex = regexp.MustCompile(`\{\{([^}]+)\}\}`)
)

// Expression represents a parsed expression
type Expression struct {
        Raw        string
        IsTemplate bool   // true if wrapped in {{...}}
        Content    string // the actual expression content without {{}}
}

// Parser handles parsing of condition expressions
type Parser struct{}

// NewParser creates a new expression parser
func NewParser() *Parser <span class="cov8" title="1">{
        return &amp;Parser{}
}</span>

// Parse parses an expression string
// Supports both template syntax {{expr}} and raw expressions
func (p *Parser) Parse(expr string) (*Expression, error) <span class="cov8" title="1">{
        if expr == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty expression")
        }</span>

        <span class="cov8" title="1">expr = strings.TrimSpace(expr)

        // Check if expression is wrapped in {{...}}
        if matches := templateRegex.FindStringSubmatch(expr); matches != nil </span><span class="cov8" title="1">{
                return &amp;Expression{
                        Raw:        expr,
                        IsTemplate: true,
                        Content:    strings.TrimSpace(matches[1]),
                }, nil
        }</span>

        // Raw expression without template syntax
        <span class="cov8" title="1">return &amp;Expression{
                Raw:        expr,
                IsTemplate: false,
                Content:    expr,
        }, nil</span>
}

// ExtractPaths extracts all variable paths from an expression
// Returns paths like "steps.step1.output", "trigger.body.field", etc.
func (p *Parser) ExtractPaths(expr string) []string <span class="cov8" title="1">{
        var paths []string
        seen := make(map[string]bool)

        // Find all {{...}} patterns
        matches := templateRegex.FindAllStringSubmatch(expr, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        content := strings.TrimSpace(match[1])
                        // Extract variable paths (looking for dotted paths)
                        vars := extractVariablePaths(content)
                        for _, v := range vars </span><span class="cov8" title="1">{
                                if !seen[v] </span><span class="cov8" title="1">{
                                        paths = append(paths, v)
                                        seen[v] = true
                                }</span>
                        }
                }
        }

        // Also check raw expression if no templates found
        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov0" title="0">{
                vars := extractVariablePaths(expr)
                for _, v := range vars </span><span class="cov0" title="0">{
                        if !seen[v] </span><span class="cov0" title="0">{
                                paths = append(paths, v)
                                seen[v] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">return paths</span>
}

// extractVariablePaths extracts variable paths from expression content
// Looks for patterns like: steps.step1.output, trigger.body.field, env.tenant_id
func extractVariablePaths(expr string) []string <span class="cov8" title="1">{
        var paths []string

        // Regex to match variable paths: word.word.word...
        // Handles array indexing: steps.step1.output[0].name
        pathRegex := regexp.MustCompile(`\b((?:steps|trigger|env)(?:\.[a-zA-Z_][a-zA-Z0-9_]*(?:\[\d+\])?)+)`)
        matches := pathRegex.FindAllStringSubmatch(expr, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        paths = append(paths, match[1])
                }</span>
        }

        <span class="cov8" title="1">return paths</span>
}

// ValidateExpression performs basic syntax validation
func (p *Parser) ValidateExpression(expr string) error <span class="cov8" title="1">{
        if expr == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("expression cannot be empty")
        }</span>

        <span class="cov8" title="1">parsed, err := p.Parse(expr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check for balanced parentheses
        <span class="cov8" title="1">if !isBalanced(parsed.Content, '(', ')') </span><span class="cov8" title="1">{
                return fmt.Errorf("unbalanced parentheses in expression")
        }</span>

        // Check for balanced brackets
        <span class="cov8" title="1">if !isBalanced(parsed.Content, '[', ']') </span><span class="cov8" title="1">{
                return fmt.Errorf("unbalanced brackets in expression")
        }</span>

        // Check for valid operators (basic check)
        <span class="cov8" title="1">invalidChars := []string{"{{", "}}", ";;", ".."}
        for _, chars := range invalidChars </span><span class="cov8" title="1">{
                if strings.Contains(parsed.Content, chars) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid characters in expression: %s", chars)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isBalanced checks if brackets/parentheses are balanced
func isBalanced(expr string, open, close rune) bool <span class="cov8" title="1">{
        count := 0
        for _, ch := range expr </span><span class="cov8" title="1">{
                if ch == open </span><span class="cov8" title="1">{
                        count++
                }</span> else<span class="cov8" title="1"> if ch == close </span><span class="cov8" title="1">{
                        count--
                        if count &lt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return count == 0</span>
}

// BuildContext creates an evaluation context from execution data
func BuildContext(trigger map[string]interface{}, steps map[string]interface{}, env map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        context := make(map[string]interface{})

        if trigger != nil </span><span class="cov8" title="1">{
                context["trigger"] = trigger
        }</span> else<span class="cov8" title="1"> {
                context["trigger"] = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">if steps != nil </span><span class="cov8" title="1">{
                context["steps"] = steps
        }</span> else<span class="cov8" title="1"> {
                context["steps"] = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">if env != nil </span><span class="cov8" title="1">{
                context["env"] = env
        }</span> else<span class="cov8" title="1"> {
                context["env"] = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">return context</span>
}

// ResolveTemplateVariables resolves all {{...}} variables in a string
// This is useful for simple template variable resolution without full expression evaluation
func ResolveTemplateVariables(template string, context map[string]interface{}) (string, error) <span class="cov8" title="1">{
        result := template

        matches := templateRegex.FindAllStringSubmatch(template, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        path := strings.TrimSpace(match[1])
                        value, err := GetValueByPath(context, path)
                        if err != nil </span><span class="cov0" title="0">{
                                // Return original if path not found
                                continue</span>
                        }

                        // Convert value to string
                        <span class="cov8" title="1">strValue := toString(value)
                        result = strings.Replace(result, match[0], strValue, 1)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetValueByPath retrieves a value from nested maps using dot notation
// Supports array indexing: "steps.step1.output[0].name"
func GetValueByPath(data map[string]interface{}, path string) (interface{}, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return data, nil
        }</span>

        // Split path by dots, but preserve array indexes
        <span class="cov8" title="1">parts := splitPathSafe(path)
        current := interface{}(data)

        for i, part := range parts </span><span class="cov8" title="1">{
                // Check for array indexing
                if strings.Contains(part, "[") &amp;&amp; strings.Contains(part, "]") </span><span class="cov8" title="1">{
                        // Handle array access like "users[0]"
                        bracketIdx := strings.Index(part, "[")
                        key := part[:bracketIdx]
                        indexPart := part[bracketIdx:]

                        // Get the field first
                        switch v := current.(type) </span>{
                        case map[string]interface{}:<span class="cov8" title="1">
                                current = v[key]</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("cannot access key '%s' on non-object at position %d", key, i)</span>
                        }

                        // Extract all array indices (supports multiple levels like [0][1])
                        <span class="cov8" title="1">indices := extractArrayIndices(indexPart)
                        for _, idx := range indices </span><span class="cov8" title="1">{
                                switch arr := current.(type) </span>{
                                case []interface{}:<span class="cov8" title="1">
                                        if idx &lt; 0 || idx &gt;= len(arr) </span><span class="cov8" title="1">{
                                                return nil, fmt.Errorf("array index %d out of bounds at '%s'", idx, key)
                                        }</span>
                                        <span class="cov8" title="1">current = arr[idx]</span>
                                default:<span class="cov0" title="0">
                                        return nil, fmt.Errorf("cannot index non-array type at '%s'", key)</span>
                                }
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // Regular object property access
                <span class="cov8" title="1">switch v := current.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        var exists bool
                        current, exists = v[part]
                        if !exists </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("key '%s' not found at path position %d", part, i)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("cannot traverse into non-object type at '%s'", part)</span>
                }
        }

        <span class="cov8" title="1">return current, nil</span>
}

// splitPathSafe splits a path by dots while preserving array indices
func splitPathSafe(path string) []string <span class="cov8" title="1">{
        var parts []string
        var current strings.Builder
        inBracket := false

        for i := 0; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                char := path[i]

                switch char </span>{
                case '[':<span class="cov8" title="1">
                        inBracket = true
                        current.WriteByte(char)</span>
                case ']':<span class="cov8" title="1">
                        inBracket = false
                        current.WriteByte(char)</span>
                case '.':<span class="cov8" title="1">
                        if !inBracket </span><span class="cov8" title="1">{
                                if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                                        parts = append(parts, current.String())
                                        current.Reset()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                current.WriteByte(char)
                        }</span>
                default:<span class="cov8" title="1">
                        current.WriteByte(char)</span>
                }
        }

        <span class="cov8" title="1">if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                parts = append(parts, current.String())
        }</span>

        <span class="cov8" title="1">return parts</span>
}

// extractArrayIndices extracts numeric indices from [0][1] format
func extractArrayIndices(indexPart string) []int <span class="cov8" title="1">{
        var indices []int
        indexRegex := regexp.MustCompile(`\[(\d+)\]`)
        matches := indexRegex.FindAllStringSubmatch(indexPart, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt; 1 </span><span class="cov8" title="1">{
                        var idx int
                        fmt.Sscanf(match[1], "%d", &amp;idx)
                        indices = append(indices, idx)
                }</span>
        }

        <span class="cov8" title="1">return indices</span>
}

// toString converts any value to string representation
func toString(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case float32, float64:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        case bool:<span class="cov0" title="0">
                return fmt.Sprintf("%t", v)</span>
        case nil:<span class="cov0" title="0">
                return ""</span>
        default:<span class="cov0" title="0">
                // For complex types, marshal to JSON
                if bytes, err := json.Marshal(v); err == nil </span><span class="cov0" title="0">{
                        return string(bytes)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%v", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package executor

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/gorax/gorax/internal/executor/actions"
        "github.com/gorax/gorax/internal/workflow"
)

const (
        // DefaultMaxIterations is the default maximum number of loop iterations
        DefaultMaxIterations = 1000
        // ErrorStrategyContinue continues loop execution on error
        ErrorStrategyContinue = "continue"
        // ErrorStrategyStop stops loop execution on error
        ErrorStrategyStop = "stop"
)

// LoopResult represents the result of a loop execution
type LoopResult struct {
        IterationCount int                  `json:"iteration_count"`
        Iterations     []IterationResult    `json:"iterations"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// IterationResult represents the result of a single iteration
type IterationResult struct {
        Index  int                    `json:"index"`
        Item   interface{}            `json:"item"`
        Output map[string]interface{} `json:"output,omitempty"`
        Error  *string                `json:"error,omitempty"`
}

// loopExecutor handles loop execution logic
type loopExecutor struct {
        mainExecutor *Executor
}

// executeLoop executes a loop node with for-each semantics
func (le *loopExecutor) executeLoop(
        ctx context.Context,
        config workflow.LoopActionConfig,
        execCtx *ExecutionContext,
        bodyNodes []workflow.Node,
        bodyEdges []workflow.Edge,
) (interface{}, error) <span class="cov8" title="1">{
        // Validate configuration
        if err := le.validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid loop configuration: %w", err)
        }</span>

        // Resolve source array from execution context
        <span class="cov8" title="1">sourceArray, err := le.resolveSourceArray(config.Source, execCtx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to resolve source array: %w", err)
        }</span>

        // Apply max iterations limit
        <span class="cov8" title="1">maxIterations := config.MaxIterations
        if maxIterations &lt;= 0 </span><span class="cov8" title="1">{
                maxIterations = DefaultMaxIterations
        }</span>

        // Check if array exceeds max iterations
        <span class="cov8" title="1">arrayLen := len(sourceArray)
        if arrayLen &gt; maxIterations </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("array length %d exceeds max iterations limit %d", arrayLen, maxIterations)
        }</span>

        // Determine error handling strategy
        <span class="cov8" title="1">onError := config.OnError
        if onError == "" </span><span class="cov0" title="0">{
                onError = ErrorStrategyStop
        }</span>

        // Execute loop iterations
        <span class="cov8" title="1">result := &amp;LoopResult{
                IterationCount: arrayLen,
                Iterations:     make([]IterationResult, 0, arrayLen),
                Metadata: map[string]interface{}{
                        "item_variable":  config.ItemVariable,
                        "index_variable": config.IndexVariable,
                        "on_error":       onError,
                },
        }

        for i, item := range sourceArray </span><span class="cov8" title="1">{
                iterationResult, err := le.executeIteration(
                        ctx,
                        i,
                        item,
                        config,
                        execCtx,
                        bodyNodes,
                        bodyEdges,
                )

                if err != nil </span><span class="cov0" title="0">{
                        if onError == ErrorStrategyStop </span><span class="cov0" title="0">{
                                // Stop on first error
                                return nil, fmt.Errorf("loop iteration %d failed: %w", i, err)
                        }</span>
                        // Continue on error - record error but continue
                        <span class="cov0" title="0">errMsg := err.Error()
                        iterationResult.Error = &amp;errMsg</span>
                }

                <span class="cov8" title="1">result.Iterations = append(result.Iterations, *iterationResult)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// validateConfig validates loop configuration
func (le *loopExecutor) validateConfig(config workflow.LoopActionConfig) error <span class="cov8" title="1">{
        if config.Source == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("source is required")
        }</span>
        <span class="cov8" title="1">if config.ItemVariable == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("item_variable is required")
        }</span>
        <span class="cov8" title="1">if config.OnError != "" &amp;&amp; config.OnError != ErrorStrategyContinue &amp;&amp; config.OnError != ErrorStrategyStop </span><span class="cov0" title="0">{
                return fmt.Errorf("on_error must be 'continue' or 'stop', got '%s'", config.OnError)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// resolveSourceArray resolves the source expression to an array
func (le *loopExecutor) resolveSourceArray(source string, execCtx *ExecutionContext) ([]interface{}, error) <span class="cov8" title="1">{
        // Build context for path resolution
        contextData := buildInterpolationContext(execCtx)

        // Remove ${} wrapper if present
        path := source
        if strings.HasPrefix(path, "${") &amp;&amp; strings.HasSuffix(path, "}") </span><span class="cov8" title="1">{
                path = path[2 : len(path)-1]
        }</span>

        // Resolve the path
        <span class="cov8" title="1">value, err := actions.GetValueByPath(contextData, path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("source path not found: %w", err)
        }</span>

        // Ensure value is an array
        <span class="cov8" title="1">array, ok := value.([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("source is not an array, got %T", value)
        }</span>

        <span class="cov8" title="1">return array, nil</span>
}

// executeIteration executes a single loop iteration
func (le *loopExecutor) executeIteration(
        ctx context.Context,
        index int,
        item interface{},
        config workflow.LoopActionConfig,
        execCtx *ExecutionContext,
        bodyNodes []workflow.Node,
        bodyEdges []workflow.Edge,
) (*IterationResult, error) <span class="cov8" title="1">{
        // Create iteration-specific execution context
        iterationCtx := le.createIterationContext(index, item, config, execCtx)

        // Execute body nodes for this iteration
        outputs, err := le.executeBodyNodes(ctx, bodyNodes, bodyEdges, iterationCtx)

        result := &amp;IterationResult{
                Index:  index,
                Item:   item,
                Output: outputs,
        }

        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// createIterationContext creates an execution context for a single iteration
func (le *loopExecutor) createIterationContext(
        index int,
        item interface{},
        config workflow.LoopActionConfig,
        parentCtx *ExecutionContext,
) *ExecutionContext <span class="cov8" title="1">{
        // Create a copy of step outputs
        stepOutputs := make(map[string]interface{})
        for k, v := range parentCtx.StepOutputs </span><span class="cov8" title="1">{
                stepOutputs[k] = v
        }</span>

        // Add loop variables to the context
        <span class="cov8" title="1">stepOutputs[config.ItemVariable] = item
        if config.IndexVariable != "" </span><span class="cov8" title="1">{
                stepOutputs[config.IndexVariable] = index
        }</span>

        <span class="cov8" title="1">return &amp;ExecutionContext{
                TenantID:    parentCtx.TenantID,
                ExecutionID: parentCtx.ExecutionID,
                WorkflowID:  parentCtx.WorkflowID,
                TriggerData: parentCtx.TriggerData,
                StepOutputs: stepOutputs,
        }</span>
}

// executeBodyNodes executes all nodes in the loop body
func (le *loopExecutor) executeBodyNodes(
        ctx context.Context,
        nodes []workflow.Node,
        edges []workflow.Edge,
        iterationCtx *ExecutionContext,
) (map[string]interface{}, error) <span class="cov8" title="1">{
        // If no nodes in body, return empty output
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        // Build execution order using topological sort
        <span class="cov8" title="1">executionOrder, err := topologicalSort(nodes, edges)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to determine execution order for loop body: %w", err)
        }</span>

        // Build node map for quick lookup
        <span class="cov8" title="1">nodeMap := buildNodeMap(nodes)

        // Execute nodes in order
        outputs := make(map[string]interface{})
        for _, nodeID := range executionOrder </span><span class="cov8" title="1">{
                node, exists := nodeMap[nodeID]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Execute the node
                <span class="cov8" title="1">var output interface{}
                var execErr error

                // Use the main executor if available, otherwise execute directly
                if le.mainExecutor != nil </span><span class="cov0" title="0">{
                        output, execErr = le.mainExecutor.executeNode(ctx, node, iterationCtx)
                }</span> else<span class="cov8" title="1"> {
                        // For testing without full executor, skip actual execution
                        output = map[string]interface{}{"status": "executed"}
                        execErr = nil
                }</span>

                <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                        return outputs, fmt.Errorf("node %s failed: %w", nodeID, execErr)
                }</span>

                // Store output for downstream nodes
                <span class="cov8" title="1">iterationCtx.StepOutputs[nodeID] = output
                outputs[nodeID] = output</span>
        }

        <span class="cov8" title="1">return outputs, nil</span>
}

// executeLoopAction is the main entry point for loop execution
func (e *Executor) executeLoopAction(
        ctx context.Context,
        node workflow.Node,
        execCtx *ExecutionContext,
        definition *workflow.WorkflowDefinition,
) (interface{}, error) <span class="cov0" title="0">{
        // Parse loop configuration
        var config workflow.LoopActionConfig
        if err := parseNodeConfig(node, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse loop configuration: %w", err)
        }</span>

        // Find loop body nodes (nodes connected after this loop node)
        <span class="cov0" title="0">bodyNodes, bodyEdges := e.findLoopBody(node.ID, definition)

        // Create loop executor with reference to main executor
        loopExec := &amp;loopExecutor{
                mainExecutor: e,
        }

        // Execute the loop
        result, err := loopExec.executeLoop(ctx, config, execCtx, bodyNodes, bodyEdges)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// findLoopBody finds all nodes that are part of the loop body
// For now, this returns all direct children of the loop node
// TODO: Implement proper loop body detection (nodes between loop start and loop end markers)
func (e *Executor) findLoopBody(loopNodeID string, definition *workflow.WorkflowDefinition) ([]workflow.Node, []workflow.Edge) <span class="cov0" title="0">{
        // Find all nodes directly connected to this loop node
        var bodyNodeIDs []string
        for _, edge := range definition.Edges </span><span class="cov0" title="0">{
                if edge.Source == loopNodeID </span><span class="cov0" title="0">{
                        bodyNodeIDs = append(bodyNodeIDs, edge.Target)
                }</span>
        }

        // Collect body nodes
        <span class="cov0" title="0">var bodyNodes []workflow.Node
        bodyNodeMap := make(map[string]bool)
        for _, nodeID := range bodyNodeIDs </span><span class="cov0" title="0">{
                bodyNodeMap[nodeID] = true
        }</span>

        <span class="cov0" title="0">for _, node := range definition.Nodes </span><span class="cov0" title="0">{
                if bodyNodeMap[node.ID] </span><span class="cov0" title="0">{
                        bodyNodes = append(bodyNodes, node)
                }</span>
        }

        // Collect edges between body nodes
        <span class="cov0" title="0">var bodyEdges []workflow.Edge
        for _, edge := range definition.Edges </span><span class="cov0" title="0">{
                if bodyNodeMap[edge.Source] &amp;&amp; bodyNodeMap[edge.Target] </span><span class="cov0" title="0">{
                        bodyEdges = append(bodyEdges, edge)
                }</span>
        }

        <span class="cov0" title="0">return bodyNodes, bodyEdges</span>
}

// parseNodeConfig parses node configuration into a target struct
func parseNodeConfig(node workflow.Node, target interface{}) error <span class="cov0" title="0">{
        configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing configuration")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(configData, target)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package executor

import (
        "context"
        "fmt"
        "log/slog"
        "math"
        "math/rand"
        "time"
)

// RetryConfig holds configuration for retry behavior
type RetryConfig struct {
        // MaxRetries is the maximum number of retry attempts (0 means no retries)
        MaxRetries int
        // InitialBackoff is the initial backoff duration
        InitialBackoff time.Duration
        // MaxBackoff is the maximum backoff duration
        MaxBackoff time.Duration
        // BackoffMultiplier is the multiplier for exponential backoff
        BackoffMultiplier float64
        // Jitter adds randomness to backoff to prevent thundering herd
        Jitter bool
}

// DefaultRetryConfig returns the default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov8" title="1">{
        return RetryConfig{
                MaxRetries:        3,
                InitialBackoff:    1 * time.Second,
                MaxBackoff:        30 * time.Second,
                BackoffMultiplier: 2.0,
                Jitter:            true,
        }
}</span>

// NodeRetryConfig extends RetryConfig with node-specific settings
type NodeRetryConfig struct {
        RetryConfig
        // Enabled determines if retry is enabled for this node
        Enabled bool
        // RetryableStatusCodes for HTTP actions (optional)
        RetryableStatusCodes []int
}

// DefaultNodeRetryConfig returns the default node retry configuration
func DefaultNodeRetryConfig() NodeRetryConfig <span class="cov8" title="1">{
        return NodeRetryConfig{
                RetryConfig:          DefaultRetryConfig(),
                Enabled:              true,
                RetryableStatusCodes: []int{408, 429, 500, 502, 503, 504},
        }
}</span>

// RetryableOperation is a function that can be retried
type RetryableOperation func(ctx context.Context, attempt int) error

// RetryStrategy handles retry logic with exponential backoff
type RetryStrategy struct {
        config RetryConfig
        logger *slog.Logger
}

// NewRetryStrategy creates a new retry strategy
func NewRetryStrategy(config RetryConfig, logger *slog.Logger) *RetryStrategy <span class="cov8" title="1">{
        return &amp;RetryStrategy{
                config: config,
                logger: logger,
        }
}</span>

// Execute runs an operation with retry logic
func (r *RetryStrategy) Execute(ctx context.Context, operation RetryableOperation) error <span class="cov8" title="1">{
        var lastErr error

        for attempt := 0; attempt &lt;= r.config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                // Execute the operation
                err := operation(ctx, attempt)
                if err == nil </span><span class="cov8" title="1">{
                        // Success
                        if attempt &gt; 0 </span><span class="cov8" title="1">{
                                r.logger.Info("operation succeeded after retry",
                                        "attempt", attempt,
                                        "max_retries", r.config.MaxRetries,
                                )
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">lastErr = err

                // Check if we should retry
                if attempt &gt;= r.config.MaxRetries </span><span class="cov8" title="1">{
                        r.logger.Error("operation failed after all retries",
                                "attempts", attempt+1,
                                "max_retries", r.config.MaxRetries,
                                "error", err,
                        )
                        break</span>
                }

                // Check if error is retryable
                <span class="cov8" title="1">if !ShouldRetry(err, attempt, r.config.MaxRetries) </span><span class="cov8" title="1">{
                        r.logger.Info("operation failed with non-retryable error",
                                "attempt", attempt+1,
                                "error", err,
                        )
                        return err
                }</span>

                // Calculate backoff duration
                <span class="cov8" title="1">backoff := r.calculateBackoff(attempt)

                r.logger.Info("operation failed, retrying",
                        "attempt", attempt+1,
                        "max_retries", r.config.MaxRetries,
                        "backoff", backoff,
                        "error", err,
                )

                // Wait for backoff duration or context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return fmt.Errorf("retry cancelled: %w", ctx.Err())</span>
                case &lt;-time.After(backoff):<span class="cov8" title="1"></span>
                        // Continue to next retry
                }
        }

        <span class="cov8" title="1">return lastErr</span>
}

// ExecuteWithResult runs an operation that returns a result with retry logic
func (r *RetryStrategy) ExecuteWithResult(ctx context.Context, operation func(ctx context.Context, attempt int) (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        var lastErr error
        var result interface{}

        for attempt := 0; attempt &lt;= r.config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                // Execute the operation
                res, err := operation(ctx, attempt)
                if err == nil </span><span class="cov8" title="1">{
                        // Success
                        if attempt &gt; 0 </span><span class="cov8" title="1">{
                                r.logger.Info("operation succeeded after retry",
                                        "attempt", attempt,
                                        "max_retries", r.config.MaxRetries,
                                )
                        }</span>
                        <span class="cov8" title="1">return res, nil</span>
                }

                <span class="cov8" title="1">lastErr = err
                result = res

                // Check if we should retry
                if attempt &gt;= r.config.MaxRetries </span><span class="cov0" title="0">{
                        r.logger.Error("operation failed after all retries",
                                "attempts", attempt+1,
                                "max_retries", r.config.MaxRetries,
                                "error", err,
                        )
                        break</span>
                }

                // Check if error is retryable
                <span class="cov8" title="1">if !ShouldRetry(err, attempt, r.config.MaxRetries) </span><span class="cov0" title="0">{
                        r.logger.Info("operation failed with non-retryable error",
                                "attempt", attempt+1,
                                "error", err,
                        )
                        return result, err
                }</span>

                // Calculate backoff duration
                <span class="cov8" title="1">backoff := r.calculateBackoff(attempt)

                r.logger.Info("operation failed, retrying",
                        "attempt", attempt+1,
                        "max_retries", r.config.MaxRetries,
                        "backoff", backoff,
                        "error", err,
                )

                // Wait for backoff duration or context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return result, fmt.Errorf("retry cancelled: %w", ctx.Err())</span>
                case &lt;-time.After(backoff):<span class="cov8" title="1"></span>
                        // Continue to next retry
                }
        }

        <span class="cov0" title="0">return result, lastErr</span>
}

// calculateBackoff calculates the backoff duration for the given attempt
func (r *RetryStrategy) calculateBackoff(attempt int) time.Duration <span class="cov8" title="1">{
        // Calculate exponential backoff: initialBackoff * (multiplier ^ attempt)
        backoff := float64(r.config.InitialBackoff) * math.Pow(r.config.BackoffMultiplier, float64(attempt))

        // Apply max backoff limit
        if backoff &gt; float64(r.config.MaxBackoff) </span><span class="cov8" title="1">{
                backoff = float64(r.config.MaxBackoff)
        }</span>

        <span class="cov8" title="1">duration := time.Duration(backoff)

        // Add jitter if enabled (random variation of 25%)
        if r.config.Jitter </span><span class="cov8" title="1">{
                jitter := float64(duration) * 0.25
                variation := (rand.Float64() * 2 * jitter) - jitter // Random value between -jitter and +jitter
                duration = time.Duration(float64(duration) + variation)
        }</span>

        <span class="cov8" title="1">return duration</span>
}

// GetAttemptNumber returns the current attempt number (0-indexed)
func GetAttemptNumber(ctx context.Context) int <span class="cov0" title="0">{
        if attempt, ok := ctx.Value(attemptKey).(int); ok </span><span class="cov0" title="0">{
                return attempt
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// attemptKey is the context key for storing retry attempt number
type contextKey string

const attemptKey contextKey = "retry_attempt"

// withAttempt returns a context with the attempt number
func withAttempt(ctx context.Context, attempt int) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, attemptKey, attempt)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package executor

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/gorax/gorax/internal/executor/actions"
        "github.com/gorax/gorax/internal/integrations/slack"
        "github.com/gorax/gorax/internal/workflow"
)

// executeSlackSendMessageAction executes a Slack send message action
func (e *Executor) executeSlackSendMessageAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov8" title="1">{
        // Check if credential service is available
        if e.credentialService == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential service not available for Slack actions")
        }</span>

        // Extract config from node data
        <span class="cov8" title="1">configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for Slack send message action")
        }</span>

        // Parse node config
        <span class="cov8" title="1">var config slack.SendMessageConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse Slack send message config: %w", err)
        }</span>

        // Create Slack action
        <span class="cov8" title="1">action := slack.NewSendMessageAction(e.credentialService)

        // Build execution context
        context := buildInterpolationContext(execCtx)

        // Create action input
        input := actions.NewActionInput(config, context)

        // Execute action
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.Data, nil</span>
}

// executeSlackSendDMAction executes a Slack send direct message action
func (e *Executor) executeSlackSendDMAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov8" title="1">{
        // Check if credential service is available
        if e.credentialService == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential service not available for Slack actions")
        }</span>

        // Extract config from node data
        <span class="cov8" title="1">configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing config for Slack send DM action")
        }</span>

        // Parse node config
        <span class="cov8" title="1">var config slack.SendDMConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Slack send DM config: %w", err)
        }</span>

        // Create Slack action
        <span class="cov8" title="1">action := slack.NewSendDMAction(e.credentialService)

        // Build execution context
        context := buildInterpolationContext(execCtx)

        // Create action input
        input := actions.NewActionInput(config, context)

        // Execute action
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.Data, nil</span>
}

// executeSlackUpdateMessageAction executes a Slack update message action
func (e *Executor) executeSlackUpdateMessageAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov8" title="1">{
        // Check if credential service is available
        if e.credentialService == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential service not available for Slack actions")
        }</span>

        // Extract config from node data
        <span class="cov8" title="1">configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for Slack update message action")
        }</span>

        // Parse node config
        <span class="cov8" title="1">var config slack.UpdateMessageConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Slack update message config: %w", err)
        }</span>

        // Create Slack action
        <span class="cov8" title="1">action := slack.NewUpdateMessageAction(e.credentialService)

        // Build execution context
        context := buildInterpolationContext(execCtx)

        // Create action input
        input := actions.NewActionInput(config, context)

        // Execute action
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.Data, nil</span>
}

// executeSlackAddReactionAction executes a Slack add reaction action
func (e *Executor) executeSlackAddReactionAction(ctx context.Context, node workflow.Node, execCtx *ExecutionContext) (interface{}, error) <span class="cov8" title="1">{
        // Check if credential service is available
        if e.credentialService == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential service not available for Slack actions")
        }</span>

        // Extract config from node data
        <span class="cov8" title="1">configData := node.Data.Config
        if len(configData) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing config for Slack add reaction action")
        }</span>

        // Parse node config
        <span class="cov8" title="1">var config slack.AddReactionConfig
        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Slack add reaction config: %w", err)
        }</span>

        // Create Slack action
        <span class="cov8" title="1">action := slack.NewAddReactionAction(e.credentialService)

        // Build execution context
        context := buildInterpolationContext(execCtx)

        // Create action input
        input := actions.NewActionInput(config, context)

        // Execute action
        output, err := action.Execute(ctx, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package slack

import (
        "context"
        "fmt"
        "strings"

        "github.com/gorax/gorax/internal/credential"
        "github.com/gorax/gorax/internal/executor/actions"
)

// AddReactionAction implements the Slack AddReaction action
type AddReactionAction struct {
        credentialService credential.Service
        baseURL           string // For testing, defaults to DefaultBaseURL
}

// NewAddReactionAction creates a new AddReaction action
func NewAddReactionAction(credentialService credential.Service) *AddReactionAction <span class="cov8" title="1">{
        return &amp;AddReactionAction{
                credentialService: credentialService,
                baseURL:           DefaultBaseURL,
        }
}</span>

// Execute implements the Action interface
func (a *AddReactionAction) Execute(ctx context.Context, input *actions.ActionInput) (*actions.ActionOutput, error) <span class="cov8" title="1">{
        // Parse config
        config, ok := input.Config.(AddReactionConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config type: expected AddReactionConfig")
        }</span>

        // Validate config
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Extract tenant_id and credential_id from context
        <span class="cov8" title="1">tenantID, err := extractString(input.Context, "env.tenant_id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant_id is required in context: %w", err)
        }</span>

        <span class="cov8" title="1">credentialID, err := extractString(input.Context, "credential_id")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential_id is required in context: %w", err)
        }</span>

        // Retrieve and decrypt credential
        <span class="cov8" title="1">decryptedCred, err := a.credentialService.GetValue(ctx, tenantID, credentialID, "system")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve credential: %w", err)
        }</span>

        // Extract access_token from credential
        <span class="cov8" title="1">accessToken, ok := decryptedCred.Value["access_token"].(string)
        if !ok || accessToken == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access_token not found in credential")
        }</span>

        // Create Slack client
        <span class="cov8" title="1">client, err := NewClient(accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        // Override base URL if set (for testing)
        <span class="cov8" title="1">if a.baseURL != "" </span><span class="cov8" title="1">{
                client.baseURL = a.baseURL
        }</span>

        // Normalize emoji name (remove colons if present)
        <span class="cov8" title="1">emoji := normalizeEmoji(config.Emoji)

        // Add reaction (client already handles "already_reacted" as success)
        err = client.AddReaction(ctx, config.Channel, config.Timestamp, emoji)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to add reaction: %w", err)
        }</span>

        // Build result
        <span class="cov8" title="1">result := &amp;AddReactionResult{
                OK:        true,
                Channel:   config.Channel,
                Timestamp: config.Timestamp,
                Emoji:     emoji,
        }

        // Create output
        output := actions.NewActionOutput(result)
        output.WithMetadata("channel", config.Channel)
        output.WithMetadata("timestamp", config.Timestamp)
        output.WithMetadata("emoji", emoji)

        return output, nil</span>
}

// normalizeEmoji removes leading and trailing colons from emoji names
// Slack accepts emoji names without colons, but users often include them
func normalizeEmoji(emoji string) string <span class="cov8" title="1">{
        return strings.Trim(emoji, ":")
}</span>

// AddReactionResult represents the result of adding a reaction to a Slack message
type AddReactionResult struct {
        OK        bool   `json:"ok"`
        Channel   string `json:"channel"`
        Timestamp string `json:"timestamp"`
        Emoji     string `json:"emoji"`
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package slack

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "time"
)

const (
        // DefaultBaseURL is the base URL for Slack API
        DefaultBaseURL = "https://slack.com/api"

        // DefaultTimeout is the default HTTP client timeout
        DefaultTimeout = 30 * time.Second

        // DefaultMaxRetries is the default number of retry attempts
        DefaultMaxRetries = 3

        // DefaultRetryDelay is the default delay between retries
        DefaultRetryDelay = 1 * time.Second
)

// Client is a Slack API client
type Client struct {
        accessToken string
        baseURL     string
        httpClient  *http.Client
        maxRetries  int
        retryDelay  time.Duration
}

// NewClient creates a new Slack API client
func NewClient(accessToken string) (*Client, error) <span class="cov8" title="1">{
        if accessToken == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">return &amp;Client{
                accessToken: accessToken,
                baseURL:     DefaultBaseURL,
                httpClient: &amp;http.Client{
                        Timeout: DefaultTimeout,
                },
                maxRetries: DefaultMaxRetries,
                retryDelay: DefaultRetryDelay,
        }, nil</span>
}

// WithBaseURL sets a custom base URL (useful for testing)
func (c *Client) WithBaseURL(baseURL string) *Client <span class="cov0" title="0">{
        c.baseURL = baseURL
        return c
}</span>

// WithTimeout sets a custom timeout
func (c *Client) WithTimeout(timeout time.Duration) *Client <span class="cov0" title="0">{
        c.httpClient.Timeout = timeout
        return c
}</span>

// WithMaxRetries sets the maximum number of retry attempts
func (c *Client) WithMaxRetries(maxRetries int) *Client <span class="cov0" title="0">{
        c.maxRetries = maxRetries
        return c
}</span>

// SendMessage sends a message to a Slack channel
func (c *Client) SendMessage(ctx context.Context, req *SendMessageRequest) (*MessageResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>

        <span class="cov8" title="1">var resp MessageResponse
        if err := c.doRequest(ctx, "POST", "/chat.postMessage", req, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !resp.OK </span><span class="cov8" title="1">{
                return nil, ParseSlackError(resp.Error)
        }</span>

        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// UpdateMessage updates an existing message
func (c *Client) UpdateMessage(ctx context.Context, req *UpdateMessageRequest) (*MessageResponse, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>

        <span class="cov8" title="1">var resp MessageResponse
        if err := c.doRequest(ctx, "POST", "/chat.update", req, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !resp.OK </span><span class="cov8" title="1">{
                return nil, ParseSlackError(resp.Error)
        }</span>

        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// DeleteMessage deletes a message
func (c *Client) DeleteMessage(ctx context.Context, channel, timestamp string) error <span class="cov0" title="0">{
        req := map[string]string{
                "channel": channel,
                "ts":      timestamp,
        }

        var resp APIResponse
        if err := c.doRequest(ctx, "POST", "/chat.delete", req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                return ParseSlackError(resp.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddReaction adds a reaction emoji to a message
func (c *Client) AddReaction(ctx context.Context, channel, timestamp, emoji string) error <span class="cov8" title="1">{
        req := map[string]string{
                "channel":   channel,
                "timestamp": timestamp,
                "name":      emoji,
        }

        var resp APIResponse
        if err := c.doRequest(ctx, "POST", "/reactions.add", req, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Treat "already_reacted" as success
        <span class="cov8" title="1">if !resp.OK &amp;&amp; resp.Error != "already_reacted" </span><span class="cov8" title="1">{
                return ParseSlackError(resp.Error)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveReaction removes a reaction emoji from a message
func (c *Client) RemoveReaction(ctx context.Context, channel, timestamp, emoji string) error <span class="cov0" title="0">{
        req := map[string]string{
                "channel":   channel,
                "timestamp": timestamp,
                "name":      emoji,
        }

        var resp APIResponse
        if err := c.doRequest(ctx, "POST", "/reactions.remove", req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                return ParseSlackError(resp.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserByEmail looks up a user by their email address
func (c *Client) GetUserByEmail(ctx context.Context, email string) (*User, error) <span class="cov8" title="1">{
        if email == "" </span><span class="cov0" title="0">{
                return nil, ErrUserRequired
        }</span>

        <span class="cov8" title="1">var resp UserByEmailResponse
        endpoint := fmt.Sprintf("/users.lookupByEmail?email=%s", email)
        if err := c.doRequest(ctx, "GET", endpoint, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !resp.OK </span><span class="cov8" title="1">{
                return nil, ParseSlackError(resp.Error)
        }</span>

        <span class="cov8" title="1">return &amp;resp.User, nil</span>
}

// GetUserByID looks up a user by their ID
func (c *Client) GetUserByID(ctx context.Context, userID string) (*User, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, ErrUserRequired
        }</span>

        <span class="cov0" title="0">req := map[string]string{
                "user": userID,
        }

        var resp struct {
                OK    bool   `json:"ok"`
                User  User   `json:"user"`
                Error string `json:"error,omitempty"`
        }

        if err := c.doRequest(ctx, "POST", "/users.info", req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                return nil, ParseSlackError(resp.Error)
        }</span>

        <span class="cov0" title="0">return &amp;resp.User, nil</span>
}

// OpenConversation opens a direct message or multi-person direct message
func (c *Client) OpenConversation(ctx context.Context, users []string) (*Conversation, error) <span class="cov8" title="1">{
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, ErrUserRequired
        }</span>

        <span class="cov8" title="1">req := &amp;OpenConversationRequest{
                Users: users,
        }

        var resp OpenConversationResponse
        if err := c.doRequest(ctx, "POST", "/conversations.open", req, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !resp.OK </span><span class="cov8" title="1">{
                return nil, ParseSlackError(resp.Error)
        }</span>

        <span class="cov8" title="1">return &amp;resp.Channel, nil</span>
}

// ListChannels lists channels in the workspace
func (c *Client) ListChannels(ctx context.Context, types []string) ([]*Conversation, error) <span class="cov0" title="0">{
        req := map[string]interface{}{
                "types": types,
                "limit": 100,
        }

        var resp ListChannelsResponse
        if err := c.doRequest(ctx, "POST", "/conversations.list", req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                return nil, ParseSlackError(resp.Error)
        }</span>

        <span class="cov0" title="0">return resp.Channels, nil</span>
}

// doRequest performs an HTTP request with retry logic
func (c *Client) doRequest(ctx context.Context, method, endpoint string, body interface{}, result interface{}) error <span class="cov8" title="1">{
        var lastErr error

        for attempt := 0; attempt &lt;= c.maxRetries; attempt++ </span><span class="cov8" title="1">{
                // Check context before attempting
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Attempt the request
                <span class="cov8" title="1">err := c.doRequestOnce(ctx, method, endpoint, body, result)
                if err == nil </span><span class="cov8" title="1">{
                        return nil // Success
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Check if error is retryable
                slackErr, ok := err.(*SlackError)
                if !ok </span><span class="cov8" title="1">{
                        return err // Not a Slack error, don't retry
                }</span>

                <span class="cov8" title="1">if !slackErr.IsRetryable() </span><span class="cov0" title="0">{
                        return err // Not retryable
                }</span>

                // Don't retry on last attempt
                <span class="cov8" title="1">if attempt == c.maxRetries </span><span class="cov8" title="1">{
                        break</span>
                }

                // Calculate retry delay
                <span class="cov8" title="1">retryDelay := c.retryDelay
                if slackErr.RetryAfter &gt; 0 </span><span class="cov8" title="1">{
                        retryDelay = time.Duration(slackErr.RetryAfter) * time.Second
                }</span>

                // Wait before retrying
                <span class="cov8" title="1">select </span>{
                case &lt;-time.After(retryDelay):<span class="cov8" title="1"></span>
                        // Continue to next attempt
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }

        <span class="cov8" title="1">return lastErr</span>
}

// doRequestOnce performs a single HTTP request
func (c *Client) doRequestOnce(ctx context.Context, method, endpoint string, body interface{}, result interface{}) error <span class="cov8" title="1">{
        // Build URL
        url := c.baseURL + endpoint

        // Prepare request body
        var bodyReader io.Reader
        if body != nil </span><span class="cov8" title="1">{
                bodyJSON, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov8" title="1">bodyReader = bytes.NewReader(bodyJSON)</span>
        }

        // Create HTTP request
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, method, url, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.accessToken)
        if body != nil </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", "application/json; charset=utf-8")
        }</span>

        // Execute request
        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read response body
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Handle rate limiting
        <span class="cov8" title="1">if resp.StatusCode == http.StatusTooManyRequests </span><span class="cov8" title="1">{
                retryAfter := 1 // Default to 1 second
                if retryHeader := resp.Header.Get("Retry-After"); retryHeader != "" </span><span class="cov8" title="1">{
                        if seconds, err := strconv.Atoi(retryHeader); err == nil </span><span class="cov8" title="1">{
                                retryAfter = seconds
                        }</span>
                }

                <span class="cov8" title="1">return &amp;SlackError{
                        ErrorCode:  "rate_limited",
                        Message:    "Slack API rate limit exceeded",
                        RetryAfter: retryAfter,
                }</span>
        }

        // Handle other HTTP errors
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(respBody))
        }</span>

        // Parse response
        <span class="cov8" title="1">if err := json.Unmarshal(respBody, result); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse response: %w (body: %s)", err, string(respBody))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExchangeCode exchanges an OAuth2 authorization code for an access token
func (c *Client) ExchangeCode(ctx context.Context, clientID, clientSecret, code, redirectURI string) (*OAuthResponse, error) <span class="cov0" title="0">{
        req := map[string]string{
                "client_id":     clientID,
                "client_secret": clientSecret,
                "code":          code,
                "redirect_uri":  redirectURI,
        }

        var resp OAuthResponse
        if err := c.doRequest(ctx, "POST", "/oauth.v2.access", req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                if resp.Error != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("OAuth error: %s (%s)", resp.Error, resp.ErrorDescription)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("OAuth exchange failed")</span>
        }

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// RefreshToken refreshes an expired access token using a refresh token
func (c *Client) RefreshToken(ctx context.Context, clientID, clientSecret, refreshToken string) (*OAuthResponse, error) <span class="cov0" title="0">{
        req := map[string]string{
                "client_id":     clientID,
                "client_secret": clientSecret,
                "refresh_token": refreshToken,
                "grant_type":    "refresh_token",
        }

        var resp OAuthResponse
        if err := c.doRequest(ctx, "POST", "/oauth.v2.access", req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                if resp.Error != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("OAuth refresh error: %s", resp.Error)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("OAuth refresh failed")</span>
        }

        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package slack

import (
        "errors"
        "fmt"
)

// Common validation errors
var (
        ErrChannelRequired        = errors.New("channel is required")
        ErrUserRequired           = errors.New("user is required")
        ErrTextOrBlocksRequired   = errors.New("either text or blocks must be provided")
        ErrTextTooLong            = errors.New("text exceeds 40,000 character limit")
        ErrTimestampRequired      = errors.New("timestamp is required")
        ErrEmojiRequired          = errors.New("emoji is required")
        ErrInvalidCredential      = errors.New("invalid or missing Slack credential")
        ErrInvalidToken           = errors.New("invalid or expired access token")
        ErrRateLimitExceeded      = errors.New("Slack API rate limit exceeded")
        ErrChannelNotFound        = errors.New("channel not found")
        ErrMessageNotFound        = errors.New("message not found")
        ErrUserNotFound           = errors.New("user not found")
        ErrUnauthorized           = errors.New("unauthorized: missing required scopes")
        ErrChannelArchived        = errors.New("cannot post to archived channel")
        ErrRestrictedAction       = errors.New("action restricted in this channel")
        ErrAccountInactive        = errors.New("Slack account inactive")
        ErrInvalidAuth            = errors.New("invalid authentication")
        ErrMissingScope           = errors.New("missing required OAuth scope")
        ErrTokenRevoked           = errors.New("access token has been revoked")
)

// SlackError represents a Slack API error
type SlackError struct {
        ErrorCode string
        Message   string
        RetryAfter int // Seconds to wait before retrying (for rate limits)
}

func (e *SlackError) Error() string <span class="cov8" title="1">{
        if e.RetryAfter &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("slack error %s: %s (retry after %ds)", e.ErrorCode, e.Message, e.RetryAfter)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("slack error %s: %s", e.ErrorCode, e.Message)</span>
}

// IsRetryable returns true if the error is transient and should be retried
func (e *SlackError) IsRetryable() bool <span class="cov8" title="1">{
        retryableCodes := map[string]bool{
                "rate_limited":       true,
                "service_unavailable": true,
                "internal_error":     true,
                "timeout":            true,
                "fatal_error":        false, // Actually not retryable
        }
        return retryableCodes[e.ErrorCode]
}</span>

// ParseSlackError converts a Slack error code to a structured error
func ParseSlackError(errorCode string) error <span class="cov8" title="1">{
        errorMap := map[string]error{
                "invalid_auth":          ErrInvalidAuth,
                "token_revoked":         ErrTokenRevoked,
                "token_expired":         ErrInvalidToken,
                "account_inactive":      ErrAccountInactive,
                "channel_not_found":     ErrChannelNotFound,
                "not_in_channel":        ErrChannelNotFound,
                "is_archived":           ErrChannelArchived,
                "msg_too_long":          ErrTextTooLong,
                "no_text":               ErrTextOrBlocksRequired,
                "rate_limited":          ErrRateLimitExceeded,
                "message_not_found":     ErrMessageNotFound,
                "cant_update_message":   ErrUnauthorized,
                "edit_window_closed":    ErrRestrictedAction,
                "user_not_found":        ErrUserNotFound,
                "users_not_found":       ErrUserNotFound,
                "missing_scope":         ErrMissingScope,
                "restricted_action":     ErrRestrictedAction,
                "not_authed":            ErrInvalidAuth,
                "invalid_arguments":     errors.New("invalid arguments provided"),
                "invalid_name":          errors.New("invalid arguments provided"),
                "internal_error":        errors.New("Slack internal error"),
                "fatal_error":           errors.New("Slack fatal error"),
                "service_unavailable":   errors.New("Slack service temporarily unavailable"),
        }

        if err, ok := errorMap[errorCode]; ok </span><span class="cov8" title="1">{
                return &amp;SlackError{
                        ErrorCode: errorCode,
                        Message:   err.Error(),
                }
        }</span>

        <span class="cov0" title="0">return &amp;SlackError{
                ErrorCode: errorCode,
                Message:   fmt.Sprintf("unknown Slack error: %s", errorCode),
        }</span>
}

// ValidationError represents a configuration validation error
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}</span>

// RateLimitError represents a rate limit error with retry information
type RateLimitError struct {
        RetryAfter int    // Seconds to wait
        Message    string
}

func (e *RateLimitError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rate limit exceeded: %s (retry after %ds)", e.Message, e.RetryAfter)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package slack

import (
        "encoding/json"
        "time"
)

// CredentialMetadata represents Slack-specific OAuth credential data
type CredentialMetadata struct {
        TeamID      string   `json:"team_id"`
        TeamName    string   `json:"team_name"`
        UserID      string   `json:"user_id,omitempty"`
        BotUserID   string   `json:"bot_user_id,omitempty"`
        Scope       string   `json:"scope"`
        AppID       string   `json:"app_id,omitempty"`
        TokenType   string   `json:"token_type"` // "bot" or "user"
}

// OAuthResponse represents the response from Slack OAuth2 token exchange
type OAuthResponse struct {
        OK          bool   `json:"ok"`
        AccessToken string `json:"access_token"`
        TokenType   string `json:"token_type"`
        Scope       string `json:"scope"`
        BotUserID   string `json:"bot_user_id,omitempty"`
        AppID       string `json:"app_id"`
        Team        struct {
                ID   string `json:"id"`
                Name string `json:"name"`
        } `json:"team"`
        Enterprise         interface{} `json:"enterprise,omitempty"`
        AuthedUser         interface{} `json:"authed_user,omitempty"`
        IncomingWebhook    interface{} `json:"incoming_webhook,omitempty"`
        RefreshToken       string      `json:"refresh_token,omitempty"`
        ExpiresIn          int         `json:"expires_in,omitempty"`
        Error              string      `json:"error,omitempty"`
        ErrorDescription   string      `json:"error_description,omitempty"`
}

// APIResponse is the base Slack API response structure
type APIResponse struct {
        OK    bool   `json:"ok"`
        Error string `json:"error,omitempty"`
}

// SendMessageRequest represents a request to send a message
type SendMessageRequest struct {
        Channel         string                   `json:"channel"`
        Text            string                   `json:"text,omitempty"`
        Blocks          []map[string]interface{} `json:"blocks,omitempty"`
        Attachments     []Attachment             `json:"attachments,omitempty"`
        ThreadTS        string                   `json:"thread_ts,omitempty"`
        ReplyBroadcast  bool                     `json:"reply_broadcast,omitempty"`
        UnfurlLinks     bool                     `json:"unfurl_links,omitempty"`
        UnfurlMedia     bool                     `json:"unfurl_media,omitempty"`
        IconEmoji       string                   `json:"icon_emoji,omitempty"`
        IconURL         string                   `json:"icon_url,omitempty"`
        Username        string                   `json:"username,omitempty"`
        AsUser          bool                     `json:"as_user,omitempty"`
        LinkNames       bool                     `json:"link_names,omitempty"`
        Mrkdwn          bool                     `json:"mrkdwn,omitempty"`
}

// Attachment represents a Slack message attachment (legacy)
type Attachment struct {
        Fallback   string                   `json:"fallback,omitempty"`
        Color      string                   `json:"color,omitempty"`
        Pretext    string                   `json:"pretext,omitempty"`
        AuthorName string                   `json:"author_name,omitempty"`
        AuthorLink string                   `json:"author_link,omitempty"`
        AuthorIcon string                   `json:"author_icon,omitempty"`
        Title      string                   `json:"title,omitempty"`
        TitleLink  string                   `json:"title_link,omitempty"`
        Text       string                   `json:"text,omitempty"`
        Fields     []AttachmentField        `json:"fields,omitempty"`
        ImageURL   string                   `json:"image_url,omitempty"`
        ThumbURL   string                   `json:"thumb_url,omitempty"`
        Footer     string                   `json:"footer,omitempty"`
        FooterIcon string                   `json:"footer_icon,omitempty"`
        Timestamp  int64                    `json:"ts,omitempty"`
        Actions    []map[string]interface{} `json:"actions,omitempty"`
}

// AttachmentField represents a field in an attachment
type AttachmentField struct {
        Title string `json:"title"`
        Value string `json:"value"`
        Short bool   `json:"short,omitempty"`
}

// MessageResponse represents the response from sending/updating a message
type MessageResponse struct {
        OK      bool    `json:"ok"`
        Channel string  `json:"channel"`
        TS      string  `json:"ts"` // Message timestamp (unique ID)
        Message Message `json:"message,omitempty"`
        Error   string  `json:"error,omitempty"`
}

// Message represents a Slack message
type Message struct {
        Type        string                   `json:"type"`
        User        string                   `json:"user,omitempty"`
        Text        string                   `json:"text"`
        Blocks      []map[string]interface{} `json:"blocks,omitempty"`
        Attachments []Attachment             `json:"attachments,omitempty"`
        TS          string                   `json:"ts"`
        BotID       string                   `json:"bot_id,omitempty"`
        Username    string                   `json:"username,omitempty"`
        Icons       *MessageIcons            `json:"icons,omitempty"`
}

// MessageIcons represents message icons
type MessageIcons struct {
        Emoji       string `json:"emoji,omitempty"`
        Image48     string `json:"image_48,omitempty"`
        Image64     string `json:"image_64,omitempty"`
        Image72     string `json:"image_72,omitempty"`
}

// UpdateMessageRequest represents a request to update a message
type UpdateMessageRequest struct {
        Channel     string                   `json:"channel"`
        TS          string                   `json:"ts"`
        Text        string                   `json:"text,omitempty"`
        Blocks      []map[string]interface{} `json:"blocks,omitempty"`
        Attachments []Attachment             `json:"attachments,omitempty"`
        AsUser      bool                     `json:"as_user,omitempty"`
        LinkNames   bool                     `json:"link_names,omitempty"`
}

// User represents a Slack user
type User struct {
        ID                string      `json:"id"`
        TeamID            string      `json:"team_id"`
        Name              string      `json:"name"`
        Deleted           bool        `json:"deleted"`
        Color             string      `json:"color,omitempty"`
        RealName          string      `json:"real_name,omitempty"`
        TZ                string      `json:"tz,omitempty"`
        TZLabel           string      `json:"tz_label,omitempty"`
        TZOffset          int         `json:"tz_offset,omitempty"`
        Profile           UserProfile `json:"profile"`
        IsAdmin           bool        `json:"is_admin,omitempty"`
        IsOwner           bool        `json:"is_owner,omitempty"`
        IsPrimaryOwner    bool        `json:"is_primary_owner,omitempty"`
        IsRestricted      bool        `json:"is_restricted,omitempty"`
        IsUltraRestricted bool        `json:"is_ultra_restricted,omitempty"`
        IsBot             bool        `json:"is_bot,omitempty"`
        IsAppUser         bool        `json:"is_app_user,omitempty"`
        Updated           int64       `json:"updated,omitempty"`
}

// UserProfile represents a Slack user's profile
type UserProfile struct {
        FirstName          string `json:"first_name,omitempty"`
        LastName           string `json:"last_name,omitempty"`
        RealName           string `json:"real_name,omitempty"`
        RealNameNormalized string `json:"real_name_normalized,omitempty"`
        DisplayName        string `json:"display_name,omitempty"`
        Email              string `json:"email,omitempty"`
        Image24            string `json:"image_24,omitempty"`
        Image32            string `json:"image_32,omitempty"`
        Image48            string `json:"image_48,omitempty"`
        Image72            string `json:"image_72,omitempty"`
        Image192           string `json:"image_192,omitempty"`
        Image512           string `json:"image_512,omitempty"`
        StatusText         string `json:"status_text,omitempty"`
        StatusEmoji        string `json:"status_emoji,omitempty"`
        Team               string `json:"team,omitempty"`
}

// UserByEmailResponse represents the response from looking up a user by email
type UserByEmailResponse struct {
        OK    bool   `json:"ok"`
        User  User   `json:"user,omitempty"`
        Error string `json:"error,omitempty"`
}

// Conversation represents a Slack channel or DM
type Conversation struct {
        ID                 string   `json:"id"`
        Name               string   `json:"name,omitempty"`
        IsChannel          bool     `json:"is_channel"`
        IsGroup            bool     `json:"is_group"`
        IsIM               bool     `json:"is_im"`
        IsMpIM             bool     `json:"is_mpim"`
        IsPrivate          bool     `json:"is_private"`
        Created            int64    `json:"created"`
        IsArchived         bool     `json:"is_archived"`
        IsGeneral          bool     `json:"is_general,omitempty"`
        Unlinked           int      `json:"unlinked,omitempty"`
        NameNormalized     string   `json:"name_normalized,omitempty"`
        IsShared           bool     `json:"is_shared,omitempty"`
        IsOrgShared        bool     `json:"is_org_shared,omitempty"`
        IsMember           bool     `json:"is_member,omitempty"`
        IsReadOnly         bool     `json:"is_read_only,omitempty"`
        Creator            string   `json:"creator,omitempty"`
        Topic              *Topic   `json:"topic,omitempty"`
        Purpose            *Purpose `json:"purpose,omitempty"`
        NumMembers         int      `json:"num_members,omitempty"`
}

// Topic represents a channel topic
type Topic struct {
        Value   string `json:"value"`
        Creator string `json:"creator"`
        LastSet int64  `json:"last_set"`
}

// Purpose represents a channel purpose
type Purpose struct {
        Value   string `json:"value"`
        Creator string `json:"creator"`
        LastSet int64  `json:"last_set"`
}

// OpenConversationRequest represents a request to open a DM or group DM
type OpenConversationRequest struct {
        Users []string `json:"users"` // User IDs
}

// OpenConversationResponse represents the response from opening a conversation
type OpenConversationResponse struct {
        OK      bool         `json:"ok"`
        Channel Conversation `json:"channel,omitempty"`
        Error   string       `json:"error,omitempty"`
}

// ListChannelsResponse represents the response from listing channels
type ListChannelsResponse struct {
        OK       bool            `json:"ok"`
        Channels []*Conversation `json:"channels,omitempty"`
        Error    string          `json:"error,omitempty"`
        Metadata *Metadata       `json:"response_metadata,omitempty"`
}

// Metadata represents pagination metadata
type Metadata struct {
        NextCursor string `json:"next_cursor,omitempty"`
}

// ErrorResponse represents a Slack error response
type ErrorResponse struct {
        OK    bool   `json:"ok"`
        Error string `json:"error"`
}

// ActionConfig represents the configuration for a Slack action in a workflow
type ActionConfig struct {
        // Common fields
        CredentialName string `json:"credential"` // References credential vault

        // Action-specific fields (will be different for each action type)
        Config json.RawMessage `json:"config"`
}

// SendMessageConfig represents configuration for SendMessage action
type SendMessageConfig struct {
        Channel         string                   `json:"channel"`
        Text            string                   `json:"text,omitempty"`
        Blocks          []map[string]interface{} `json:"blocks,omitempty"`
        ThreadTS        string                   `json:"thread_ts,omitempty"`
        ReplyBroadcast  bool                     `json:"reply_broadcast,omitempty"`
        UnfurlLinks     *bool                    `json:"unfurl_links,omitempty"`
        UnfurlMedia     *bool                    `json:"unfurl_media,omitempty"`
        IconEmoji       string                   `json:"icon_emoji,omitempty"`
        Username        string                   `json:"username,omitempty"`
}

// SendDMConfig represents configuration for SendDM action
type SendDMConfig struct {
        User   string                   `json:"user"` // User ID or email
        Text   string                   `json:"text,omitempty"`
        Blocks []map[string]interface{} `json:"blocks,omitempty"`
}

// UpdateMessageConfig represents configuration for UpdateMessage action
type UpdateMessageConfig struct {
        Channel string                   `json:"channel"`
        TS      string                   `json:"ts"`
        Text    string                   `json:"text,omitempty"`
        Blocks  []map[string]interface{} `json:"blocks,omitempty"`
}

// AddReactionConfig represents configuration for AddReaction action
type AddReactionConfig struct {
        Channel   string `json:"channel"`
        Timestamp string `json:"timestamp"`
        Emoji     string `json:"emoji"` // Emoji name without colons
}

// Validate validates SendMessageConfig
func (c *SendMessageConfig) Validate() error <span class="cov8" title="1">{
        if c.Channel == "" </span><span class="cov8" title="1">{
                return ErrChannelRequired
        }</span>
        <span class="cov8" title="1">if c.Text == "" &amp;&amp; len(c.Blocks) == 0 </span><span class="cov8" title="1">{
                return ErrTextOrBlocksRequired
        }</span>
        <span class="cov8" title="1">if len(c.Text) &gt; 40000 </span><span class="cov8" title="1">{
                return ErrTextTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate validates SendDMConfig
func (c *SendDMConfig) Validate() error <span class="cov8" title="1">{
        if c.User == "" </span><span class="cov8" title="1">{
                return ErrUserRequired
        }</span>
        <span class="cov8" title="1">if c.Text == "" &amp;&amp; len(c.Blocks) == 0 </span><span class="cov8" title="1">{
                return ErrTextOrBlocksRequired
        }</span>
        <span class="cov8" title="1">if len(c.Text) &gt; 40000 </span><span class="cov8" title="1">{
                return ErrTextTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate validates UpdateMessageConfig
func (c *UpdateMessageConfig) Validate() error <span class="cov8" title="1">{
        if c.Channel == "" </span><span class="cov8" title="1">{
                return ErrChannelRequired
        }</span>
        <span class="cov8" title="1">if c.TS == "" </span><span class="cov8" title="1">{
                return ErrTimestampRequired
        }</span>
        <span class="cov8" title="1">if c.Text == "" &amp;&amp; len(c.Blocks) == 0 </span><span class="cov8" title="1">{
                return ErrTextOrBlocksRequired
        }</span>
        <span class="cov8" title="1">if len(c.Text) &gt; 40000 </span><span class="cov8" title="1">{
                return ErrTextTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate validates AddReactionConfig
func (c *AddReactionConfig) Validate() error <span class="cov8" title="1">{
        if c.Channel == "" </span><span class="cov8" title="1">{
                return ErrChannelRequired
        }</span>
        <span class="cov8" title="1">if c.Timestamp == "" </span><span class="cov8" title="1">{
                return ErrTimestampRequired
        }</span>
        <span class="cov8" title="1">if c.Emoji == "" </span><span class="cov8" title="1">{
                return ErrEmojiRequired
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UsageLog represents a Slack API usage log entry
type UsageLog struct {
        ID             string
        TenantID       string
        CredentialID   string
        ActionType     string
        ExecutionID    string
        Success        bool
        StatusCode     int
        ErrorMessage   string
        ResponseTimeMS int
        Metadata       map[string]interface{}
        CreatedAt      time.Time
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package slack

import (
        "context"
        "fmt"
        "strings"

        "github.com/gorax/gorax/internal/credential"
        "github.com/gorax/gorax/internal/executor/actions"
)

// SendDMAction implements the Slack SendDM (Direct Message) action
type SendDMAction struct {
        credentialService credential.Service
        baseURL           string // For testing, defaults to DefaultBaseURL
}

// NewSendDMAction creates a new SendDM action
func NewSendDMAction(credentialService credential.Service) *SendDMAction <span class="cov8" title="1">{
        return &amp;SendDMAction{
                credentialService: credentialService,
                baseURL:           DefaultBaseURL,
        }
}</span>

// Execute implements the Action interface
func (a *SendDMAction) Execute(ctx context.Context, input *actions.ActionInput) (*actions.ActionOutput, error) <span class="cov8" title="1">{
        // Parse config
        config, ok := input.Config.(SendDMConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config type: expected SendDMConfig")
        }</span>

        // Validate config
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Extract tenant_id and credential_id from context
        <span class="cov8" title="1">tenantID, err := extractString(input.Context, "env.tenant_id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant_id is required in context: %w", err)
        }</span>

        <span class="cov8" title="1">credentialID, err := extractString(input.Context, "credential_id")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential_id is required in context: %w", err)
        }</span>

        // Retrieve and decrypt credential
        <span class="cov8" title="1">decryptedCred, err := a.credentialService.GetValue(ctx, tenantID, credentialID, "system")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve credential: %w", err)
        }</span>

        // Extract access_token from credential
        <span class="cov8" title="1">accessToken, ok := decryptedCred.Value["access_token"].(string)
        if !ok || accessToken == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access_token not found in credential")
        }</span>

        // Create Slack client
        <span class="cov8" title="1">client, err := NewClient(accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        // Override base URL if set (for testing)
        <span class="cov8" title="1">if a.baseURL != "" </span><span class="cov8" title="1">{
                client.baseURL = a.baseURL
        }</span>

        // Resolve user identifier to user ID
        <span class="cov8" title="1">userID, err := a.resolveUserID(ctx, client, config.User)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to resolve user: %w", err)
        }</span>

        // Open DM conversation
        <span class="cov8" title="1">conversation, err := client.OpenConversation(ctx, []string{userID})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open conversation: %w", err)
        }</span>

        // Build SendMessage request
        <span class="cov8" title="1">req := &amp;SendMessageRequest{
                Channel: conversation.ID,
                Text:    config.Text,
                Blocks:  config.Blocks,
        }

        // Send message
        resp, err := client.SendMessage(ctx, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send message: %w", err)
        }</span>

        // Build result
        <span class="cov8" title="1">result := &amp;SendDMResult{
                OK:        resp.OK,
                UserID:    userID,
                Channel:   resp.Channel,
                Timestamp: resp.TS,
                Message:   &amp;resp.Message,
        }

        // Create output
        output := actions.NewActionOutput(result)
        output.WithMetadata("user_id", userID)
        output.WithMetadata("channel", resp.Channel)
        output.WithMetadata("timestamp", resp.TS)
        output.WithMetadata("message_type", resp.Message.Type)

        return output, nil</span>
}

// resolveUserID resolves a user identifier (email or user ID) to a Slack user ID
func (a *SendDMAction) resolveUserID(ctx context.Context, client *Client, userIdentifier string) (string, error) <span class="cov8" title="1">{
        // Check if it's an email
        if isEmail(userIdentifier) </span><span class="cov8" title="1">{
                // Look up user by email
                user, err := client.GetUserByEmail(ctx, userIdentifier)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to lookup user by email: %w", err)
                }</span>
                <span class="cov8" title="1">return user.ID, nil</span>
        }

        // Assume it's a user ID
        <span class="cov8" title="1">return userIdentifier, nil</span>
}

// isEmail checks if a string is an email address
func isEmail(s string) bool <span class="cov8" title="1">{
        // Simple email validation - contains @ and has parts before and after
        if !strings.Contains(s, "@") </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">parts := strings.Split(s, "@")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that both parts are non-empty
        <span class="cov8" title="1">if len(parts[0]) == 0 || len(parts[1]) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that domain part contains a dot
        <span class="cov8" title="1">if !strings.Contains(parts[1], ".") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// SendDMResult represents the result of sending a direct message
type SendDMResult struct {
        OK        bool     `json:"ok"`
        UserID    string   `json:"user_id"`
        Channel   string   `json:"channel"`
        Timestamp string   `json:"timestamp"`
        Message   *Message `json:"message,omitempty"`
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package slack

import (
        "context"
        "fmt"

        "github.com/gorax/gorax/internal/credential"
        "github.com/gorax/gorax/internal/executor/actions"
)

// SendMessageAction implements the Slack SendMessage action
type SendMessageAction struct {
        credentialService credential.Service
        baseURL           string // For testing, defaults to DefaultBaseURL
}

// NewSendMessageAction creates a new SendMessage action
func NewSendMessageAction(credentialService credential.Service) *SendMessageAction <span class="cov8" title="1">{
        return &amp;SendMessageAction{
                credentialService: credentialService,
                baseURL:           DefaultBaseURL,
        }
}</span>

// Execute implements the Action interface
func (a *SendMessageAction) Execute(ctx context.Context, input *actions.ActionInput) (*actions.ActionOutput, error) <span class="cov8" title="1">{
        // Parse config
        config, ok := input.Config.(SendMessageConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config type: expected SendMessageConfig")
        }</span>

        // Validate config
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Extract tenant_id and credential_id from context
        <span class="cov8" title="1">tenantID, err := extractString(input.Context, "env.tenant_id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant_id is required in context: %w", err)
        }</span>

        <span class="cov8" title="1">credentialID, err := extractString(input.Context, "credential_id")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential_id is required in context: %w", err)
        }</span>

        // Retrieve and decrypt credential
        <span class="cov8" title="1">decryptedCred, err := a.credentialService.GetValue(ctx, tenantID, credentialID, "system")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve credential: %w", err)
        }</span>

        // Extract access_token from credential
        <span class="cov8" title="1">accessToken, ok := decryptedCred.Value["access_token"].(string)
        if !ok || accessToken == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("access_token not found in credential")
        }</span>

        // Create Slack client
        <span class="cov8" title="1">client, err := NewClient(accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        // Override base URL if set (for testing)
        <span class="cov8" title="1">if a.baseURL != "" </span><span class="cov8" title="1">{
                client.baseURL = a.baseURL
        }</span>

        // Build SendMessage request
        <span class="cov8" title="1">req := &amp;SendMessageRequest{
                Channel:        config.Channel,
                Text:           config.Text,
                Blocks:         config.Blocks,
                ThreadTS:       config.ThreadTS,
                ReplyBroadcast: config.ReplyBroadcast,
                IconEmoji:      config.IconEmoji,
                Username:       config.Username,
        }

        // Set unfurl options if provided
        if config.UnfurlLinks != nil </span><span class="cov0" title="0">{
                req.UnfurlLinks = *config.UnfurlLinks
        }</span>
        <span class="cov8" title="1">if config.UnfurlMedia != nil </span><span class="cov0" title="0">{
                req.UnfurlMedia = *config.UnfurlMedia
        }</span>

        // Send message
        <span class="cov8" title="1">resp, err := client.SendMessage(ctx, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to send message: %w", err)
        }</span>

        // Build result
        <span class="cov8" title="1">result := &amp;SendMessageResult{
                OK:        resp.OK,
                Channel:   resp.Channel,
                Timestamp: resp.TS,
                Message:   &amp;resp.Message,
        }

        // Create output
        output := actions.NewActionOutput(result)
        output.WithMetadata("channel", resp.Channel)
        output.WithMetadata("timestamp", resp.TS)
        output.WithMetadata("message_type", resp.Message.Type)

        return output, nil</span>
}

// SendMessageResult represents the result of sending a Slack message
type SendMessageResult struct {
        OK        bool     `json:"ok"`
        Channel   string   `json:"channel"`
        Timestamp string   `json:"timestamp"`
        Message   *Message `json:"message,omitempty"`
}

// extractString extracts a string value from a nested map using dot notation
// e.g., "env.tenant_id" from map["env"]["tenant_id"]
func extractString(data map[string]interface{}, path string) (string, error) <span class="cov8" title="1">{
        // Simple implementation for now - can be enhanced with proper JSONPath later
        keys := parsePath(path)
        current := data

        for i, key := range keys </span><span class="cov8" title="1">{
                if i == len(keys)-1 </span><span class="cov8" title="1">{
                        // Last key - should be the value
                        if val, ok := current[key]; ok </span><span class="cov8" title="1">{
                                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                                        return str, nil
                                }</span>
                                <span class="cov0" title="0">return "", fmt.Errorf("value at '%s' is not a string", path)</span>
                        }
                        <span class="cov8" title="1">return "", fmt.Errorf("key '%s' not found in context", path)</span>
                }

                // Intermediate key - should be a map
                <span class="cov8" title="1">if val, ok := current[key]; ok </span><span class="cov8" title="1">{
                        if m, ok := val.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                current = m
                        }</span> else<span class="cov0" title="0"> {
                                return "", fmt.Errorf("value at '%s' is not a map", key)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return "", fmt.Errorf("key '%s' not found in context", key)
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed to extract value from path '%s'", path)</span>
}

// parsePath splits a dot-notation path into keys
// e.g., "env.tenant_id" -&gt; ["env", "tenant_id"]
func parsePath(path string) []string <span class="cov8" title="1">{
        // Simple split by dot - can be enhanced to handle escaped dots later
        result := []string{}
        current := ""

        for _, ch := range path </span><span class="cov8" title="1">{
                if ch == '.' </span><span class="cov8" title="1">{
                        if current != "" </span><span class="cov8" title="1">{
                                result = append(result, current)
                                current = ""
                        }</span>
                } else<span class="cov8" title="1"> {
                        current += string(ch)
                }</span>
        }

        <span class="cov8" title="1">if current != "" </span><span class="cov8" title="1">{
                result = append(result, current)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package slack

import (
        "context"
        "fmt"

        "github.com/gorax/gorax/internal/credential"
        "github.com/gorax/gorax/internal/executor/actions"
)

// UpdateMessageAction implements the Slack UpdateMessage action
type UpdateMessageAction struct {
        credentialService credential.Service
        baseURL           string // For testing, defaults to DefaultBaseURL
}

// NewUpdateMessageAction creates a new UpdateMessage action
func NewUpdateMessageAction(credentialService credential.Service) *UpdateMessageAction <span class="cov8" title="1">{
        return &amp;UpdateMessageAction{
                credentialService: credentialService,
                baseURL:           DefaultBaseURL,
        }
}</span>

// Execute implements the Action interface
func (a *UpdateMessageAction) Execute(ctx context.Context, input *actions.ActionInput) (*actions.ActionOutput, error) <span class="cov8" title="1">{
        // Parse config
        config, ok := input.Config.(UpdateMessageConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config type: expected UpdateMessageConfig")
        }</span>

        // Validate config
        <span class="cov8" title="1">if err := config.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Extract tenant_id and credential_id from context
        <span class="cov8" title="1">tenantID, err := extractString(input.Context, "env.tenant_id")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tenant_id is required in context: %w", err)
        }</span>

        <span class="cov8" title="1">credentialID, err := extractString(input.Context, "credential_id")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("credential_id is required in context: %w", err)
        }</span>

        // Retrieve and decrypt credential
        <span class="cov8" title="1">decryptedCred, err := a.credentialService.GetValue(ctx, tenantID, credentialID, "system")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve credential: %w", err)
        }</span>

        // Extract access_token from credential
        <span class="cov8" title="1">accessToken, ok := decryptedCred.Value["access_token"].(string)
        if !ok || accessToken == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("access_token not found in credential")
        }</span>

        // Create Slack client
        <span class="cov8" title="1">client, err := NewClient(accessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Slack client: %w", err)
        }</span>

        // Override base URL if set (for testing)
        <span class="cov8" title="1">if a.baseURL != "" </span><span class="cov8" title="1">{
                client.baseURL = a.baseURL
        }</span>

        // Build UpdateMessage request
        <span class="cov8" title="1">req := &amp;UpdateMessageRequest{
                Channel: config.Channel,
                TS:      config.TS,
                Text:    config.Text,
                Blocks:  config.Blocks,
        }

        // Update message
        resp, err := client.UpdateMessage(ctx, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update message: %w", err)
        }</span>

        // Build result
        <span class="cov8" title="1">result := &amp;UpdateMessageResult{
                OK:        resp.OK,
                Channel:   resp.Channel,
                Timestamp: resp.TS,
                Message:   &amp;resp.Message,
        }

        // Create output
        output := actions.NewActionOutput(result)
        output.WithMetadata("channel", resp.Channel)
        output.WithMetadata("timestamp", resp.TS)
        output.WithMetadata("message_type", resp.Message.Type)
        output.WithMetadata("updated", true)

        return output, nil</span>
}

// UpdateMessageResult represents the result of updating a Slack message
type UpdateMessageResult struct {
        OK        bool     `json:"ok"`
        Channel   string   `json:"channel"`
        Timestamp string   `json:"timestamp"`
        Message   *Message `json:"message,omitempty"`
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package queue

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"
)

// Consumer handles consuming messages from the queue
type Consumer struct {
        sqsClient *SQSClient
        logger    *slog.Logger
        handler   MessageHandler
        config    ConsumerConfig
        metrics   *ConsumerMetrics
        mu        sync.RWMutex
        running   bool
}

// ConsumerConfig holds consumer configuration
type ConsumerConfig struct {
        MaxMessages        int32         // Maximum number of messages to receive per poll (1-10)
        WaitTimeSeconds    int32         // Long polling wait time (0-20 seconds)
        VisibilityTimeout  int32         // Message visibility timeout in seconds
        MaxRetries         int           // Maximum number of retries before sending to DLQ
        ProcessTimeout     time.Duration // Maximum time to process a message
        PollInterval       time.Duration // Interval between polls when no messages received
        ConcurrentWorkers  int           // Number of concurrent message processors
        DeleteAfterProcess bool          // Automatically delete message after successful processing
}

// DefaultConsumerConfig returns default consumer configuration
func DefaultConsumerConfig() ConsumerConfig <span class="cov0" title="0">{
        return ConsumerConfig{
                MaxMessages:        10,
                WaitTimeSeconds:    20, // Long polling
                VisibilityTimeout:  30,
                MaxRetries:         3,
                ProcessTimeout:     5 * time.Minute,
                PollInterval:       1 * time.Second,
                ConcurrentWorkers:  10,
                DeleteAfterProcess: true,
        }
}</span>

// ConsumerMetrics tracks consumer performance
type ConsumerMetrics struct {
        TotalReceived   int64
        TotalProcessed  int64
        TotalFailed     int64
        TotalDeleted    int64
        LastReceiveAt   time.Time
        LastProcessedAt time.Time
        InFlight        int64
}

// MessageHandler is a function that processes a message
type MessageHandler func(ctx context.Context, msg *ExecutionMessage) error

// NewConsumer creates a new queue consumer
func NewConsumer(sqsClient *SQSClient, handler MessageHandler, config ConsumerConfig, logger *slog.Logger) *Consumer <span class="cov0" title="0">{
        return &amp;Consumer{
                sqsClient: sqsClient,
                logger:    logger,
                handler:   handler,
                config:    config,
                metrics:   &amp;ConsumerMetrics{},
                running:   false,
        }
}</span>

// Start begins consuming messages from the queue
func (c *Consumer) Start(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.Lock()
        if c.running </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return fmt.Errorf("consumer already running")
        }</span>
        <span class="cov0" title="0">c.running = true
        c.mu.Unlock()

        c.logger.Info("starting consumer",
                "max_messages", c.config.MaxMessages,
                "wait_time", c.config.WaitTimeSeconds,
                "concurrent_workers", c.config.ConcurrentWorkers,
        )

        // Create worker pool
        messagesChan := make(chan Message, c.config.ConcurrentWorkers*2)
        var wg sync.WaitGroup

        // Start worker goroutines
        for i := 0; i &lt; c.config.ConcurrentWorkers; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        c.worker(ctx, workerID, messagesChan)
                }</span>(i)
        }

        // Main polling loop
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer close(messagesChan)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                c.logger.Info("consumer stopping due to context cancellation")
                                c.mu.Lock()
                                c.running = false
                                c.mu.Unlock()
                                return</span>
                        default:<span class="cov0" title="0">
                                // Poll for messages
                                messages, err := c.sqsClient.ReceiveMessages(ctx, c.config.MaxMessages, c.config.WaitTimeSeconds)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("failed to receive messages", "error", err)
                                        time.Sleep(c.config.PollInterval)
                                        continue</span>
                                }

                                <span class="cov0" title="0">if len(messages) == 0 </span><span class="cov0" title="0">{
                                        // No messages, wait before next poll
                                        time.Sleep(c.config.PollInterval)
                                        continue</span>
                                }

                                // Update metrics
                                <span class="cov0" title="0">c.mu.Lock()
                                c.metrics.TotalReceived += int64(len(messages))
                                c.metrics.LastReceiveAt = time.Now()
                                c.mu.Unlock()

                                c.logger.Debug("received messages from queue", "count", len(messages))

                                // Send messages to worker pool
                                for _, msg := range messages </span><span class="cov0" title="0">{
                                        select </span>{
                                        case messagesChan &lt;- msg:<span class="cov0" title="0">
                                                c.mu.Lock()
                                                c.metrics.InFlight++
                                                c.mu.Unlock()</span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }
                }
        }()

        // Wait for all workers to finish
        <span class="cov0" title="0">wg.Wait()

        c.logger.Info("consumer stopped")
        return nil</span>
}

// worker processes messages from the channel
func (c *Consumer) worker(ctx context.Context, workerID int, messagesChan &lt;-chan Message) <span class="cov0" title="0">{
        c.logger.Debug("worker started", "worker_id", workerID)

        for msg := range messagesChan </span><span class="cov0" title="0">{
                c.processMessage(ctx, msg)

                // Decrement in-flight count
                c.mu.Lock()
                c.metrics.InFlight--
                c.mu.Unlock()
        }</span>

        <span class="cov0" title="0">c.logger.Debug("worker stopped", "worker_id", workerID)</span>
}

// processMessage processes a single message
func (c *Consumer) processMessage(ctx context.Context, msg Message) <span class="cov0" title="0">{
        // Create processing context with timeout
        processCtx, cancel := context.WithTimeout(ctx, c.config.ProcessTimeout)
        defer cancel()

        c.logger.Info("processing message",
                "message_id", msg.ID,
                "receive_count", msg.ApproximateReceiveCount,
        )

        // Unmarshal execution message
        execMsg, err := UnmarshalExecutionMessage(msg.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to unmarshal message", "error", err, "message_id", msg.ID)
                c.handleFailedMessage(ctx, msg, err)
                return
        }</span>

        // Validate message
        <span class="cov0" title="0">if err := execMsg.Validate(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("invalid message", "error", err, "message_id", msg.ID)
                c.handleFailedMessage(ctx, msg, err)
                return
        }</span>

        // Check if message has exceeded max retries
        <span class="cov0" title="0">if msg.ApproximateReceiveCount &gt; c.config.MaxRetries </span><span class="cov0" title="0">{
                c.logger.Error("message exceeded max retries",
                        "message_id", msg.ID,
                        "receive_count", msg.ApproximateReceiveCount,
                        "max_retries", c.config.MaxRetries,
                )
                // Delete the message to prevent infinite reprocessing
                // It should have already been sent to DLQ by SQS
                c.deleteMessage(ctx, msg.ReceiptHandle)
                return
        }</span>

        // Process the message using handler
        <span class="cov0" title="0">if err := c.handler(processCtx, execMsg); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("message processing failed",
                        "error", err,
                        "message_id", msg.ID,
                        "execution_id", execMsg.ExecutionID,
                )
                c.handleFailedMessage(ctx, msg, err)
                return
        }</span>

        // Update metrics
        <span class="cov0" title="0">c.mu.Lock()
        c.metrics.TotalProcessed++
        c.metrics.LastProcessedAt = time.Now()
        c.mu.Unlock()

        c.logger.Info("message processed successfully",
                "message_id", msg.ID,
                "execution_id", execMsg.ExecutionID,
        )

        // Delete message from queue if configured
        if c.config.DeleteAfterProcess </span><span class="cov0" title="0">{
                c.deleteMessage(ctx, msg.ReceiptHandle)
        }</span>
}

// handleFailedMessage handles a failed message
func (c *Consumer) handleFailedMessage(ctx context.Context, msg Message, err error) <span class="cov0" title="0">{
        c.mu.Lock()
        c.metrics.TotalFailed++
        c.mu.Unlock()

        // If the message has not exceeded retries, it will become visible again
        // and be retried automatically by SQS
        // If it has exceeded retries, SQS will send it to the DLQ automatically

        c.logger.Warn("message processing failed, will retry",
                "message_id", msg.ID,
                "receive_count", msg.ApproximateReceiveCount,
                "error", err,
        )

        // Note: We don't delete the message here, so it will become visible again
        // after the visibility timeout expires
}</span>

// deleteMessage deletes a message from the queue
func (c *Consumer) deleteMessage(ctx context.Context, receiptHandle string) <span class="cov0" title="0">{
        if err := c.sqsClient.DeleteMessage(ctx, receiptHandle); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to delete message", "error", err)
                return
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.metrics.TotalDeleted++
        c.mu.Unlock()</span>
}

// IsRunning returns whether the consumer is running
func (c *Consumer) IsRunning() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.running
}</span>

// GetMetrics returns consumer metrics
func (c *Consumer) GetMetrics() ConsumerMetrics <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return *c.metrics
}</span>

// ResetMetrics resets consumer metrics
func (c *Consumer) ResetMetrics() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.metrics.TotalReceived = 0
        c.metrics.TotalProcessed = 0
        c.metrics.TotalFailed = 0
        c.metrics.TotalDeleted = 0
        c.metrics.LastReceiveAt = time.Time{}
        c.metrics.LastProcessedAt = time.Time{}
        // Don't reset InFlight as it represents current state
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package queue

import (
        "encoding/json"
        "fmt"
        "time"
)

// ExecutionMessage represents a workflow execution message in the queue
type ExecutionMessage struct {
        // Execution identifiers
        ExecutionID     string `json:"execution_id"`
        TenantID        string `json:"tenant_id"`
        WorkflowID      string `json:"workflow_id"`
        WorkflowVersion int    `json:"workflow_version"`

        // Trigger information
        TriggerType string          `json:"trigger_type"`
        TriggerData json.RawMessage `json:"trigger_data,omitempty"`

        // Message metadata
        EnqueuedAt time.Time `json:"enqueued_at"`
        RetryCount int       `json:"retry_count,omitempty"`

        // Tracing and correlation
        CorrelationID string `json:"correlation_id,omitempty"`
}

// NewExecutionMessage creates a new execution message
func NewExecutionMessage(executionID, tenantID, workflowID string, workflowVersion int, triggerType string, triggerData json.RawMessage) *ExecutionMessage <span class="cov8" title="1">{
        return &amp;ExecutionMessage{
                ExecutionID:     executionID,
                TenantID:        tenantID,
                WorkflowID:      workflowID,
                WorkflowVersion: workflowVersion,
                TriggerType:     triggerType,
                TriggerData:     triggerData,
                EnqueuedAt:      time.Now().UTC(),
                RetryCount:      0,
        }
}</span>

// Marshal serializes the execution message to JSON
func (m *ExecutionMessage) Marshal() (string, error) <span class="cov8" title="1">{
        data, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal execution message: %w", err)
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

// UnmarshalExecutionMessage deserializes an execution message from JSON
func UnmarshalExecutionMessage(data string) (*ExecutionMessage, error) <span class="cov8" title="1">{
        var msg ExecutionMessage
        if err := json.Unmarshal([]byte(data), &amp;msg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal execution message: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;msg, nil</span>
}

// Validate checks if the execution message is valid
func (m *ExecutionMessage) Validate() error <span class="cov8" title="1">{
        if m.ExecutionID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("execution_id is required")
        }</span>
        <span class="cov8" title="1">if m.TenantID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("tenant_id is required")
        }</span>
        <span class="cov8" title="1">if m.WorkflowID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("workflow_id is required")
        }</span>
        <span class="cov8" title="1">if m.WorkflowVersion &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("workflow_version must be greater than 0")
        }</span>
        <span class="cov8" title="1">if m.TriggerType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("trigger_type is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetMessageAttributes returns message attributes for SQS
func (m *ExecutionMessage) GetMessageAttributes() map[string]string <span class="cov8" title="1">{
        attrs := map[string]string{
                "tenant_id":   m.TenantID,
                "workflow_id": m.WorkflowID,
                "trigger_type": m.TriggerType,
        }

        if m.CorrelationID != "" </span><span class="cov8" title="1">{
                attrs["correlation_id"] = m.CorrelationID
        }</span>

        <span class="cov8" title="1">return attrs</span>
}

// IncrementRetryCount increments the retry count
func (m *ExecutionMessage) IncrementRetryCount() <span class="cov8" title="1">{
        m.RetryCount++
}</span>

// ShouldRetry determines if the message should be retried based on retry count
func (m *ExecutionMessage) ShouldRetry(maxRetries int) bool <span class="cov8" title="1">{
        return m.RetryCount &lt; maxRetries
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package queue

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"
)

// MetricsCollector collects queue metrics
type MetricsCollector struct {
        sqsClient *SQSClient
        logger    *slog.Logger
        metrics   *QueueMetrics
        mu        sync.RWMutex
        stopChan  chan struct{}
        interval  time.Duration
}

// QueueMetrics represents queue metrics
type QueueMetrics struct {
        // Main queue metrics
        ApproximateNumberOfMessages            int
        ApproximateNumberOfMessagesNotVisible  int
        ApproximateNumberOfMessagesDelayed     int

        // Dead-letter queue metrics
        DLQApproximateNumberOfMessages int

        // Calculated metrics
        TotalMessages int // Messages + NotVisible + Delayed
        QueueDepth    int // Same as TotalMessages for backward compatibility

        // Timestamp
        LastUpdated time.Time
}

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector(sqsClient *SQSClient, interval time.Duration, logger *slog.Logger) *MetricsCollector <span class="cov0" title="0">{
        if interval &lt;= 0 </span><span class="cov0" title="0">{
                interval = 30 * time.Second // Default to 30 seconds
        }</span>

        <span class="cov0" title="0">return &amp;MetricsCollector{
                sqsClient: sqsClient,
                logger:    logger,
                metrics:   &amp;QueueMetrics{},
                stopChan:  make(chan struct{}),
                interval:  interval,
        }</span>
}

// Start begins collecting metrics
func (c *MetricsCollector) Start(ctx context.Context) error <span class="cov0" title="0">{
        c.logger.Info("starting metrics collector", "interval", c.interval)

        ticker := time.NewTicker(c.interval)
        defer ticker.Stop()

        // Collect initial metrics
        if err := c.collectMetrics(ctx); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to collect initial metrics", "error", err)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        c.logger.Info("metrics collector stopping")
                        return ctx.Err()</span>
                case &lt;-c.stopChan:<span class="cov0" title="0">
                        c.logger.Info("metrics collector stopped")
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := c.collectMetrics(ctx); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("failed to collect metrics", "error", err)
                        }</span>
                }
        }
}

// Stop stops the metrics collector
func (c *MetricsCollector) Stop() <span class="cov0" title="0">{
        close(c.stopChan)
}</span>

// collectMetrics collects metrics from SQS
func (c *MetricsCollector) collectMetrics(ctx context.Context) error <span class="cov0" title="0">{
        // Get main queue attributes
        attrs, err := c.sqsClient.GetQueueAttributes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get queue attributes: %w", err)
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        defer c.mu.Unlock()

        c.metrics.ApproximateNumberOfMessages = attrs.ApproximateNumberOfMessages
        c.metrics.ApproximateNumberOfMessagesNotVisible = attrs.ApproximateNumberOfMessagesNotVisible
        c.metrics.ApproximateNumberOfMessagesDelayed = attrs.ApproximateNumberOfMessagesDelayed

        // Calculate total messages
        c.metrics.TotalMessages = attrs.ApproximateNumberOfMessages +
                attrs.ApproximateNumberOfMessagesNotVisible +
                attrs.ApproximateNumberOfMessagesDelayed
        c.metrics.QueueDepth = c.metrics.TotalMessages

        // Get DLQ attributes if configured
        dlqAttrs, err := c.sqsClient.GetDLQAttributes(ctx)
        if err == nil </span><span class="cov0" title="0">{
                c.metrics.DLQApproximateNumberOfMessages = dlqAttrs.ApproximateNumberOfMessages
        }</span> else<span class="cov0" title="0"> {
                // DLQ might not be configured, don't log as error
                c.logger.Debug("DLQ metrics not available", "error", err)
        }</span>

        <span class="cov0" title="0">c.metrics.LastUpdated = time.Now()

        c.logger.Debug("metrics collected",
                "visible", c.metrics.ApproximateNumberOfMessages,
                "not_visible", c.metrics.ApproximateNumberOfMessagesNotVisible,
                "delayed", c.metrics.ApproximateNumberOfMessagesDelayed,
                "total", c.metrics.TotalMessages,
                "dlq", c.metrics.DLQApproximateNumberOfMessages,
        )

        return nil</span>
}

// GetMetrics returns the current metrics
func (c *MetricsCollector) GetMetrics() QueueMetrics <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return *c.metrics
}</span>

// GetQueueDepth returns the current queue depth (total messages)
func (c *MetricsCollector) GetQueueDepth() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.metrics.QueueDepth
}</span>

// GetDLQDepth returns the dead-letter queue depth
func (c *MetricsCollector) GetDLQDepth() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.metrics.DLQApproximateNumberOfMessages
}</span>

// IsHealthy returns true if the queue is healthy
// A queue is considered unhealthy if:
// - DLQ has messages (indicating failures)
// - Queue depth is extremely high (configurable threshold)
func (c *MetricsCollector) IsHealthy(maxQueueDepth int) bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        // Check DLQ - any messages indicate issues
        if c.metrics.DLQApproximateNumberOfMessages &gt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check queue depth if threshold is configured
        <span class="cov0" title="0">if maxQueueDepth &gt; 0 &amp;&amp; c.metrics.QueueDepth &gt; maxQueueDepth </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetHealthStatus returns a detailed health status
func (c *MetricsCollector) GetHealthStatus(maxQueueDepth int) HealthStatus <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        status := HealthStatus{
                Healthy:     true,
                QueueDepth:  c.metrics.QueueDepth,
                DLQDepth:    c.metrics.DLQApproximateNumberOfMessages,
                LastChecked: c.metrics.LastUpdated,
        }

        // Check DLQ
        if c.metrics.DLQApproximateNumberOfMessages &gt; 0 </span><span class="cov0" title="0">{
                status.Healthy = false
                status.Issues = append(status.Issues, fmt.Sprintf("DLQ contains %d messages", c.metrics.DLQApproximateNumberOfMessages))
        }</span>

        // Check queue depth
        <span class="cov0" title="0">if maxQueueDepth &gt; 0 &amp;&amp; c.metrics.QueueDepth &gt; maxQueueDepth </span><span class="cov0" title="0">{
                status.Healthy = false
                status.Issues = append(status.Issues, fmt.Sprintf("Queue depth %d exceeds threshold %d", c.metrics.QueueDepth, maxQueueDepth))
        }</span>

        // Check if metrics are stale (haven't been updated in 5 minutes)
        <span class="cov0" title="0">if time.Since(c.metrics.LastUpdated) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                status.Healthy = false
                status.Issues = append(status.Issues, "Metrics are stale")
        }</span>

        <span class="cov0" title="0">return status</span>
}

// HealthStatus represents the health status of the queue
type HealthStatus struct {
        Healthy     bool
        QueueDepth  int
        DLQDepth    int
        LastChecked time.Time
        Issues      []string
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package queue

import (
        "context"
        "fmt"
        "log/slog"
        "time"
)

// Publisher handles publishing messages to the queue
type Publisher struct {
        sqsClient *SQSClient
        logger    *slog.Logger
        metrics   *PublisherMetrics
}

// PublisherMetrics tracks publisher performance
type PublisherMetrics struct {
        TotalPublished int64
        TotalFailed    int64
        LastPublishAt  time.Time
}

// NewPublisher creates a new queue publisher
func NewPublisher(sqsClient *SQSClient, logger *slog.Logger) *Publisher <span class="cov0" title="0">{
        return &amp;Publisher{
                sqsClient: sqsClient,
                logger:    logger,
                metrics:   &amp;PublisherMetrics{},
        }
}</span>

// PublishExecution publishes a workflow execution message to the queue
func (p *Publisher) PublishExecution(ctx context.Context, msg *ExecutionMessage) error <span class="cov0" title="0">{
        // Validate message
        if err := msg.Validate(); err != nil </span><span class="cov0" title="0">{
                p.logger.Error("invalid execution message", "error", err)
                return fmt.Errorf("invalid message: %w", err)
        }</span>

        // Marshal message to JSON
        <span class="cov0" title="0">body, err := msg.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to marshal message", "error", err)
                p.metrics.TotalFailed++
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Get message attributes
        <span class="cov0" title="0">attributes := msg.GetMessageAttributes()

        // Send message to SQS
        messageID, err := p.sqsClient.SendMessage(ctx, body, attributes)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to publish execution message",
                        "error", err,
                        "execution_id", msg.ExecutionID,
                        "workflow_id", msg.WorkflowID,
                )
                p.metrics.TotalFailed++
                return fmt.Errorf("failed to publish message: %w", err)
        }</span>

        // Update metrics
        <span class="cov0" title="0">p.metrics.TotalPublished++
        p.metrics.LastPublishAt = time.Now()

        p.logger.Info("execution message published",
                "execution_id", msg.ExecutionID,
                "workflow_id", msg.WorkflowID,
                "tenant_id", msg.TenantID,
                "message_id", *messageID,
        )

        return nil</span>
}

// PublishExecutionBatch publishes multiple workflow execution messages to the queue
func (p *Publisher) PublishExecutionBatch(ctx context.Context, messages []*ExecutionMessage) error <span class="cov0" title="0">{
        if len(messages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(messages) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch size cannot exceed 10 messages")
        }</span>

        // Validate and prepare batch messages
        <span class="cov0" title="0">batchMessages := make([]BatchMessage, 0, len(messages))
        for _, msg := range messages </span><span class="cov0" title="0">{
                // Validate message
                if err := msg.Validate(); err != nil </span><span class="cov0" title="0">{
                        p.logger.Error("invalid execution message in batch", "error", err, "execution_id", msg.ExecutionID)
                        return fmt.Errorf("invalid message in batch: %w", err)
                }</span>

                // Marshal message to JSON
                <span class="cov0" title="0">body, err := msg.Marshal()
                if err != nil </span><span class="cov0" title="0">{
                        p.logger.Error("failed to marshal message in batch", "error", err, "execution_id", msg.ExecutionID)
                        p.metrics.TotalFailed++
                        return fmt.Errorf("failed to marshal message in batch: %w", err)
                }</span>

                <span class="cov0" title="0">batchMessages = append(batchMessages, BatchMessage{
                        Body:       body,
                        Attributes: msg.GetMessageAttributes(),
                })</span>
        }

        // Send batch to SQS
        <span class="cov0" title="0">if err := p.sqsClient.SendMessageBatch(ctx, batchMessages); err != nil </span><span class="cov0" title="0">{
                p.logger.Error("failed to publish execution batch", "error", err, "count", len(messages))
                p.metrics.TotalFailed += int64(len(messages))
                return fmt.Errorf("failed to publish batch: %w", err)
        }</span>

        // Update metrics
        <span class="cov0" title="0">p.metrics.TotalPublished += int64(len(messages))
        p.metrics.LastPublishAt = time.Now()

        p.logger.Info("execution batch published", "count", len(messages))

        return nil</span>
}

// GetMetrics returns publisher metrics
func (p *Publisher) GetMetrics() PublisherMetrics <span class="cov0" title="0">{
        return *p.metrics
}</span>

// ResetMetrics resets publisher metrics
func (p *Publisher) ResetMetrics() <span class="cov0" title="0">{
        p.metrics.TotalPublished = 0
        p.metrics.TotalFailed = 0
        p.metrics.LastPublishAt = time.Time{}
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package queue

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
)

// PublisherAdapter adapts the queue Publisher to the workflow service interface
type PublisherAdapter struct {
        publisher *Publisher
        logger    *slog.Logger
}

// NewPublisherAdapter creates a new publisher adapter
func NewPublisherAdapter(publisher *Publisher, logger *slog.Logger) *PublisherAdapter <span class="cov0" title="0">{
        return &amp;PublisherAdapter{
                publisher: publisher,
                logger:    logger,
        }
}</span>

// PublishExecution publishes an execution message to the queue
// This method accepts a generic interface{} to match the workflow service interface
func (a *PublisherAdapter) PublishExecution(ctx context.Context, msg interface{}) error <span class="cov0" title="0">{
        // Convert the interface to a map
        msgMap, ok := msg.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid message type: expected map[string]interface{}")
        }</span>

        // Extract required fields
        <span class="cov0" title="0">executionID, ok := msgMap["execution_id"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("execution_id is required")
        }</span>

        <span class="cov0" title="0">tenantID, ok := msgMap["tenant_id"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("tenant_id is required")
        }</span>

        <span class="cov0" title="0">workflowID, ok := msgMap["workflow_id"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("workflow_id is required")
        }</span>

        <span class="cov0" title="0">workflowVersion, ok := msgMap["workflow_version"].(int)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("workflow_version is required")
        }</span>

        <span class="cov0" title="0">triggerType, ok := msgMap["trigger_type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("trigger_type is required")
        }</span>

        // Extract optional trigger data
        <span class="cov0" title="0">var triggerData json.RawMessage
        if td, exists := msgMap["trigger_data"]; exists </span><span class="cov0" title="0">{
                switch v := td.(type) </span>{
                case []byte:<span class="cov0" title="0">
                        triggerData = v</span>
                case string:<span class="cov0" title="0">
                        triggerData = []byte(v)</span>
                case json.RawMessage:<span class="cov0" title="0">
                        triggerData = v</span>
                default:<span class="cov0" title="0">
                        // Try to marshal it
                        data, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal trigger_data: %w", err)
                        }</span>
                        <span class="cov0" title="0">triggerData = data</span>
                }
        }

        // Create execution message
        <span class="cov0" title="0">execMsg := NewExecutionMessage(
                executionID,
                tenantID,
                workflowID,
                workflowVersion,
                triggerType,
                triggerData,
        )

        // Publish to queue
        return a.publisher.PublishExecution(ctx, execMsg)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package queue

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/aws/aws-sdk-go-v2/service/sqs/types"
)

// SQSClient wraps AWS SQS functionality
type SQSClient struct {
        client   *sqs.Client
        queueURL string
        dlqURL   string
        logger   *slog.Logger
}

// SQSConfig holds configuration for SQS client
type SQSConfig struct {
        QueueURL        string
        DLQueueURL      string
        Region          string
        AccessKeyID     string
        SecretAccessKey string
        Endpoint        string // For LocalStack or custom endpoints
}

// NewSQSClient creates a new SQS client
func NewSQSClient(ctx context.Context, cfg SQSConfig, logger *slog.Logger) (*SQSClient, error) <span class="cov0" title="0">{
        if cfg.QueueURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("queue URL is required")
        }</span>

        // Build AWS config options
        <span class="cov0" title="0">var opts []func(*config.LoadOptions) error
        opts = append(opts, config.WithRegion(cfg.Region))

        // Use static credentials if provided (for LocalStack)
        if cfg.AccessKeyID != "" &amp;&amp; cfg.SecretAccessKey != "" </span><span class="cov0" title="0">{
                opts = append(opts, config.WithCredentialsProvider(
                        credentials.NewStaticCredentialsProvider(cfg.AccessKeyID, cfg.SecretAccessKey, ""),
                ))
        }</span>

        // Load AWS configuration
        <span class="cov0" title="0">awsCfg, err := config.LoadDefaultConfig(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>

        // Create SQS client with custom endpoint if provided (for LocalStack)
        <span class="cov0" title="0">var clientOpts []func(*sqs.Options)
        if cfg.Endpoint != "" </span><span class="cov0" title="0">{
                clientOpts = append(clientOpts, func(o *sqs.Options) </span><span class="cov0" title="0">{
                        o.BaseEndpoint = aws.String(cfg.Endpoint)
                }</span>)
                <span class="cov0" title="0">logger.Info("using custom SQS endpoint", "endpoint", cfg.Endpoint)</span>
        }

        <span class="cov0" title="0">client := sqs.NewFromConfig(awsCfg, clientOpts...)

        logger.Info("SQS client initialized",
                "queue_url", cfg.QueueURL,
                "dlq_url", cfg.DLQueueURL,
                "region", cfg.Region,
        )

        return &amp;SQSClient{
                client:   client,
                queueURL: cfg.QueueURL,
                dlqURL:   cfg.DLQueueURL,
                logger:   logger,
        }, nil</span>
}

// SendMessage sends a message to the SQS queue
func (c *SQSClient) SendMessage(ctx context.Context, messageBody string, attributes map[string]string) (*string, error) <span class="cov0" title="0">{
        input := &amp;sqs.SendMessageInput{
                QueueUrl:    aws.String(c.queueURL),
                MessageBody: aws.String(messageBody),
        }

        // Add message attributes if provided
        if len(attributes) &gt; 0 </span><span class="cov0" title="0">{
                msgAttrs := make(map[string]types.MessageAttributeValue)
                for key, value := range attributes </span><span class="cov0" title="0">{
                        msgAttrs[key] = types.MessageAttributeValue{
                                DataType:    aws.String("String"),
                                StringValue: aws.String(value),
                        }
                }</span>
                <span class="cov0" title="0">input.MessageAttributes = msgAttrs</span>
        }

        <span class="cov0" title="0">result, err := c.client.SendMessage(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to send message to SQS", "error", err)
                return nil, fmt.Errorf("failed to send message: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("message sent to SQS", "message_id", *result.MessageId)
        return result.MessageId, nil</span>
}

// SendMessageBatch sends multiple messages to the SQS queue in a single request
func (c *SQSClient) SendMessageBatch(ctx context.Context, messages []BatchMessage) error <span class="cov0" title="0">{
        if len(messages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(messages) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch size cannot exceed 10 messages")
        }</span>

        <span class="cov0" title="0">entries := make([]types.SendMessageBatchRequestEntry, 0, len(messages))
        for i, msg := range messages </span><span class="cov0" title="0">{
                entry := types.SendMessageBatchRequestEntry{
                        Id:          aws.String(fmt.Sprintf("msg-%d", i)),
                        MessageBody: aws.String(msg.Body),
                }

                // Add message attributes if provided
                if len(msg.Attributes) &gt; 0 </span><span class="cov0" title="0">{
                        msgAttrs := make(map[string]types.MessageAttributeValue)
                        for key, value := range msg.Attributes </span><span class="cov0" title="0">{
                                msgAttrs[key] = types.MessageAttributeValue{
                                        DataType:    aws.String("String"),
                                        StringValue: aws.String(value),
                                }
                        }</span>
                        <span class="cov0" title="0">entry.MessageAttributes = msgAttrs</span>
                }

                <span class="cov0" title="0">entries = append(entries, entry)</span>
        }

        <span class="cov0" title="0">result, err := c.client.SendMessageBatch(ctx, &amp;sqs.SendMessageBatchInput{
                QueueUrl: aws.String(c.queueURL),
                Entries:  entries,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to send batch messages to SQS", "error", err)
                return fmt.Errorf("failed to send batch messages: %w", err)
        }</span>

        // Log any failed messages
        <span class="cov0" title="0">if len(result.Failed) &gt; 0 </span><span class="cov0" title="0">{
                c.logger.Warn("some messages failed to send", "count", len(result.Failed))
                for _, failed := range result.Failed </span><span class="cov0" title="0">{
                        c.logger.Error("message send failed",
                                "id", *failed.Id,
                                "code", *failed.Code,
                                "message", *failed.Message,
                        )
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to send %d messages", len(result.Failed))</span>
        }

        <span class="cov0" title="0">c.logger.Debug("batch messages sent to SQS", "count", len(result.Successful))
        return nil</span>
}

// ReceiveMessages receives messages from the SQS queue
func (c *SQSClient) ReceiveMessages(ctx context.Context, maxMessages int32, waitTimeSeconds int32) ([]Message, error) <span class="cov0" title="0">{
        if maxMessages &lt;= 0 || maxMessages &gt; 10 </span><span class="cov0" title="0">{
                maxMessages = 10
        }</span>

        <span class="cov0" title="0">if waitTimeSeconds &lt; 0 || waitTimeSeconds &gt; 20 </span><span class="cov0" title="0">{
                waitTimeSeconds = 20 // Maximum long polling time
        }</span>

        <span class="cov0" title="0">result, err := c.client.ReceiveMessage(ctx, &amp;sqs.ReceiveMessageInput{
                QueueUrl:              aws.String(c.queueURL),
                MaxNumberOfMessages:   maxMessages,
                WaitTimeSeconds:       waitTimeSeconds,
                MessageAttributeNames: []string{"All"},
                AttributeNames:        []types.QueueAttributeName{types.QueueAttributeNameAll},
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to receive messages from SQS", "error", err)
                return nil, fmt.Errorf("failed to receive messages: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result.Messages) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">messages := make([]Message, 0, len(result.Messages))
        for _, msg := range result.Messages </span><span class="cov0" title="0">{
                attributes := make(map[string]string)
                for key, value := range msg.MessageAttributes </span><span class="cov0" title="0">{
                        if value.StringValue != nil </span><span class="cov0" title="0">{
                                attributes[key] = *value.StringValue
                        }</span>
                }

                <span class="cov0" title="0">messages = append(messages, Message{
                        ID:              *msg.MessageId,
                        Body:            *msg.Body,
                        ReceiptHandle:   *msg.ReceiptHandle,
                        Attributes:      attributes,
                        ApproximateReceiveCount: getApproximateReceiveCount(msg.Attributes),
                })</span>
        }

        <span class="cov0" title="0">c.logger.Debug("received messages from SQS", "count", len(messages))
        return messages, nil</span>
}

// DeleteMessage deletes a message from the queue
func (c *SQSClient) DeleteMessage(ctx context.Context, receiptHandle string) error <span class="cov0" title="0">{
        _, err := c.client.DeleteMessage(ctx, &amp;sqs.DeleteMessageInput{
                QueueUrl:      aws.String(c.queueURL),
                ReceiptHandle: aws.String(receiptHandle),
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to delete message from SQS", "error", err)
                return fmt.Errorf("failed to delete message: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("message deleted from SQS")
        return nil</span>
}

// DeleteMessageBatch deletes multiple messages from the queue
func (c *SQSClient) DeleteMessageBatch(ctx context.Context, receiptHandles []string) error <span class="cov0" title="0">{
        if len(receiptHandles) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(receiptHandles) &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("batch size cannot exceed 10 messages")
        }</span>

        <span class="cov0" title="0">entries := make([]types.DeleteMessageBatchRequestEntry, 0, len(receiptHandles))
        for i, handle := range receiptHandles </span><span class="cov0" title="0">{
                entries = append(entries, types.DeleteMessageBatchRequestEntry{
                        Id:            aws.String(fmt.Sprintf("msg-%d", i)),
                        ReceiptHandle: aws.String(handle),
                })
        }</span>

        <span class="cov0" title="0">result, err := c.client.DeleteMessageBatch(ctx, &amp;sqs.DeleteMessageBatchInput{
                QueueUrl: aws.String(c.queueURL),
                Entries:  entries,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to delete batch messages from SQS", "error", err)
                return fmt.Errorf("failed to delete batch messages: %w", err)
        }</span>

        // Log any failed deletions
        <span class="cov0" title="0">if len(result.Failed) &gt; 0 </span><span class="cov0" title="0">{
                c.logger.Warn("some messages failed to delete", "count", len(result.Failed))
                for _, failed := range result.Failed </span><span class="cov0" title="0">{
                        c.logger.Error("message deletion failed",
                                "id", *failed.Id,
                                "code", *failed.Code,
                                "message", *failed.Message,
                        )
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete %d messages", len(result.Failed))</span>
        }

        <span class="cov0" title="0">c.logger.Debug("batch messages deleted from SQS", "count", len(result.Successful))
        return nil</span>
}

// ChangeMessageVisibility changes the visibility timeout of a message
func (c *SQSClient) ChangeMessageVisibility(ctx context.Context, receiptHandle string, visibilityTimeout int32) error <span class="cov0" title="0">{
        _, err := c.client.ChangeMessageVisibility(ctx, &amp;sqs.ChangeMessageVisibilityInput{
                QueueUrl:          aws.String(c.queueURL),
                ReceiptHandle:     aws.String(receiptHandle),
                VisibilityTimeout: visibilityTimeout,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to change message visibility", "error", err)
                return fmt.Errorf("failed to change message visibility: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("message visibility changed", "timeout", visibilityTimeout)
        return nil</span>
}

// GetQueueAttributes retrieves queue attributes
func (c *SQSClient) GetQueueAttributes(ctx context.Context) (*QueueAttributes, error) <span class="cov0" title="0">{
        result, err := c.client.GetQueueAttributes(ctx, &amp;sqs.GetQueueAttributesInput{
                QueueUrl: aws.String(c.queueURL),
                AttributeNames: []types.QueueAttributeName{
                        types.QueueAttributeNameApproximateNumberOfMessages,
                        types.QueueAttributeNameApproximateNumberOfMessagesNotVisible,
                        types.QueueAttributeNameApproximateNumberOfMessagesDelayed,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to get queue attributes", "error", err)
                return nil, fmt.Errorf("failed to get queue attributes: %w", err)
        }</span>

        <span class="cov0" title="0">attrs := &amp;QueueAttributes{}
        if val, ok := result.Attributes[string(types.QueueAttributeNameApproximateNumberOfMessages)]; ok </span><span class="cov0" title="0">{
                fmt.Sscanf(val, "%d", &amp;attrs.ApproximateNumberOfMessages)
        }</span>
        <span class="cov0" title="0">if val, ok := result.Attributes[string(types.QueueAttributeNameApproximateNumberOfMessagesNotVisible)]; ok </span><span class="cov0" title="0">{
                fmt.Sscanf(val, "%d", &amp;attrs.ApproximateNumberOfMessagesNotVisible)
        }</span>
        <span class="cov0" title="0">if val, ok := result.Attributes[string(types.QueueAttributeNameApproximateNumberOfMessagesDelayed)]; ok </span><span class="cov0" title="0">{
                fmt.Sscanf(val, "%d", &amp;attrs.ApproximateNumberOfMessagesDelayed)
        }</span>

        <span class="cov0" title="0">return attrs, nil</span>
}

// GetDLQAttributes retrieves dead-letter queue attributes
func (c *SQSClient) GetDLQAttributes(ctx context.Context) (*QueueAttributes, error) <span class="cov0" title="0">{
        if c.dlqURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dead-letter queue URL not configured")
        }</span>

        <span class="cov0" title="0">result, err := c.client.GetQueueAttributes(ctx, &amp;sqs.GetQueueAttributesInput{
                QueueUrl: aws.String(c.dlqURL),
                AttributeNames: []types.QueueAttributeName{
                        types.QueueAttributeNameApproximateNumberOfMessages,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to get DLQ attributes", "error", err)
                return nil, fmt.Errorf("failed to get DLQ attributes: %w", err)
        }</span>

        <span class="cov0" title="0">attrs := &amp;QueueAttributes{}
        if val, ok := result.Attributes[string(types.QueueAttributeNameApproximateNumberOfMessages)]; ok </span><span class="cov0" title="0">{
                fmt.Sscanf(val, "%d", &amp;attrs.ApproximateNumberOfMessages)
        }</span>

        <span class="cov0" title="0">return attrs, nil</span>
}

// Message represents an SQS message
type Message struct {
        ID                      string
        Body                    string
        ReceiptHandle           string
        Attributes              map[string]string
        ApproximateReceiveCount int
}

// BatchMessage represents a message for batch sending
type BatchMessage struct {
        Body       string
        Attributes map[string]string
}

// QueueAttributes represents queue metrics
type QueueAttributes struct {
        ApproximateNumberOfMessages            int
        ApproximateNumberOfMessagesNotVisible  int
        ApproximateNumberOfMessagesDelayed     int
}

// Helper function to extract approximate receive count from message attributes
func getApproximateReceiveCount(attrs map[string]string) int <span class="cov0" title="0">{
        if val, ok := attrs[string(types.MessageSystemAttributeNameApproximateReceiveCount)]; ok </span><span class="cov0" title="0">{
                var count int
                fmt.Sscanf(val, "%d", &amp;count)
                return count
        }</span>
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package quota

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/gorax/gorax/internal/workflow"
)

// ExecutorMiddleware wraps an executor and tracks quota usage
type ExecutorMiddleware struct {
        tracker *Tracker
        logger  *slog.Logger
}

// NewExecutorMiddleware creates a new executor middleware
func NewExecutorMiddleware(tracker *Tracker, logger *slog.Logger) *ExecutorMiddleware <span class="cov0" title="0">{
        return &amp;ExecutorMiddleware{
                tracker: tracker,
                logger:  logger,
        }
}</span>

// BeforeExecute is called before workflow execution starts
func (m *ExecutorMiddleware) BeforeExecute(ctx context.Context, execution *workflow.Execution) error <span class="cov0" title="0">{
        // Increment workflow execution counter
        if err := m.tracker.IncrementWorkflowExecutions(ctx, execution.TenantID, PeriodDaily); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to increment daily workflow executions",
                        "error", err,
                        "tenant_id", execution.TenantID,
                        "execution_id", execution.ID,
                )
                // Don't fail execution on tracking error
        }</span>

        <span class="cov0" title="0">if err := m.tracker.IncrementWorkflowExecutions(ctx, execution.TenantID, PeriodMonthly); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to increment monthly workflow executions",
                        "error", err,
                        "tenant_id", execution.TenantID,
                        "execution_id", execution.ID,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AfterExecute is called after workflow execution completes
func (m *ExecutorMiddleware) AfterExecute(ctx context.Context, execution *workflow.Execution, err error) <span class="cov0" title="0">{
        // If execution was cancelled or failed early, optionally decrement
        // For now, we count all started executions regardless of outcome
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Debug("execution completed with error",
                        "error", err,
                        "execution_id", execution.ID,
                )
        }</span>
}

// OnStepExecute is called for each step execution
func (m *ExecutorMiddleware) OnStepExecute(ctx context.Context, tenantID, executionID, nodeID string) <span class="cov0" title="0">{
        // Increment step execution counter
        if err := m.tracker.IncrementStepExecutions(ctx, tenantID, PeriodDaily); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to increment daily step executions",
                        "error", err,
                        "tenant_id", tenantID,
                        "execution_id", executionID,
                        "node_id", nodeID,
                )
        }</span>

        <span class="cov0" title="0">if err := m.tracker.IncrementStepExecutions(ctx, tenantID, PeriodMonthly); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to increment monthly step executions",
                        "error", err,
                        "tenant_id", tenantID,
                        "execution_id", executionID,
                        "node_id", nodeID,
                )
        }</span>
}

// CheckQuotaBeforeExecution checks if tenant can execute workflow
func (m *ExecutorMiddleware) CheckQuotaBeforeExecution(ctx context.Context, tenantID string, quotas TenantQuotas) error <span class="cov0" title="0">{
        // Check daily execution quota
        if quotas.MaxExecutionsPerDay &gt; 0 </span><span class="cov0" title="0">{
                exceeded, remaining, err := m.tracker.CheckQuota(ctx, tenantID, PeriodDaily, int64(quotas.MaxExecutionsPerDay))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check quota: %w", err)
                }</span>

                <span class="cov0" title="0">if exceeded </span><span class="cov0" title="0">{
                        return fmt.Errorf("daily execution quota exceeded (0 remaining)")
                }</span>

                <span class="cov0" title="0">m.logger.Debug("quota check passed",
                        "tenant_id", tenantID,
                        "remaining", remaining,
                        "period", "daily",
                )</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// TenantQuotas represents tenant quota limits
type TenantQuotas struct {
        MaxExecutionsPerDay int `json:"max_executions_per_day"`
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package quota

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

var (
        // ErrInvalidTenantID is returned when tenant ID is empty
        ErrInvalidTenantID = errors.New("tenant ID cannot be empty")
        // ErrInvalidPeriod is returned when period is invalid
        ErrInvalidPeriod = errors.New("invalid period")
        // ErrInvalidDateRange is returned when date range is invalid
        ErrInvalidDateRange = errors.New("end date must be after start date")
)

// Period represents a time period for quota tracking
type Period string

const (
        // PeriodDaily represents daily quota tracking
        PeriodDaily Period = "daily"
        // PeriodMonthly represents monthly quota tracking
        PeriodMonthly Period = "monthly"
)

// UsageByDate represents usage statistics for a specific date
type UsageByDate struct {
        Date               string `json:"date"`
        WorkflowExecutions int64  `json:"workflow_executions"`
        StepExecutions     int64  `json:"step_executions"`
}

// Tracker handles quota tracking using Redis
type Tracker struct {
        client *redis.Client
}

// NewTracker creates a new quota tracker
func NewTracker(client *redis.Client) *Tracker <span class="cov8" title="1">{
        return &amp;Tracker{
                client: client,
        }
}</span>

// IncrementWorkflowExecutions increments workflow execution count
func (t *Tracker) IncrementWorkflowExecutions(ctx context.Context, tenantID string, period Period) error <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov8" title="1">{
                return ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if !isValidPeriod(period) </span><span class="cov8" title="1">{
                return ErrInvalidPeriod
        }</span>

        <span class="cov8" title="1">key := t.periodKey(tenantID, period, "workflow")
        ttl := t.getTTL(period)

        pipe := t.client.Pipeline()
        pipe.Incr(ctx, key)
        pipe.Expire(ctx, key, ttl)
        _, err := pipe.Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to increment workflow executions: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IncrementStepExecutions increments step execution count
func (t *Tracker) IncrementStepExecutions(ctx context.Context, tenantID string, period Period) error <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if !isValidPeriod(period) </span><span class="cov0" title="0">{
                return ErrInvalidPeriod
        }</span>

        <span class="cov8" title="1">key := t.periodKey(tenantID, period, "step")
        ttl := t.getTTL(period)

        pipe := t.client.Pipeline()
        pipe.Incr(ctx, key)
        pipe.Expire(ctx, key, ttl)
        _, err := pipe.Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to increment step executions: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DecrementWorkflowExecutions decrements workflow execution count
func (t *Tracker) DecrementWorkflowExecutions(ctx context.Context, tenantID string, period Period) error <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if !isValidPeriod(period) </span><span class="cov0" title="0">{
                return ErrInvalidPeriod
        }</span>

        <span class="cov8" title="1">key := t.periodKey(tenantID, period, "workflow")

        // Don't let it go below 0
        count, err := t.client.Get(ctx, key).Int64()
        if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current count: %w", err)
        }</span>

        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                err = t.client.Decr(ctx, key).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrement workflow executions: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetWorkflowExecutions returns workflow execution count for a period
func (t *Tracker) GetWorkflowExecutions(ctx context.Context, tenantID string, period Period) (int64, error) <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return 0, ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if !isValidPeriod(period) </span><span class="cov0" title="0">{
                return 0, ErrInvalidPeriod
        }</span>

        <span class="cov8" title="1">key := t.periodKey(tenantID, period, "workflow")
        count, err := t.client.Get(ctx, key).Int64()
        if err == redis.Nil </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get workflow executions: %w", err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// GetStepExecutions returns step execution count for a period
func (t *Tracker) GetStepExecutions(ctx context.Context, tenantID string, period Period) (int64, error) <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return 0, ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if !isValidPeriod(period) </span><span class="cov0" title="0">{
                return 0, ErrInvalidPeriod
        }</span>

        <span class="cov8" title="1">key := t.periodKey(tenantID, period, "step")
        count, err := t.client.Get(ctx, key).Int64()
        if err == redis.Nil </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get step executions: %w", err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// CheckQuota checks if quota is exceeded
// Returns: exceeded (bool), remaining (int64), error
func (t *Tracker) CheckQuota(ctx context.Context, tenantID string, period Period, quota int64) (bool, int64, error) <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return false, 0, ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if !isValidPeriod(period) </span><span class="cov0" title="0">{
                return false, 0, ErrInvalidPeriod
        }</span>

        // -1 means unlimited
        <span class="cov8" title="1">if quota == -1 </span><span class="cov8" title="1">{
                return false, -1, nil
        }</span>

        <span class="cov8" title="1">current, err := t.GetWorkflowExecutions(ctx, tenantID, period)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, err
        }</span>

        <span class="cov8" title="1">exceeded := current &gt;= quota
        remaining := quota - current
        if remaining &lt; 0 </span><span class="cov8" title="1">{
                remaining = 0
        }</span>

        <span class="cov8" title="1">return exceeded, remaining, nil</span>
}

// GetUsageByDateRange returns usage statistics for a date range
func (t *Tracker) GetUsageByDateRange(ctx context.Context, tenantID string, startDate, endDate time.Time) ([]UsageByDate, error) <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if endDate.Before(startDate) </span><span class="cov8" title="1">{
                return nil, ErrInvalidDateRange
        }</span>

        <span class="cov8" title="1">var usage []UsageByDate

        // Iterate through each day in the range
        currentDate := startDate
        for !currentDate.After(endDate) </span><span class="cov8" title="1">{
                workflowKey := t.dailyKey(tenantID, currentDate)
                stepKey := t.dailyKey(tenantID, currentDate) + ":step"

                workflowCount, err := t.client.Get(ctx, workflowKey).Int64()
                if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get workflow count for %s: %w", currentDate.Format("2006-01-02"), err)
                }</span>
                <span class="cov8" title="1">if err == redis.Nil </span><span class="cov0" title="0">{
                        workflowCount = 0
                }</span>

                <span class="cov8" title="1">stepCount, err := t.client.Get(ctx, stepKey).Int64()
                if err != nil &amp;&amp; err != redis.Nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get step count for %s: %w", currentDate.Format("2006-01-02"), err)
                }</span>
                <span class="cov8" title="1">if err == redis.Nil </span><span class="cov8" title="1">{
                        stepCount = 0
                }</span>

                <span class="cov8" title="1">usage = append(usage, UsageByDate{
                        Date:               currentDate.Format("2006-01-02"),
                        WorkflowExecutions: workflowCount,
                        StepExecutions:     stepCount,
                })

                currentDate = currentDate.AddDate(0, 0, 1)</span>
        }

        <span class="cov8" title="1">return usage, nil</span>
}

// Reset clears all quota data for a tenant
func (t *Tracker) Reset(ctx context.Context, tenantID string) error <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>

        <span class="cov8" title="1">pattern := fmt.Sprintf("quota:%s:*", tenantID)
        iter := t.client.Scan(ctx, 0, pattern, 0).Iterator()

        for iter.Next(ctx) </span><span class="cov8" title="1">{
                if err := t.client.Del(ctx, iter.Val()).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete key: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan keys: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// periodKey generates Redis key for period-based tracking
func (t *Tracker) periodKey(tenantID string, period Period, counter string) string <span class="cov8" title="1">{
        now := time.Now()

        switch period </span>{
        case PeriodDaily:<span class="cov8" title="1">
                return fmt.Sprintf("quota:%s:daily:%s:%s", tenantID, now.Format("2006-01-02"), counter)</span>
        case PeriodMonthly:<span class="cov8" title="1">
                return fmt.Sprintf("quota:%s:monthly:%s:%s", tenantID, now.Format("2006-01"), counter)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("quota:%s:%s:%s", tenantID, period, counter)</span>
        }
}

// dailyKey generates Redis key for a specific date
func (t *Tracker) dailyKey(tenantID string, date time.Time) string <span class="cov8" title="1">{
        return fmt.Sprintf("quota:%s:daily:%s:workflow", tenantID, date.Format("2006-01-02"))
}</span>

// getTTL returns appropriate TTL for a period
func (t *Tracker) getTTL(period Period) time.Duration <span class="cov8" title="1">{
        switch period </span>{
        case PeriodDaily:<span class="cov8" title="1">
                return 48 * time.Hour</span> // 2 days to handle timezone differences
        case PeriodMonthly:<span class="cov8" title="1">
                return 62 * 24 * time.Hour</span> // ~2 months
        default:<span class="cov0" title="0">
                return 48 * time.Hour</span>
        }
}

// isValidPeriod checks if period is valid
func isValidPeriod(period Period) bool <span class="cov8" title="1">{
        return period == PeriodDaily || period == PeriodMonthly
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package ratelimit

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

var (
        // ErrInvalidLimit is returned when limit is &lt;= 0
        ErrInvalidLimit = errors.New("limit must be greater than 0")
        // ErrInvalidWindow is returned when window is &lt;= 0
        ErrInvalidWindow = errors.New("window must be greater than 0")
        // ErrInvalidTenantID is returned when tenant ID is empty
        ErrInvalidTenantID = errors.New("tenant ID cannot be empty")
)

// SlidingWindowLimiter implements rate limiting using Redis sorted sets
// with sliding window algorithm for accurate rate limiting
type SlidingWindowLimiter struct {
        client *redis.Client
}

// NewSlidingWindowLimiter creates a new sliding window rate limiter
func NewSlidingWindowLimiter(client *redis.Client) *SlidingWindowLimiter <span class="cov8" title="1">{
        return &amp;SlidingWindowLimiter{
                client: client,
        }
}</span>

// Allow checks if a request is allowed under the rate limit
// Returns true if allowed, false if rate limit exceeded
func (l *SlidingWindowLimiter) Allow(ctx context.Context, tenantID string, limit int64, window time.Duration) (bool, error) <span class="cov8" title="1">{
        if err := l.validate(tenantID, limit, window); err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">key := l.key(tenantID, window)
        now := time.Now().UnixNano()
        windowStart := now - window.Nanoseconds()

        // Use Lua script for atomic operations
        script := redis.NewScript(`
                -- Remove expired entries
                redis.call('ZREMRANGEBYSCORE', KEYS[1], '-inf', ARGV[1])

                -- Count current entries
                local count = redis.call('ZCARD', KEYS[1])

                -- Check if under limit
                if tonumber(count) &lt; tonumber(ARGV[3]) then
                        -- Add new entry
                        redis.call('ZADD', KEYS[1], ARGV[2], ARGV[2])
                        -- Set expiration
                        redis.call('EXPIRE', KEYS[1], ARGV[4])
                        return 1
                else
                        return 0
                end
        `)

        result, err := script.Run(ctx, l.client, []string{key},
                windowStart, // ARGV[1] - window start
                now,         // ARGV[2] - current timestamp
                limit,       // ARGV[3] - limit
                int(window.Seconds())+1, // ARGV[4] - TTL
        ).Result()

        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("rate limit check failed: %w", err)
        }</span>

        // Result is 1 if allowed, 0 if blocked
        <span class="cov8" title="1">allowed := result.(int64) == 1
        return allowed, nil</span>
}

// GetUsage returns the current usage count within the window
func (l *SlidingWindowLimiter) GetUsage(ctx context.Context, tenantID string, window time.Duration) (int64, error) <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return 0, ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if window &lt;= 0 </span><span class="cov0" title="0">{
                return 0, ErrInvalidWindow
        }</span>

        <span class="cov8" title="1">key := l.key(tenantID, window)
        now := time.Now().UnixNano()
        windowStart := now - window.Nanoseconds()

        // Count entries in current window
        count, err := l.client.ZCount(ctx, key, fmt.Sprint(windowStart), "+inf").Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get usage: %w", err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// Reset clears all rate limit data for a tenant
func (l *SlidingWindowLimiter) Reset(ctx context.Context, tenantID string) error <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return ErrInvalidTenantID
        }</span>

        // Delete all keys for this tenant
        <span class="cov8" title="1">pattern := fmt.Sprintf("ratelimit:%s:*", tenantID)
        iter := l.client.Scan(ctx, 0, pattern, 0).Iterator()

        for iter.Next(ctx) </span><span class="cov8" title="1">{
                if err := l.client.Del(ctx, iter.Val()).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete key: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan keys: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validate checks if parameters are valid
func (l *SlidingWindowLimiter) validate(tenantID string, limit int64, window time.Duration) error <span class="cov8" title="1">{
        if tenantID == "" </span><span class="cov8" title="1">{
                return ErrInvalidTenantID
        }</span>
        <span class="cov8" title="1">if limit &lt;= 0 </span><span class="cov8" title="1">{
                return ErrInvalidLimit
        }</span>
        <span class="cov8" title="1">if window &lt;= 0 </span><span class="cov8" title="1">{
                return ErrInvalidWindow
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// key generates a Redis key for rate limiting
func (l *SlidingWindowLimiter) key(tenantID string, window time.Duration) string <span class="cov8" title="1">{
        return fmt.Sprintf("ratelimit:%s:window_%d", tenantID, int64(window.Seconds()))
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package schedule

import (
        "time"
)

// Schedule represents a scheduled workflow execution
type Schedule struct {
        ID              string     `db:"id" json:"id"`
        TenantID        string     `db:"tenant_id" json:"tenant_id"`
        WorkflowID      string     `db:"workflow_id" json:"workflow_id"`
        Name            string     `db:"name" json:"name"`
        CronExpression  string     `db:"cron_expression" json:"cron_expression"`
        Timezone        string     `db:"timezone" json:"timezone"`
        Enabled         bool       `db:"enabled" json:"enabled"`
        NextRunAt       *time.Time `db:"next_run_at" json:"next_run_at,omitempty"`
        LastRunAt       *time.Time `db:"last_run_at" json:"last_run_at,omitempty"`
        LastExecutionID *string    `db:"last_execution_id" json:"last_execution_id,omitempty"`
        CreatedBy       string     `db:"created_by" json:"created_by"`
        CreatedAt       time.Time  `db:"created_at" json:"created_at"`
        UpdatedAt       time.Time  `db:"updated_at" json:"updated_at"`
}

// CreateScheduleInput represents input for creating a schedule
type CreateScheduleInput struct {
        Name           string `json:"name" validate:"required,min=1,max=255"`
        CronExpression string `json:"cron_expression" validate:"required"`
        Timezone       string `json:"timezone,omitempty"`
        Enabled        bool   `json:"enabled"`
}

// UpdateScheduleInput represents input for updating a schedule
type UpdateScheduleInput struct {
        Name           *string `json:"name,omitempty"`
        CronExpression *string `json:"cron_expression,omitempty"`
        Timezone       *string `json:"timezone,omitempty"`
        Enabled        *bool   `json:"enabled,omitempty"`
}

// ScheduleWithWorkflow represents a schedule with workflow details
type ScheduleWithWorkflow struct {
        Schedule
        WorkflowName   string `db:"workflow_name" json:"workflow_name"`
        WorkflowStatus string `db:"workflow_status" json:"workflow_status"`
}

// ValidationError represents a validation error
type ValidationError struct {
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package schedule

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

var (
        ErrNotFound = errors.New("schedule not found")
)

// Repository handles schedule database operations
type Repository struct {
        db *sqlx.DB
}

// NewRepository creates a new schedule repository
func NewRepository(db *sqlx.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{db: db}
}</span>

// Create inserts a new schedule
func (r *Repository) Create(ctx context.Context, tenantID, workflowID, createdBy string, input CreateScheduleInput) (*Schedule, error) <span class="cov0" title="0">{
        id := uuid.New().String()
        now := time.Now()

        // Default timezone to UTC if not provided
        timezone := input.Timezone
        if timezone == "" </span><span class="cov0" title="0">{
                timezone = "UTC"
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO schedules (id, tenant_id, workflow_id, name, cron_expression, timezone, enabled, created_by, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING *
        `

        var schedule Schedule
        err := r.db.QueryRowxContext(
                ctx, query,
                id, tenantID, workflowID, input.Name, input.CronExpression, timezone, input.Enabled, createdBy, now, now,
        ).StructScan(&amp;schedule)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;schedule, nil</span>
}

// GetByID retrieves a schedule by ID (tenant-scoped)
func (r *Repository) GetByID(ctx context.Context, tenantID, id string) (*Schedule, error) <span class="cov0" title="0">{
        query := `SELECT * FROM schedules WHERE id = $1 AND tenant_id = $2`

        var schedule Schedule
        err := r.db.GetContext(ctx, &amp;schedule, query, id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;schedule, nil</span>
}

// GetByIDWithoutTenant retrieves a schedule by ID without tenant check (for scheduler)
func (r *Repository) GetByIDWithoutTenant(ctx context.Context, id string) (*Schedule, error) <span class="cov0" title="0">{
        query := `SELECT * FROM schedules WHERE id = $1`

        var schedule Schedule
        err := r.db.GetContext(ctx, &amp;schedule, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;schedule, nil</span>
}

// Update updates a schedule
func (r *Repository) Update(ctx context.Context, tenantID, id string, input UpdateScheduleInput) (*Schedule, error) <span class="cov0" title="0">{
        query := `
                UPDATE schedules
                SET name = COALESCE($3, name),
                    cron_expression = COALESCE($4, cron_expression),
                    timezone = COALESCE($5, timezone),
                    enabled = COALESCE($6, enabled),
                    updated_at = $7
                WHERE id = $1 AND tenant_id = $2
                RETURNING *
        `

        var schedule Schedule
        err := r.db.QueryRowxContext(
                ctx, query,
                id, tenantID, input.Name, input.CronExpression, input.Timezone, input.Enabled, time.Now(),
        ).StructScan(&amp;schedule)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;schedule, nil</span>
}

// Delete deletes a schedule
func (r *Repository) Delete(ctx context.Context, tenantID, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM schedules WHERE id = $1 AND tenant_id = $2`

        result, err := r.db.ExecContext(ctx, query, id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// List retrieves all schedules for a workflow
func (r *Repository) List(ctx context.Context, tenantID, workflowID string, limit, offset int) ([]*Schedule, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM schedules
                WHERE tenant_id = $1 AND workflow_id = $2
                ORDER BY created_at DESC
                LIMIT $3 OFFSET $4
        `

        var schedules []*Schedule
        err := r.db.SelectContext(ctx, &amp;schedules, query, tenantID, workflowID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return schedules, nil</span>
}

// ListAll retrieves all schedules for a tenant
func (r *Repository) ListAll(ctx context.Context, tenantID string, limit, offset int) ([]*ScheduleWithWorkflow, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        s.*,
                        w.name as workflow_name,
                        w.status as workflow_status
                FROM schedules s
                JOIN workflows w ON s.workflow_id = w.id
                WHERE s.tenant_id = $1
                ORDER BY s.created_at DESC
                LIMIT $2 OFFSET $3
        `

        var schedules []*ScheduleWithWorkflow
        err := r.db.SelectContext(ctx, &amp;schedules, query, tenantID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return schedules, nil</span>
}

// GetDueSchedules retrieves schedules that are due for execution
func (r *Repository) GetDueSchedules(ctx context.Context, beforeTime time.Time) ([]*Schedule, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM schedules
                WHERE enabled = true
                AND (next_run_at IS NULL OR next_run_at &lt;= $1)
                ORDER BY next_run_at ASC NULLS FIRST
                LIMIT 100
        `

        var schedules []*Schedule
        err := r.db.SelectContext(ctx, &amp;schedules, query, beforeTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return schedules, nil</span>
}

// UpdateNextRunTime updates the next run time for a schedule
func (r *Repository) UpdateNextRunTime(ctx context.Context, id string, nextRunAt time.Time) error <span class="cov0" title="0">{
        query := `
                UPDATE schedules
                SET next_run_at = $2,
                    updated_at = $3
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, id, nextRunAt, time.Now())
        return err
}</span>

// UpdateLastRun updates the last run information for a schedule
func (r *Repository) UpdateLastRun(ctx context.Context, id string, lastRunAt time.Time, executionID string, nextRunAt time.Time) error <span class="cov0" title="0">{
        query := `
                UPDATE schedules
                SET last_run_at = $2,
                    last_execution_id = $3,
                    next_run_at = $4,
                    updated_at = $5
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, id, lastRunAt, executionID, nextRunAt, time.Now())
        return err
}</span>

// Count returns the total number of schedules for a workflow
func (r *Repository) Count(ctx context.Context, tenantID, workflowID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM schedules WHERE tenant_id = $1 AND workflow_id = $2`

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, tenantID, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// CountAll returns the total number of schedules for a tenant
func (r *Repository) CountAll(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM schedules WHERE tenant_id = $1`

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package schedule

import (
        "context"
        "log/slog"
        "sync"
        "time"
)

// WorkflowExecutor interface for triggering workflow executions
type WorkflowExecutor interface {
        ExecuteScheduled(ctx context.Context, tenantID, workflowID, scheduleID string) (executionID string, err error)
}

// ScheduleProvider interface for getting due schedules
type ScheduleProvider interface {
        GetDueSchedules(ctx context.Context) ([]*Schedule, error)
        MarkScheduleRun(ctx context.Context, scheduleID, executionID string) error
}

// Scheduler manages scheduled workflow executions
type Scheduler struct {
        provider ScheduleProvider
        executor WorkflowExecutor
        logger   *slog.Logger

        // Scheduler configuration
        checkInterval time.Duration
        batchSize     int

        // Running state
        running bool
        mu      sync.Mutex
        wg      sync.WaitGroup
        stopCh  chan struct{}
}

// NewScheduler creates a new scheduler instance
func NewScheduler(provider ScheduleProvider, executor WorkflowExecutor, logger *slog.Logger) *Scheduler <span class="cov8" title="1">{
        return &amp;Scheduler{
                provider:      provider,
                executor:      executor,
                logger:        logger,
                checkInterval: 30 * time.Second, // Check every 30 seconds
                batchSize:     100,               // Process up to 100 schedules per check
                stopCh:        make(chan struct{}),
        }
}</span>

// Start starts the scheduler
func (s *Scheduler) Start(ctx context.Context) error <span class="cov8" title="1">{
        s.mu.Lock()
        if s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">s.running = true
        s.mu.Unlock()

        s.logger.Info("scheduler started", "check_interval", s.checkInterval)

        s.wg.Add(1)
        go s.run(ctx)

        return nil</span>
}

// Stop stops the scheduler gracefully
func (s *Scheduler) Stop() <span class="cov8" title="1">{
        s.mu.Lock()
        if !s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">s.running = false
        s.mu.Unlock()

        s.logger.Info("stopping scheduler...")
        close(s.stopCh)
        s.wg.Wait()
        s.logger.Info("scheduler stopped")</span>
}

// Wait waits for the scheduler to finish
func (s *Scheduler) Wait() <span class="cov8" title="1">{
        s.wg.Wait()
}</span>

// run is the main scheduler loop
func (s *Scheduler) run(ctx context.Context) <span class="cov8" title="1">{
        defer s.wg.Done()

        ticker := time.NewTicker(s.checkInterval)
        defer ticker.Stop()

        // Run initial check immediately
        s.checkAndExecuteSchedules(ctx)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("scheduler context cancelled")
                        return</span>
                case &lt;-s.stopCh:<span class="cov8" title="1">
                        s.logger.Info("scheduler stop signal received")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        s.checkAndExecuteSchedules(ctx)</span>
                }
        }
}

// checkAndExecuteSchedules checks for due schedules and executes them
func (s *Scheduler) checkAndExecuteSchedules(ctx context.Context) <span class="cov8" title="1">{
        schedules, err := s.provider.GetDueSchedules(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get due schedules", "error", err)
                return
        }</span>

        <span class="cov8" title="1">if len(schedules) == 0 </span><span class="cov8" title="1">{
                s.logger.Debug("no schedules due for execution")
                return
        }</span>

        <span class="cov8" title="1">s.logger.Info("found schedules due for execution", "count", len(schedules))

        // Execute schedules concurrently with a limit
        semaphore := make(chan struct{}, 10) // Limit to 10 concurrent executions
        var wg sync.WaitGroup

        for _, schedule := range schedules </span><span class="cov8" title="1">{
                wg.Add(1)
                semaphore &lt;- struct{}{} // Acquire semaphore

                go func(sch *Schedule) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        defer func() </span><span class="cov8" title="1">{ &lt;-semaphore }</span>() // Release semaphore

                        <span class="cov8" title="1">s.executeSchedule(ctx, sch)</span>
                }(schedule)
        }

        <span class="cov8" title="1">wg.Wait()
        s.logger.Info("finished processing due schedules", "count", len(schedules))</span>
}

// executeSchedule executes a single schedule
func (s *Scheduler) executeSchedule(ctx context.Context, schedule *Schedule) <span class="cov8" title="1">{
        s.logger.Info("executing schedule",
                "schedule_id", schedule.ID,
                "workflow_id", schedule.WorkflowID,
                "tenant_id", schedule.TenantID,
                "name", schedule.Name,
        )

        // Check if schedule is still enabled (may have been disabled since query)
        if !schedule.Enabled </span><span class="cov8" title="1">{
                s.logger.Warn("schedule is disabled, skipping",
                        "schedule_id", schedule.ID,
                )
                return
        }</span>

        // Execute workflow
        <span class="cov8" title="1">executionID, err := s.executor.ExecuteScheduled(ctx, schedule.TenantID, schedule.WorkflowID, schedule.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to execute scheduled workflow",
                        "error", err,
                        "schedule_id", schedule.ID,
                        "workflow_id", schedule.WorkflowID,
                )
                // Still mark the schedule as run to avoid repeated failures
                // Calculate next run time and update
                if err := s.provider.MarkScheduleRun(ctx, schedule.ID, ""); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to mark schedule run after error",
                                "error", err,
                                "schedule_id", schedule.ID,
                        )
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">s.logger.Info("schedule executed successfully",
                "schedule_id", schedule.ID,
                "execution_id", executionID,
        )

        // Mark schedule as run and update next run time
        if err := s.provider.MarkScheduleRun(ctx, schedule.ID, executionID); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to mark schedule run",
                        "error", err,
                        "schedule_id", schedule.ID,
                )
        }</span>
}

// SetCheckInterval sets the interval between schedule checks
func (s *Scheduler) SetCheckInterval(interval time.Duration) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.checkInterval = interval
}</span>

// IsRunning returns whether the scheduler is currently running
func (s *Scheduler) IsRunning() bool <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        return s.running
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package schedule

import (
        "context"
        "log/slog"
        "time"

        "github.com/robfig/cron/v3"
)

// WorkflowGetter interface to avoid circular dependencies
type WorkflowGetter interface {
        GetByID(ctx context.Context, tenantID, id string) (interface{}, error)
}

// Service handles schedule business logic
type Service struct {
        repo           *Repository
        workflowGetter WorkflowGetter
        logger         *slog.Logger
        cronParser     cron.Parser
}

// NewService creates a new schedule service
func NewService(repo *Repository, logger *slog.Logger) *Service <span class="cov8" title="1">{
        // Create parser that supports standard cron format with seconds
        parser := cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor)

        return &amp;Service{
                repo:       repo,
                logger:     logger,
                cronParser: parser,
        }
}</span>

// SetWorkflowService sets the workflow service (called after initialization to avoid import cycles)
func (s *Service) SetWorkflowService(workflowGetter WorkflowGetter) <span class="cov0" title="0">{
        s.workflowGetter = workflowGetter
}</span>

// Create creates a new schedule
func (s *Service) Create(ctx context.Context, tenantID, workflowID, userID string, input CreateScheduleInput) (*Schedule, error) <span class="cov0" title="0">{
        // Validate cron expression
        if err := s.validateCronExpression(input.CronExpression); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate timezone
        <span class="cov0" title="0">if input.Timezone != "" </span><span class="cov0" title="0">{
                if _, err := time.LoadLocation(input.Timezone); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;ValidationError{Message: "invalid timezone: " + err.Error()}
                }</span>
        }

        // Verify workflow exists
        <span class="cov0" title="0">if s.workflowGetter != nil </span><span class="cov0" title="0">{
                if _, err := s.workflowGetter.GetByID(ctx, tenantID, workflowID); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;ValidationError{Message: "workflow not found"}
                }</span>
        }

        // Create schedule
        <span class="cov0" title="0">schedule, err := s.repo.Create(ctx, tenantID, workflowID, userID, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create schedule", "error", err, "tenant_id", tenantID, "workflow_id", workflowID)
                return nil, err
        }</span>

        // Calculate and set next run time if enabled
        <span class="cov0" title="0">if schedule.Enabled </span><span class="cov0" title="0">{
                nextRun, err := s.calculateNextRun(schedule.CronExpression, schedule.Timezone)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to calculate next run time", "error", err, "schedule_id", schedule.ID)
                }</span> else<span class="cov0" title="0"> {
                        if err := s.repo.UpdateNextRunTime(ctx, schedule.ID, nextRun); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("failed to update next run time", "error", err, "schedule_id", schedule.ID)
                        }</span> else<span class="cov0" title="0"> {
                                schedule.NextRunAt = &amp;nextRun
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("schedule created", "schedule_id", schedule.ID, "workflow_id", workflowID)
        return schedule, nil</span>
}

// GetByID retrieves a schedule by ID
func (s *Service) GetByID(ctx context.Context, tenantID, id string) (*Schedule, error) <span class="cov0" title="0">{
        return s.repo.GetByID(ctx, tenantID, id)
}</span>

// Update updates a schedule
func (s *Service) Update(ctx context.Context, tenantID, id string, input UpdateScheduleInput) (*Schedule, error) <span class="cov0" title="0">{
        // Get existing schedule
        existing, err := s.repo.GetByID(ctx, tenantID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate cron expression if provided
        <span class="cov0" title="0">if input.CronExpression != nil </span><span class="cov0" title="0">{
                if err := s.validateCronExpression(*input.CronExpression); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Validate timezone if provided
        <span class="cov0" title="0">if input.Timezone != nil &amp;&amp; *input.Timezone != "" </span><span class="cov0" title="0">{
                if _, err := time.LoadLocation(*input.Timezone); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;ValidationError{Message: "invalid timezone: " + err.Error()}
                }</span>
        }

        // Update schedule
        <span class="cov0" title="0">schedule, err := s.repo.Update(ctx, tenantID, id, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update schedule", "error", err, "schedule_id", id)
                return nil, err
        }</span>

        // Recalculate next run time if cron expression, timezone, or enabled status changed
        <span class="cov0" title="0">shouldRecalculate := false
        if input.CronExpression != nil || input.Timezone != nil </span><span class="cov0" title="0">{
                shouldRecalculate = true
        }</span>
        <span class="cov0" title="0">if input.Enabled != nil &amp;&amp; *input.Enabled &amp;&amp; !existing.Enabled </span><span class="cov0" title="0">{
                shouldRecalculate = true
        }</span>

        <span class="cov0" title="0">if shouldRecalculate &amp;&amp; schedule.Enabled </span><span class="cov0" title="0">{
                nextRun, err := s.calculateNextRun(schedule.CronExpression, schedule.Timezone)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to calculate next run time", "error", err, "schedule_id", schedule.ID)
                }</span> else<span class="cov0" title="0"> {
                        if err := s.repo.UpdateNextRunTime(ctx, schedule.ID, nextRun); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("failed to update next run time", "error", err, "schedule_id", schedule.ID)
                        }</span> else<span class="cov0" title="0"> {
                                schedule.NextRunAt = &amp;nextRun
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("schedule updated", "schedule_id", schedule.ID)
        return schedule, nil</span>
}

// Delete deletes a schedule
func (s *Service) Delete(ctx context.Context, tenantID, id string) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, tenantID, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete schedule", "error", err, "schedule_id", id)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("schedule deleted", "schedule_id", id)
        return nil</span>
}

// List retrieves all schedules for a workflow
func (s *Service) List(ctx context.Context, tenantID, workflowID string, limit, offset int) ([]*Schedule, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.repo.List(ctx, tenantID, workflowID, limit, offset)</span>
}

// ListAll retrieves all schedules for a tenant
func (s *Service) ListAll(ctx context.Context, tenantID string, limit, offset int) ([]*ScheduleWithWorkflow, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.repo.ListAll(ctx, tenantID, limit, offset)</span>
}

// GetDueSchedules retrieves schedules that need to be executed
func (s *Service) GetDueSchedules(ctx context.Context) ([]*Schedule, error) <span class="cov0" title="0">{
        return s.repo.GetDueSchedules(ctx, time.Now())
}</span>

// MarkScheduleRun updates schedule after execution
func (s *Service) MarkScheduleRun(ctx context.Context, scheduleID, executionID string) error <span class="cov0" title="0">{
        schedule, err := s.repo.GetByIDWithoutTenant(ctx, scheduleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Calculate next run time
        <span class="cov0" title="0">nextRun, err := s.calculateNextRun(schedule.CronExpression, schedule.Timezone)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to calculate next run time", "error", err, "schedule_id", scheduleID)
                return err
        }</span>

        // Update last run and next run
        <span class="cov0" title="0">err = s.repo.UpdateLastRun(ctx, scheduleID, time.Now(), executionID, nextRun)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update schedule run info", "error", err, "schedule_id", scheduleID)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("schedule run marked", "schedule_id", scheduleID, "execution_id", executionID, "next_run", nextRun)
        return nil</span>
}

// validateCronExpression validates a cron expression
func (s *Service) validateCronExpression(expression string) error <span class="cov8" title="1">{
        _, err := s.cronParser.Parse(expression)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;ValidationError{Message: "invalid cron expression: " + err.Error()}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// calculateNextRun calculates the next run time for a cron expression
func (s *Service) calculateNextRun(expression, timezone string) (time.Time, error) <span class="cov8" title="1">{
        // Parse cron expression
        sched, err := s.cronParser.Parse(expression)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, err
        }</span>

        // Load timezone
        <span class="cov8" title="1">loc, err := time.LoadLocation(timezone)
        if err != nil </span><span class="cov8" title="1">{
                loc = time.UTC
        }</span>

        // Calculate next run time
        <span class="cov8" title="1">now := time.Now().In(loc)
        nextRun := sched.Next(now)

        return nextRun, nil</span>
}

// ParseNextRunTime is a helper to parse and return next run time (useful for API responses)
func (s *Service) ParseNextRunTime(expression, timezone string) (time.Time, error) <span class="cov8" title="1">{
        return s.calculateNextRun(expression, timezone)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package schedule

import (
        "context"
)

// WorkflowServiceAdapter adapts workflow service for scheduler
type WorkflowServiceAdapter struct {
        executeFunc func(ctx context.Context, tenantID, workflowID, triggerType string, triggerData []byte) (executionID string, err error)
}

// NewWorkflowServiceAdapter creates a new adapter
func NewWorkflowServiceAdapter(executeFunc func(ctx context.Context, tenantID, workflowID, triggerType string, triggerData []byte) (executionID string, err error)) *WorkflowServiceAdapter <span class="cov0" title="0">{
        return &amp;WorkflowServiceAdapter{
                executeFunc: executeFunc,
        }
}</span>

// ExecuteScheduled executes a scheduled workflow
func (w *WorkflowServiceAdapter) ExecuteScheduled(ctx context.Context, tenantID, workflowID, scheduleID string) (executionID string, err error) <span class="cov0" title="0">{
        // Create trigger data with schedule information
        triggerData := []byte(`{"schedule_id":"` + scheduleID + `"}`)
        return w.executeFunc(ctx, tenantID, workflowID, "schedule", triggerData)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package tenant

import (
        "encoding/json"
        "time"
)

// Tenant represents a tenant in the system
type Tenant struct {
        ID        string          `db:"id" json:"id"`
        Name      string          `db:"name" json:"name"`
        Subdomain string          `db:"subdomain" json:"subdomain"`
        Status    string          `db:"status" json:"status"`
        Tier      string          `db:"tier" json:"tier"`
        Settings  json.RawMessage `db:"settings" json:"settings"`
        Quotas    json.RawMessage `db:"quotas" json:"quotas"`
        CreatedAt time.Time       `db:"created_at" json:"created_at"`
        UpdatedAt time.Time       `db:"updated_at" json:"updated_at"`
}

// TenantSettings holds tenant-specific settings
type TenantSettings struct {
        DefaultTimezone string `json:"default_timezone"`
        WebhookSecret   string `json:"webhook_secret"`
}

// TenantQuotas holds tenant resource quotas
type TenantQuotas struct {
        MaxWorkflows              int `json:"max_workflows"`
        MaxExecutionsPerDay       int `json:"max_executions_per_day"`
        MaxConcurrentExecutions   int `json:"max_concurrent_executions"`
        MaxStorageBytes           int `json:"max_storage_bytes"`
        MaxAPICallsPerMinute      int `json:"max_api_calls_per_minute"`
        ExecutionHistoryRetention int `json:"execution_history_retention_days"`
}

// DefaultQuotas returns default quotas based on tier
func DefaultQuotas(tier string) TenantQuotas <span class="cov8" title="1">{
        switch tier </span>{
        case "enterprise":<span class="cov8" title="1">
                return TenantQuotas{
                        MaxWorkflows:              -1, // unlimited
                        MaxExecutionsPerDay:       -1,
                        MaxConcurrentExecutions:   100,
                        MaxStorageBytes:           -1,
                        MaxAPICallsPerMinute:      1000,
                        ExecutionHistoryRetention: 365,
                }</span>
        case "professional":<span class="cov8" title="1">
                return TenantQuotas{
                        MaxWorkflows:              50,
                        MaxExecutionsPerDay:       5000,
                        MaxConcurrentExecutions:   10,
                        MaxStorageBytes:           5 * 1024 * 1024 * 1024, // 5GB
                        MaxAPICallsPerMinute:      300,
                        ExecutionHistoryRetention: 30,
                }</span>
        default:<span class="cov8" title="1"> // free
                return TenantQuotas{
                        MaxWorkflows:              5,
                        MaxExecutionsPerDay:       100,
                        MaxConcurrentExecutions:   2,
                        MaxStorageBytes:           100 * 1024 * 1024, // 100MB
                        MaxAPICallsPerMinute:      60,
                        ExecutionHistoryRetention: 7,
                }</span>
        }
}

// CreateTenantInput represents input for creating a tenant
type CreateTenantInput struct {
        Name      string `json:"name" validate:"required,min=2,max=100"`
        Subdomain string `json:"subdomain" validate:"required,min=3,max=63,alphanum"`
        Tier      string `json:"tier" validate:"oneof=free professional enterprise"`
}

// UpdateTenantInput represents input for updating a tenant
type UpdateTenantInput struct {
        Name     string          `json:"name,omitempty"`
        Status   string          `json:"status,omitempty"`
        Tier     string          `json:"tier,omitempty"`
        Settings json.RawMessage `json:"settings,omitempty"`
}

// UsageStats represents current usage statistics for a tenant
type UsageStats struct {
        TenantID             string `json:"tenant_id"`
        WorkflowCount        int    `json:"workflow_count"`
        ExecutionsToday      int    `json:"executions_today"`
        ExecutionsThisMonth  int    `json:"executions_this_month"`
        ConcurrentExecutions int    `json:"concurrent_executions"`
        StorageBytes         int64  `json:"storage_bytes"`
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package tenant

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

var (
        ErrNotFound = errors.New("tenant not found")
)

// Repository handles tenant database operations
type Repository struct {
        db *sqlx.DB
}

// NewRepository creates a new tenant repository
func NewRepository(db *sqlx.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{db: db}
}</span>

// Create inserts a new tenant
func (r *Repository) Create(ctx context.Context, input CreateTenantInput) (*Tenant, error) <span class="cov0" title="0">{
        id := uuid.New().String()
        now := time.Now()

        // Set default quotas based on tier
        quotas := DefaultQuotas(input.Tier)
        quotasJSON, err := json.Marshal(quotas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Default settings
        <span class="cov0" title="0">settings := TenantSettings{
                DefaultTimezone: "UTC",
                WebhookSecret:   uuid.New().String(),
        }
        settingsJSON, err := json.Marshal(settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO tenants (id, name, subdomain, status, tier, settings, quotas, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id, name, subdomain, status, tier, settings, quotas, created_at, updated_at
        `

        var tenant Tenant
        err = r.db.QueryRowxContext(
                ctx, query,
                id, input.Name, input.Subdomain, "active", input.Tier, settingsJSON, quotasJSON, now, now,
        ).StructScan(&amp;tenant)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;tenant, nil</span>
}

// GetByID retrieves a tenant by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Tenant, error) <span class="cov0" title="0">{
        query := `SELECT * FROM tenants WHERE id = $1`

        var tenant Tenant
        err := r.db.GetContext(ctx, &amp;tenant, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;tenant, nil</span>
}

// GetBySubdomain retrieves a tenant by subdomain
func (r *Repository) GetBySubdomain(ctx context.Context, subdomain string) (*Tenant, error) <span class="cov0" title="0">{
        query := `SELECT * FROM tenants WHERE subdomain = $1`

        var tenant Tenant
        err := r.db.GetContext(ctx, &amp;tenant, query, subdomain)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;tenant, nil</span>
}

// Update updates a tenant
func (r *Repository) Update(ctx context.Context, id string, input UpdateTenantInput) (*Tenant, error) <span class="cov0" title="0">{
        query := `
                UPDATE tenants
                SET name = COALESCE(NULLIF($2, ''), name),
                    status = COALESCE(NULLIF($3, ''), status),
                    tier = COALESCE(NULLIF($4, ''), tier),
                    settings = COALESCE($5, settings),
                    updated_at = $6
                WHERE id = $1
                RETURNING *
        `

        var tenant Tenant
        err := r.db.QueryRowxContext(
                ctx, query,
                id, input.Name, input.Status, input.Tier, input.Settings, time.Now(),
        ).StructScan(&amp;tenant)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;tenant, nil</span>
}

// Delete deletes a tenant (soft delete by setting status to 'deleted')
func (r *Repository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `UPDATE tenants SET status = 'deleted', updated_at = $2 WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// List retrieves all tenants with pagination
func (r *Repository) List(ctx context.Context, limit, offset int) ([]*Tenant, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM tenants
                WHERE status != 'deleted'
                ORDER BY created_at DESC
                LIMIT $1 OFFSET $2
        `

        var tenants []*Tenant
        err := r.db.SelectContext(ctx, &amp;tenants, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tenants, nil</span>
}

// Count returns the total number of active tenants
func (r *Repository) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM tenants WHERE status != 'deleted'`

        var count int
        err := r.db.GetContext(ctx, &amp;count, query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// UpdateQuotas updates tenant quotas
func (r *Repository) UpdateQuotas(ctx context.Context, id string, quotas TenantQuotas) (*Tenant, error) <span class="cov0" title="0">{
        quotasJSON, err := json.Marshal(quotas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE tenants
                SET quotas = $2,
                    updated_at = $3
                WHERE id = $1
                RETURNING *
        `

        var tenant Tenant
        err = r.db.QueryRowxContext(ctx, query, id, quotasJSON, time.Now()).StructScan(&amp;tenant)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;tenant, nil</span>
}

// GetWorkflowCount returns the count of active workflows for a tenant
func (r *Repository) GetWorkflowCount(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM workflows WHERE tenant_id = $1 AND status != 'archived'`

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetExecutionStats returns execution statistics for a tenant
func (r *Repository) GetExecutionStats(ctx context.Context, tenantID string) (*UsageStats, error) <span class="cov0" title="0">{
        today := time.Now().Truncate(24 * time.Hour)
        monthStart := time.Date(today.Year(), today.Month(), 1, 0, 0, 0, 0, time.UTC)

        query := `
                SELECT
                        $1 as tenant_id,
                        (SELECT COUNT(*) FROM workflows WHERE tenant_id = $1 AND status != 'archived') as workflow_count,
                        (SELECT COUNT(*) FROM executions WHERE tenant_id = $1 AND created_at &gt;= $2) as executions_today,
                        (SELECT COUNT(*) FROM executions WHERE tenant_id = $1 AND created_at &gt;= $3) as executions_this_month,
                        (SELECT COUNT(*) FROM executions WHERE tenant_id = $1 AND status = 'running') as concurrent_executions,
                        0 as storage_bytes
        `

        var stats UsageStats
        err := r.db.GetContext(ctx, &amp;stats, query, tenantID, today, monthStart)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetConcurrentExecutions returns the count of currently running executions
func (r *Repository) GetConcurrentExecutions(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM executions WHERE tenant_id = $1 AND status = 'running'`

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package tenant

import (
        "context"
        "log/slog"
)

// Service handles tenant business logic
type Service struct {
        repo   *Repository
        logger *slog.Logger
}

// NewService creates a new tenant service
func NewService(repo *Repository, logger *slog.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// Create creates a new tenant
func (s *Service) Create(ctx context.Context, input CreateTenantInput) (*Tenant, error) <span class="cov0" title="0">{
        // Set default tier if not specified
        if input.Tier == "" </span><span class="cov0" title="0">{
                input.Tier = "free"
        }</span>

        <span class="cov0" title="0">tenant, err := s.repo.Create(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create tenant", "error", err, "name", input.Name)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("tenant created", "tenant_id", tenant.ID, "name", tenant.Name)
        return tenant, nil</span>
}

// GetByID retrieves a tenant by ID
func (s *Service) GetByID(ctx context.Context, id string) (*Tenant, error) <span class="cov0" title="0">{
        return s.repo.GetByID(ctx, id)
}</span>

// GetBySubdomain retrieves a tenant by subdomain
func (s *Service) GetBySubdomain(ctx context.Context, subdomain string) (*Tenant, error) <span class="cov0" title="0">{
        return s.repo.GetBySubdomain(ctx, subdomain)
}</span>

// Update updates a tenant
func (s *Service) Update(ctx context.Context, id string, input UpdateTenantInput) (*Tenant, error) <span class="cov0" title="0">{
        tenant, err := s.repo.Update(ctx, id, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update tenant", "error", err, "tenant_id", id)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("tenant updated", "tenant_id", tenant.ID)
        return tenant, nil</span>
}

// Delete deletes a tenant
func (s *Service) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete tenant", "error", err, "tenant_id", id)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("tenant deleted", "tenant_id", id)
        return nil</span>
}

// List retrieves all tenants with pagination
func (s *Service) List(ctx context.Context, limit, offset int) ([]*Tenant, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.repo.List(ctx, limit, offset)</span>
}

// UpdateQuotas updates tenant quotas
func (s *Service) UpdateQuotas(ctx context.Context, id string, quotas TenantQuotas) (*Tenant, error) <span class="cov0" title="0">{
        tenant, err := s.repo.UpdateQuotas(ctx, id, quotas)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update tenant quotas", "error", err, "tenant_id", id)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("tenant quotas updated", "tenant_id", tenant.ID)
        return tenant, nil</span>
}

// GetWorkflowCount returns the count of active workflows for a tenant
func (s *Service) GetWorkflowCount(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        return s.repo.GetWorkflowCount(ctx, tenantID)
}</span>

// GetExecutionStats returns execution statistics for a tenant
func (s *Service) GetExecutionStats(ctx context.Context, tenantID string) (*UsageStats, error) <span class="cov0" title="0">{
        return s.repo.GetExecutionStats(ctx, tenantID)
}</span>

// GetConcurrentExecutions returns the count of currently running executions
func (s *Service) GetConcurrentExecutions(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        return s.repo.GetConcurrentExecutions(ctx, tenantID)
}</span>

// Count returns the total number of active tenants
func (s *Service) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return s.repo.Count(ctx)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package user

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

var (
        ErrUserNotFound      = errors.New("user not found")
        ErrUserAlreadyExists = errors.New("user already exists")
)

// Repository defines the interface for user data access
type Repository interface {
        Create(ctx context.Context, user *User) error
        GetByID(ctx context.Context, id string) (*User, error)
        GetByKratosIdentityID(ctx context.Context, kratosIdentityID string) (*User, error)
        GetByEmail(ctx context.Context, email string) (*User, error)
        ListByTenant(ctx context.Context, tenantID string) ([]*User, error)
        Update(ctx context.Context, id string, input UpdateUserInput) (*User, error)
        Delete(ctx context.Context, id string) error
}

type repository struct {
        db *sqlx.DB
}

// NewRepository creates a new user repository
func NewRepository(db *sqlx.DB) Repository <span class="cov0" title="0">{
        return &amp;repository{db: db}
}</span>

func (r *repository) Create(ctx context.Context, user *User) error <span class="cov0" title="0">{
        // Generate UUID if not provided
        if user.ID == "" </span><span class="cov0" title="0">{
                user.ID = uuid.New().String()
        }</span>

        // Set defaults
        <span class="cov0" title="0">if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = "member"
        }</span>
        <span class="cov0" title="0">if user.Status == "" </span><span class="cov0" title="0">{
                user.Status = "active"
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO users (id, tenant_id, kratos_identity_id, email, role, status, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                RETURNING created_at, updated_at
        `

        err := r.db.QueryRowContext(
                ctx,
                query,
                user.ID,
                user.TenantID,
                user.KratosIdentityID,
                user.Email,
                user.Role,
                user.Status,
        ).Scan(&amp;user.CreatedAt, &amp;user.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "pq: duplicate key value violates unique constraint \"users_kratos_identity_id_key\"" </span><span class="cov0" title="0">{
                        return ErrUserAlreadyExists
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("create user: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *repository) GetByID(ctx context.Context, id string) (*User, error) <span class="cov0" title="0">{
        var user User
        query := `SELECT * FROM users WHERE id = $1`

        err := r.db.GetContext(ctx, &amp;user, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get user by id: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *repository) GetByKratosIdentityID(ctx context.Context, kratosIdentityID string) (*User, error) <span class="cov0" title="0">{
        var user User
        query := `SELECT * FROM users WHERE kratos_identity_id = $1`

        err := r.db.GetContext(ctx, &amp;user, query, kratosIdentityID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get user by kratos identity id: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *repository) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{
        var user User
        query := `SELECT * FROM users WHERE email = $1`

        err := r.db.GetContext(ctx, &amp;user, query, email)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get user by email: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *repository) ListByTenant(ctx context.Context, tenantID string) ([]*User, error) <span class="cov0" title="0">{
        var users []*User
        query := `SELECT * FROM users WHERE tenant_id = $1 ORDER BY created_at DESC`

        err := r.db.SelectContext(ctx, &amp;users, query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list users by tenant: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (r *repository) Update(ctx context.Context, id string, input UpdateUserInput) (*User, error) <span class="cov0" title="0">{
        // Build dynamic update query
        query := `UPDATE users SET updated_at = NOW()`
        args := []interface{}{}
        argCount := 1

        if input.Role != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(", role = $%d", argCount)
                args = append(args, input.Role)
                argCount++
        }</span>

        <span class="cov0" title="0">if input.Status != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(", status = $%d", argCount)
                args = append(args, input.Status)
                argCount++
        }</span>

        <span class="cov0" title="0">query += fmt.Sprintf(" WHERE id = $%d RETURNING *", argCount)
        args = append(args, id)

        var user User
        err := r.db.GetContext(ctx, &amp;user, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("update user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *repository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = $1`
        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete user: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete user: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrUserNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package user

import (
        "context"
        "fmt"
        "log/slog"
)

// Service handles user business logic
type Service struct {
        repo   Repository
        logger *slog.Logger
}

// NewService creates a new user service
func NewService(repo Repository, logger *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// CreateUser creates a new user
func (s *Service) CreateUser(ctx context.Context, input CreateUserInput) (*User, error) <span class="cov8" title="1">{
        s.logger.Info("creating user",
                "email", input.Email,
                "tenant_id", input.TenantID,
        )

        user := &amp;User{
                TenantID:         input.TenantID,
                KratosIdentityID: input.KratosIdentityID,
                Email:            input.Email,
                Role:             input.Role,
        }

        if err := s.repo.Create(ctx, user); err != nil </span><span class="cov8" title="1">{
                s.logger.Error("failed to create user",
                        "error", err,
                        "email", input.Email,
                )
                return nil, fmt.Errorf("create user: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("user created successfully",
                "user_id", user.ID,
                "email", user.Email,
        )

        return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *Service) GetUserByID(ctx context.Context, id string) (*User, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get user by id: %w", err)
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByKratosIdentityID retrieves a user by Kratos identity ID
func (s *Service) GetUserByKratosIdentityID(ctx context.Context, kratosIdentityID string) (*User, error) <span class="cov8" title="1">{
        user, err := s.repo.GetByKratosIdentityID(ctx, kratosIdentityID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("get user by kratos identity id: %w", err)
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// GetUserByEmail retrieves a user by email
func (s *Service) GetUserByEmail(ctx context.Context, email string) (*User, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get user by email: %w", err)
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

// ListUsersByTenant retrieves all users for a tenant
func (s *Service) ListUsersByTenant(ctx context.Context, tenantID string) ([]*User, error) <span class="cov0" title="0">{
        users, err := s.repo.ListByTenant(ctx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list users by tenant: %w", err)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// UpdateUser updates a user
func (s *Service) UpdateUser(ctx context.Context, id string, input UpdateUserInput) (*User, error) <span class="cov8" title="1">{
        s.logger.Info("updating user", "user_id", id)

        user, err := s.repo.Update(ctx, id, input)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("failed to update user",
                        "error", err,
                        "user_id", id,
                )
                return nil, fmt.Errorf("update user: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("user updated successfully", "user_id", id)
        return user, nil</span>
}

// DeleteUser deletes a user
func (s *Service) DeleteUser(ctx context.Context, id string) error <span class="cov8" title="1">{
        s.logger.Info("deleting user", "user_id", id)

        if err := s.repo.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                s.logger.Error("failed to delete user",
                        "error", err,
                        "user_id", id,
                )
                return fmt.Errorf("delete user: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("user deleted successfully", "user_id", id)
        return nil</span>
}

// SyncFromKratosWebhook syncs user data from Kratos webhook
func (s *Service) SyncFromKratosWebhook(ctx context.Context, webhook KratosIdentityWebhook) (*User, error) <span class="cov8" title="1">{
        s.logger.Info("syncing user from Kratos webhook",
                "identity_id", webhook.IdentityID,
                "email", webhook.Email,
        )

        // Check if user already exists
        existingUser, err := s.repo.GetByKratosIdentityID(ctx, webhook.IdentityID)
        if err == nil </span><span class="cov8" title="1">{
                // User exists, update if needed
                s.logger.Info("user already exists, skipping sync",
                        "user_id", existingUser.ID,
                        "identity_id", webhook.IdentityID,
                )
                return existingUser, nil
        }</span>

        // Determine tenant ID
        <span class="cov8" title="1">tenantID := webhook.TenantID
        if tenantID == "" </span><span class="cov8" title="1">{
                // For development/testing, use a default tenant
                // In production, this should be required
                s.logger.Warn("no tenant_id in webhook, using default")
                tenantID = "00000000-0000-0000-0000-000000000001"
        }</span>

        // Create new user
        <span class="cov8" title="1">input := CreateUserInput{
                TenantID:         tenantID,
                KratosIdentityID: webhook.IdentityID,
                Email:            webhook.Email,
                Role:             "member", // Default role
        }

        user, err := s.CreateUser(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sync from kratos webhook: %w", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package webhook

import (
        "time"
)

// Webhook represents a webhook configuration
type Webhook struct {
        ID         string    `db:"id" json:"id"`
        TenantID   string    `db:"tenant_id" json:"tenant_id"`
        WorkflowID string    `db:"workflow_id" json:"workflow_id"`
        NodeID     string    `db:"node_id" json:"node_id"`
        Path       string    `db:"path" json:"path"`
        Secret     string    `db:"secret" json:"secret"`
        AuthType   string    `db:"auth_type" json:"auth_type"`
        Enabled    bool      `db:"enabled" json:"enabled"`
        CreatedAt  time.Time `db:"created_at" json:"created_at"`
        UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`
}

// WebhookURL returns the full webhook URL path
func (w *Webhook) WebhookURL() string <span class="cov0" title="0">{
        return "/webhooks/" + w.WorkflowID + "/" + w.ID
}</span>

// AuthType constants
const (
        AuthTypeNone      = "none"
        AuthTypeSignature = "signature"
        AuthTypeBasic     = "basic"
        AuthTypeAPIKey    = "api_key"
)
</pre>
		
		<pre class="file" id="file75" style="display: none">package webhook

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

var (
        ErrNotFound = errors.New("webhook not found")
)

// Repository handles webhook database operations
type Repository struct {
        db *sqlx.DB
}

// NewRepository creates a new webhook repository
func NewRepository(db *sqlx.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{db: db}
}</span>

// Create creates a new webhook
func (r *Repository) Create(ctx context.Context, tenantID, workflowID, nodeID, secret, authType string) (*Webhook, error) <span class="cov0" title="0">{
        id := uuid.New().String()
        now := time.Now()

        // Generate unique path: /webhooks/{workflowID}/{webhookID}
        path := "/webhooks/" + workflowID + "/" + id

        query := `
                INSERT INTO webhooks (id, tenant_id, workflow_id, node_id, path, secret, auth_type, enabled, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING *
        `

        var webhook Webhook
        err := r.db.QueryRowxContext(
                ctx, query,
                id, tenantID, workflowID, nodeID, path, secret, authType, true, now, now,
        ).StructScan(&amp;webhook)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;webhook, nil</span>
}

// GetByID retrieves a webhook by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Webhook, error) <span class="cov0" title="0">{
        query := `SELECT * FROM webhooks WHERE id = $1`

        var webhook Webhook
        err := r.db.GetContext(ctx, &amp;webhook, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;webhook, nil</span>
}

// GetByWorkflowAndWebhookID retrieves a webhook by workflow ID and webhook ID
func (r *Repository) GetByWorkflowAndWebhookID(ctx context.Context, workflowID, webhookID string) (*Webhook, error) <span class="cov0" title="0">{
        query := `SELECT * FROM webhooks WHERE workflow_id = $1 AND id = $2 AND enabled = true`

        var webhook Webhook
        err := r.db.GetContext(ctx, &amp;webhook, query, workflowID, webhookID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;webhook, nil</span>
}

// GetByWorkflowID retrieves all webhooks for a workflow
func (r *Repository) GetByWorkflowID(ctx context.Context, workflowID string) ([]*Webhook, error) <span class="cov0" title="0">{
        query := `SELECT * FROM webhooks WHERE workflow_id = $1`

        var webhooks []*Webhook
        err := r.db.SelectContext(ctx, &amp;webhooks, query, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return webhooks, nil</span>
}

// Delete deletes a webhook
func (r *Repository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM webhooks WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteByWorkflowID deletes all webhooks for a workflow
func (r *Repository) DeleteByWorkflowID(ctx context.Context, workflowID string) error <span class="cov0" title="0">{
        query := `DELETE FROM webhooks WHERE workflow_id = $1`

        _, err := r.db.ExecContext(ctx, query, workflowID)
        return err
}</span>

// UpdateEnabled updates the enabled status of a webhook
func (r *Repository) UpdateEnabled(ctx context.Context, id string, enabled bool) error <span class="cov0" title="0">{
        query := `UPDATE webhooks SET enabled = $2, updated_at = $3 WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id, enabled, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package webhook

import (
        "context"
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "fmt"
        "log/slog"

        "github.com/gorax/gorax/internal/workflow"
)

// Service handles webhook business logic
type Service struct {
        repo   *Repository
        logger *slog.Logger
}

// NewService creates a new webhook service
func NewService(repo *Repository, logger *slog.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// GenerateSecret generates a secure random secret for webhook signing
func (s *Service) GenerateSecret() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32) // 256 bits
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random secret: %w", err)
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(bytes), nil</span>
}

// Create creates a new webhook
func (s *Service) Create(ctx context.Context, tenantID, workflowID, nodeID, authType string) (*Webhook, error) <span class="cov0" title="0">{
        // Generate secret if using signature auth
        secret := ""
        if authType == AuthTypeSignature </span><span class="cov0" title="0">{
                var err error
                secret, err = s.GenerateSecret()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">webhook, err := s.repo.Create(ctx, tenantID, workflowID, nodeID, secret, authType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create webhook", "error", err, "workflow_id", workflowID)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("webhook created", "webhook_id", webhook.ID, "workflow_id", workflowID)
        return webhook, nil</span>
}

// GetByWorkflowAndWebhookID retrieves a webhook by workflow and webhook IDs
func (s *Service) GetByWorkflowAndWebhookID(ctx context.Context, workflowID, webhookID string) (*Webhook, error) <span class="cov0" title="0">{
        return s.repo.GetByWorkflowAndWebhookID(ctx, workflowID, webhookID)
}</span>

// GetByWorkflowID retrieves all webhooks for a workflow as workflow.WebhookInfo
func (s *Service) GetByWorkflowID(ctx context.Context, workflowID string) ([]*workflow.WebhookInfo, error) <span class="cov0" title="0">{
        webhooks, err := s.repo.GetByWorkflowID(ctx, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to workflow.WebhookInfo
        <span class="cov0" title="0">result := make([]*workflow.WebhookInfo, len(webhooks))
        for i, wh := range webhooks </span><span class="cov0" title="0">{
                result[i] = &amp;workflow.WebhookInfo{
                        ID:         wh.ID,
                        NodeID:     wh.NodeID,
                        WebhookURL: wh.WebhookURL(),
                        AuthType:   wh.AuthType,
                        Secret:     wh.Secret,
                }
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Delete deletes a webhook
func (s *Service) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete webhook", "error", err, "webhook_id", id)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("webhook deleted", "webhook_id", id)
        return nil</span>
}

// DeleteByWorkflowID deletes all webhooks for a workflow
func (s *Service) DeleteByWorkflowID(ctx context.Context, workflowID string) error <span class="cov0" title="0">{
        err := s.repo.DeleteByWorkflowID(ctx, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete webhooks", "error", err, "workflow_id", workflowID)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("webhooks deleted for workflow", "workflow_id", workflowID)
        return nil</span>
}

// VerifySignature verifies the HMAC signature of a webhook request
// Signature format: sha256=&lt;hex encoded hmac&gt;
func (s *Service) VerifySignature(payload []byte, signature string, secret string) bool <span class="cov0" title="0">{
        if signature == "" || secret == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Remove 'sha256=' prefix if present
        <span class="cov0" title="0">if len(signature) &gt; 7 &amp;&amp; signature[:7] == "sha256=" </span><span class="cov0" title="0">{
                signature = signature[7:]
        }</span>

        // Calculate expected signature
        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        expectedMAC := mac.Sum(nil)
        expectedSignature := hex.EncodeToString(expectedMAC)

        // Compare signatures (constant time comparison)
        return hmac.Equal([]byte(signature), []byte(expectedSignature))</span>
}

// GenerateSignature generates an HMAC signature for testing purposes
func (s *Service) GenerateSignature(payload []byte, secret string) string <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        signature := hex.EncodeToString(mac.Sum(nil))
        return "sha256=" + signature
}</span>

// SyncWorkflowWebhooks syncs webhooks for a workflow based on its definition
// This should be called when a workflow is created or updated
func (s *Service) SyncWorkflowWebhooks(ctx context.Context, tenantID, workflowID string, webhookNodes []workflow.WebhookNodeConfig) error <span class="cov0" title="0">{
        // Get existing webhooks
        existing, err := s.repo.GetByWorkflowID(ctx, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a map of existing webhooks by node_id
        <span class="cov0" title="0">existingMap := make(map[string]*Webhook)
        for _, wh := range existing </span><span class="cov0" title="0">{
                existingMap[wh.NodeID] = wh
        }</span>

        // Track which webhooks should exist
        <span class="cov0" title="0">shouldExist := make(map[string]bool)

        // Create or update webhooks for each webhook node
        for _, nodeConfig := range webhookNodes </span><span class="cov0" title="0">{
                shouldExist[nodeConfig.NodeID] = true

                // If webhook doesn't exist, create it
                if _, exists := existingMap[nodeConfig.NodeID]; !exists </span><span class="cov0" title="0">{
                        authType := nodeConfig.AuthType
                        if authType == "" </span><span class="cov0" title="0">{
                                authType = AuthTypeSignature // Default to signature
                        }</span>

                        <span class="cov0" title="0">_, err := s.Create(ctx, tenantID, workflowID, nodeConfig.NodeID, authType)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("failed to create webhook during sync", "error", err, "node_id", nodeConfig.NodeID)
                                return err
                        }</span>
                }
        }

        // Delete webhooks that no longer exist in the workflow definition
        <span class="cov0" title="0">for nodeID, webhook := range existingMap </span><span class="cov0" title="0">{
                if !shouldExist[nodeID] </span><span class="cov0" title="0">{
                        if err := s.repo.Delete(ctx, webhook.ID); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("failed to delete orphaned webhook", "error", err, "webhook_id", webhook.ID)
                                // Continue even if deletion fails
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package websocket

import (
        "encoding/json"
        "time"
)

// EventType represents the type of execution event
type EventType string

const (
        EventTypeExecutionStarted   EventType = "execution.started"
        EventTypeExecutionCompleted EventType = "execution.completed"
        EventTypeExecutionFailed    EventType = "execution.failed"
        EventTypeStepStarted        EventType = "step.started"
        EventTypeStepCompleted      EventType = "step.completed"
        EventTypeStepFailed         EventType = "step.failed"
        EventTypeExecutionProgress  EventType = "execution.progress"
)

// ExecutionEvent represents a WebSocket event for execution updates
type ExecutionEvent struct {
        Type        EventType              `json:"type"`
        ExecutionID string                 `json:"execution_id"`
        WorkflowID  string                 `json:"workflow_id"`
        TenantID    string                 `json:"tenant_id"`
        Status      string                 `json:"status,omitempty"`
        Progress    *ProgressInfo          `json:"progress,omitempty"`
        Step        *StepInfo              `json:"step,omitempty"`
        Error       *string                `json:"error,omitempty"`
        Output      *json.RawMessage       `json:"output,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
        Timestamp   time.Time              `json:"timestamp"`
}

// ProgressInfo contains execution progress information
type ProgressInfo struct {
        TotalSteps     int     `json:"total_steps"`
        CompletedSteps int     `json:"completed_steps"`
        Percentage     float64 `json:"percentage"`
}

// StepInfo contains step execution information
type StepInfo struct {
        StepID      string           `json:"step_id"`
        NodeID      string           `json:"node_id"`
        NodeType    string           `json:"node_type"`
        Status      string           `json:"status"`
        OutputData  *json.RawMessage `json:"output_data,omitempty"`
        ErrorMsg    *string          `json:"error,omitempty"`
        DurationMs  *int             `json:"duration_ms,omitempty"`
        StartedAt   *time.Time       `json:"started_at,omitempty"`
        CompletedAt *time.Time       `json:"completed_at,omitempty"`
}

// Broadcaster defines the interface for broadcasting execution events
type Broadcaster interface {
        // BroadcastExecutionStarted broadcasts when execution starts
        BroadcastExecutionStarted(tenantID, workflowID, executionID string, totalSteps int)

        // BroadcastExecutionCompleted broadcasts when execution completes
        BroadcastExecutionCompleted(tenantID, workflowID, executionID string, output json.RawMessage)

        // BroadcastExecutionFailed broadcasts when execution fails
        BroadcastExecutionFailed(tenantID, workflowID, executionID string, errorMsg string)

        // BroadcastStepStarted broadcasts when a step starts
        BroadcastStepStarted(tenantID, workflowID, executionID, nodeID, nodeType string)

        // BroadcastStepCompleted broadcasts when a step completes
        BroadcastStepCompleted(tenantID, workflowID, executionID, nodeID string, output json.RawMessage, durationMs int)

        // BroadcastStepFailed broadcasts when a step fails
        BroadcastStepFailed(tenantID, workflowID, executionID, nodeID string, errorMsg string)

        // BroadcastProgress broadcasts execution progress
        BroadcastProgress(tenantID, workflowID, executionID string, completedSteps, totalSteps int)
}

// HubBroadcaster implements Broadcaster using the WebSocket Hub
type HubBroadcaster struct {
        hub *Hub
}

// NewHubBroadcaster creates a new HubBroadcaster
func NewHubBroadcaster(hub *Hub) *HubBroadcaster <span class="cov8" title="1">{
        return &amp;HubBroadcaster{hub: hub}
}</span>

// Room helpers
func executionRoom(executionID string) string <span class="cov8" title="1">{
        return "execution:" + executionID
}</span>

func workflowRoom(workflowID string) string <span class="cov8" title="1">{
        return "workflow:" + workflowID
}</span>

func tenantRoom(tenantID string) string <span class="cov8" title="1">{
        return "tenant:" + tenantID
}</span>

// BroadcastExecutionStarted broadcasts when execution starts
func (b *HubBroadcaster) BroadcastExecutionStarted(tenantID, workflowID, executionID string, totalSteps int) <span class="cov8" title="1">{
        event := ExecutionEvent{
                Type:        EventTypeExecutionStarted,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Status:      "running",
                Progress: &amp;ProgressInfo{
                        TotalSteps:     totalSteps,
                        CompletedSteps: 0,
                        Percentage:     0,
                },
                Timestamp: time.Now(),
        }

        b.broadcast(executionID, workflowID, tenantID, event)
}</span>

// BroadcastExecutionCompleted broadcasts when execution completes
func (b *HubBroadcaster) BroadcastExecutionCompleted(tenantID, workflowID, executionID string, output json.RawMessage) <span class="cov8" title="1">{
        event := ExecutionEvent{
                Type:        EventTypeExecutionCompleted,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Status:      "completed",
                Output:      &amp;output,
                Timestamp:   time.Now(),
        }

        b.broadcast(executionID, workflowID, tenantID, event)
}</span>

// BroadcastExecutionFailed broadcasts when execution fails
func (b *HubBroadcaster) BroadcastExecutionFailed(tenantID, workflowID, executionID string, errorMsg string) <span class="cov8" title="1">{
        event := ExecutionEvent{
                Type:        EventTypeExecutionFailed,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Status:      "failed",
                Error:       &amp;errorMsg,
                Timestamp:   time.Now(),
        }

        b.broadcast(executionID, workflowID, tenantID, event)
}</span>

// BroadcastStepStarted broadcasts when a step starts
func (b *HubBroadcaster) BroadcastStepStarted(tenantID, workflowID, executionID, nodeID, nodeType string) <span class="cov8" title="1">{
        now := time.Now()
        event := ExecutionEvent{
                Type:        EventTypeStepStarted,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Step: &amp;StepInfo{
                        NodeID:    nodeID,
                        NodeType:  nodeType,
                        Status:    "running",
                        StartedAt: &amp;now,
                },
                Timestamp: now,
        }

        b.broadcast(executionID, workflowID, tenantID, event)
}</span>

// BroadcastStepCompleted broadcasts when a step completes
func (b *HubBroadcaster) BroadcastStepCompleted(tenantID, workflowID, executionID, nodeID string, output json.RawMessage, durationMs int) <span class="cov8" title="1">{
        now := time.Now()
        event := ExecutionEvent{
                Type:        EventTypeStepCompleted,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Step: &amp;StepInfo{
                        NodeID:      nodeID,
                        Status:      "completed",
                        OutputData:  &amp;output,
                        DurationMs:  &amp;durationMs,
                        CompletedAt: &amp;now,
                },
                Timestamp: now,
        }

        b.broadcast(executionID, workflowID, tenantID, event)
}</span>

// BroadcastStepFailed broadcasts when a step fails
func (b *HubBroadcaster) BroadcastStepFailed(tenantID, workflowID, executionID, nodeID string, errorMsg string) <span class="cov0" title="0">{
        now := time.Now()
        event := ExecutionEvent{
                Type:        EventTypeStepFailed,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Step: &amp;StepInfo{
                        NodeID:      nodeID,
                        Status:      "failed",
                        ErrorMsg:    &amp;errorMsg,
                        CompletedAt: &amp;now,
                },
                Timestamp: now,
        }

        b.broadcast(executionID, workflowID, tenantID, event)
}</span>

// BroadcastProgress broadcasts execution progress
func (b *HubBroadcaster) BroadcastProgress(tenantID, workflowID, executionID string, completedSteps, totalSteps int) <span class="cov8" title="1">{
        percentage := 0.0
        if totalSteps &gt; 0 </span><span class="cov8" title="1">{
                percentage = float64(completedSteps) / float64(totalSteps) * 100.0
        }</span>

        <span class="cov8" title="1">event := ExecutionEvent{
                Type:        EventTypeExecutionProgress,
                ExecutionID: executionID,
                WorkflowID:  workflowID,
                TenantID:    tenantID,
                Progress: &amp;ProgressInfo{
                        TotalSteps:     totalSteps,
                        CompletedSteps: completedSteps,
                        Percentage:     percentage,
                },
                Timestamp: time.Now(),
        }

        b.broadcast(executionID, workflowID, tenantID, event)</span>
}

// broadcast sends an event to all relevant rooms
func (b *HubBroadcaster) broadcast(executionID, workflowID, tenantID string, event ExecutionEvent) <span class="cov8" title="1">{
        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Broadcast to execution-specific room
        <span class="cov8" title="1">b.hub.BroadcastToRoom(executionRoom(executionID), data)

        // Also broadcast to workflow room (for workflow monitoring)
        b.hub.BroadcastToRoom(workflowRoom(workflowID), data)

        // Also broadcast to tenant room (for dashboard)
        b.hub.BroadcastToRoom(tenantRoom(tenantID), data)</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package websocket

import (
        "log/slog"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

// Client represents a WebSocket client connection
type Client struct {
        ID            string
        TenantID      string
        Conn          *websocket.Conn
        Hub           *Hub
        Send          chan []byte
        Subscriptions map[string]bool
        mu            sync.RWMutex
}

// Hub manages all WebSocket connections and message broadcasting
type Hub struct {
        // Registered clients by client ID
        clients map[string]*Client

        // Clients grouped by subscription room
        rooms map[string]map[string]*Client

        // Register client (exported for handler)
        Register chan *Client

        // Unregister client (exported for handler)
        Unregister chan *Client

        // Broadcast message to specific room
        broadcast chan *BroadcastMessage

        // Mutex for thread-safe operations
        mu sync.RWMutex

        logger *slog.Logger
}

// BroadcastMessage represents a message to broadcast to a room
type BroadcastMessage struct {
        Room    string
        Message []byte
}

// NewHub creates a new WebSocket hub
func NewHub(logger *slog.Logger) *Hub <span class="cov8" title="1">{
        return &amp;Hub{
                clients:    make(map[string]*Client),
                rooms:      make(map[string]map[string]*Client),
                Register:   make(chan *Client),
                Unregister: make(chan *Client),
                broadcast:  make(chan *BroadcastMessage, 256),
                logger:     logger,
        }
}</span>

// Run starts the hub's main loop
func (h *Hub) Run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case client := &lt;-h.Register:<span class="cov8" title="1">
                        h.registerClient(client)</span>

                case client := &lt;-h.Unregister:<span class="cov8" title="1">
                        h.unregisterClient(client)</span>

                case message := &lt;-h.broadcast:<span class="cov8" title="1">
                        h.broadcastToRoom(message)</span>
                }
        }
}

// registerClient registers a new client
func (h *Hub) registerClient(client *Client) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        h.clients[client.ID] = client
        h.logger.Info("client registered",
                "client_id", client.ID,
                "tenant_id", client.TenantID,
        )
}</span>

// unregisterClient removes a client and cleans up their subscriptions
func (h *Hub) unregisterClient(client *Client) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if _, exists := h.clients[client.ID]; exists </span><span class="cov8" title="1">{
                delete(h.clients, client.ID)

                // Remove from all rooms
                client.mu.RLock()
                for room := range client.Subscriptions </span><span class="cov0" title="0">{
                        if clients, exists := h.rooms[room]; exists </span><span class="cov0" title="0">{
                                delete(clients, client.ID)
                                if len(clients) == 0 </span><span class="cov0" title="0">{
                                        delete(h.rooms, room)
                                }</span>
                        }
                }
                <span class="cov8" title="1">client.mu.RUnlock()

                close(client.Send)

                h.logger.Info("client unregistered",
                        "client_id", client.ID,
                        "tenant_id", client.TenantID,
                )</span>
        }
}

// SubscribeClient subscribes a client to a room
func (h *Hub) SubscribeClient(client *Client, room string) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        client.mu.Lock()
        defer client.mu.Unlock()

        // Add to client's subscriptions
        client.Subscriptions[room] = true

        // Add to room's clients
        if _, exists := h.rooms[room]; !exists </span><span class="cov8" title="1">{
                h.rooms[room] = make(map[string]*Client)
        }</span>
        <span class="cov8" title="1">h.rooms[room][client.ID] = client

        h.logger.Info("client subscribed to room",
                "client_id", client.ID,
                "room", room,
        )</span>
}

// UnsubscribeClient unsubscribes a client from a room
func (h *Hub) UnsubscribeClient(client *Client, room string) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        client.mu.Lock()
        defer client.mu.Unlock()

        // Remove from client's subscriptions
        delete(client.Subscriptions, room)

        // Remove from room's clients
        if clients, exists := h.rooms[room]; exists </span><span class="cov8" title="1">{
                delete(clients, client.ID)
                if len(clients) == 0 </span><span class="cov8" title="1">{
                        delete(h.rooms, room)
                }</span>
        }

        <span class="cov8" title="1">h.logger.Info("client unsubscribed from room",
                "client_id", client.ID,
                "room", room,
        )</span>
}

// BroadcastToRoom sends a message to all clients in a room
func (h *Hub) BroadcastToRoom(room string, message []byte) <span class="cov8" title="1">{
        h.broadcast &lt;- &amp;BroadcastMessage{
                Room:    room,
                Message: message,
        }
}</span>

// broadcastToRoom performs the actual broadcast
func (h *Hub) broadcastToRoom(msg *BroadcastMessage) <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        if clients, exists := h.rooms[msg.Room]; exists </span><span class="cov8" title="1">{
                h.logger.Debug("broadcasting to room",
                        "room", msg.Room,
                        "client_count", len(clients),
                )

                for _, client := range clients </span><span class="cov8" title="1">{
                        select </span>{
                        case client.Send &lt;- msg.Message:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0">
                                // Client's send channel is full, skip
                                h.logger.Warn("client send channel full, dropping message",
                                        "client_id", client.ID,
                                        "room", msg.Room,
                                )</span>
                        }
                }
        }
}

// Client read and write pumps

const (
        // Time allowed to write a message to the peer
        writeWait = 10 * time.Second

        // Time allowed to read the next pong message from the peer
        pongWait = 60 * time.Second

        // Send pings to peer with this period (must be less than pongWait)
        pingPeriod = (pongWait * 9) / 10

        // Maximum message size allowed from peer
        maxMessageSize = 512 * 1024 // 512KB
)

// ReadPump pumps messages from the WebSocket connection to the hub
func (c *Client) ReadPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.Hub.Unregister &lt;- c
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">c.Conn.SetReadDeadline(time.Now().Add(pongWait))
        c.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.Conn.SetReadDeadline(time.Now().Add(pongWait))
                return nil
        }</span>)

        <span class="cov0" title="0">c.Conn.SetReadLimit(maxMessageSize)

        for </span><span class="cov0" title="0">{
                _, message, err := c.Conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                c.Hub.logger.Error("websocket error", "error", err, "client_id", c.ID)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                // Handle incoming messages (subscriptions, etc.)
                <span class="cov0" title="0">c.handleMessage(message)</span>
        }
}

// WritePump pumps messages from the hub to the WebSocket connection
func (c *Client) WritePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-c.Send:<span class="cov0" title="0">
                        c.Conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if !ok </span><span class="cov0" title="0">{
                                // The hub closed the channel
                                c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := c.Conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">w.Write(message)

                        // Add queued messages to the current websocket message
                        n := len(c.Send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                w.Write([]byte{'\n'})
                                w.Write(&lt;-c.Send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.Conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// handleMessage processes incoming messages from clients
func (c *Client) handleMessage(message []byte) {<span class="cov0" title="0">
        // Parse message and handle subscription requests
        // Message format: {"type": "subscribe", "room": "execution:123"}
        // For now, we'll handle subscriptions through HTTP params
        // This can be extended later for dynamic subscriptions
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package worker

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// TenantConcurrencyLimiter manages per-tenant concurrency limits
type TenantConcurrencyLimiter struct {
        redis       *redis.Client
        maxPerTenant int
        keyPrefix   string
}

// NewTenantConcurrencyLimiter creates a new tenant concurrency limiter
func NewTenantConcurrencyLimiter(redis *redis.Client, maxPerTenant int) *TenantConcurrencyLimiter <span class="cov0" title="0">{
        return &amp;TenantConcurrencyLimiter{
                redis:        redis,
                maxPerTenant: maxPerTenant,
                keyPrefix:    "tenant:concurrency:",
        }
}</span>

// Acquire attempts to acquire a concurrency slot for a tenant
// Returns true if acquired, false if tenant is at capacity
func (tcl *TenantConcurrencyLimiter) Acquire(ctx context.Context, tenantID string, executionID string) (bool, error) <span class="cov0" title="0">{
        key := tcl.keyPrefix + tenantID

        // Use Redis ZADD with NX to atomically check and increment
        // Store execution ID with current timestamp as score
        now := float64(time.Now().Unix())

        // First, clean up old entries (executions that finished more than 1 hour ago)
        cutoff := now - 3600
        tcl.redis.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%f", cutoff))

        // Count current active executions
        count, err := tcl.redis.ZCard(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check tenant concurrency: %w", err)
        }</span>

        // Check if at capacity
        <span class="cov0" title="0">if int(count) &gt;= tcl.maxPerTenant </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Add this execution
        <span class="cov0" title="0">_, err = tcl.redis.ZAdd(ctx, key, redis.Z{
                Score:  now,
                Member: executionID,
        }).Result()

        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to acquire concurrency slot: %w", err)
        }</span>

        // Set expiry on the key to ensure cleanup
        <span class="cov0" title="0">tcl.redis.Expire(ctx, key, 24*time.Hour)

        return true, nil</span>
}

// Release releases a concurrency slot for a tenant
func (tcl *TenantConcurrencyLimiter) Release(ctx context.Context, tenantID string, executionID string) error <span class="cov0" title="0">{
        key := tcl.keyPrefix + tenantID

        _, err := tcl.redis.ZRem(ctx, key, executionID).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to release concurrency slot: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetCurrent returns the current concurrency count for a tenant
func (tcl *TenantConcurrencyLimiter) GetCurrent(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        key := tcl.keyPrefix + tenantID

        // Clean up old entries first
        now := float64(time.Now().Unix())
        cutoff := now - 3600
        tcl.redis.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%f", cutoff))

        count, err := tcl.redis.ZCard(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get tenant concurrency: %w", err)
        }</span>

        <span class="cov0" title="0">return int(count), nil</span>
}

// GetMaxPerTenant returns the maximum concurrent executions per tenant
func (tcl *TenantConcurrencyLimiter) GetMaxPerTenant() int <span class="cov0" title="0">{
        return tcl.maxPerTenant
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package worker

import (
        "context"
        "encoding/json"
        "net/http"
        "sync/atomic"
        "time"
)

// HealthServer provides health check endpoints for the worker
type HealthServer struct {
        worker *Worker
        server *http.Server
        ready  atomic.Bool
}

// HealthResponse represents the health check response
type HealthResponse struct {
        Status      string            `json:"status"`
        Timestamp   time.Time         `json:"timestamp"`
        Version     string            `json:"version"`
        WorkerInfo  WorkerInfo        `json:"worker_info"`
        Connections ConnectionsHealth `json:"connections"`
}

// WorkerInfo contains worker statistics
type WorkerInfo struct {
        Concurrency       int   `json:"concurrency"`
        ActiveExecutions  int32 `json:"active_executions"`
        ProcessedTotal    int64 `json:"processed_total"`
        FailedTotal       int64 `json:"failed_total"`
}

// ConnectionsHealth contains connection status
type ConnectionsHealth struct {
        Database string `json:"database"`
        Redis    string `json:"redis"`
        Queue    string `json:"queue"`
}

// NewHealthServer creates a new health check server
func NewHealthServer(worker *Worker, port string) *HealthServer <span class="cov0" title="0">{
        hs := &amp;HealthServer{
                worker: worker,
        }

        mux := http.NewServeMux()
        mux.HandleFunc("/health/live", hs.handleLiveness)
        mux.HandleFunc("/health/ready", hs.handleReadiness)
        mux.HandleFunc("/health", hs.handleHealth)

        hs.server = &amp;http.Server{
                Addr:         ":" + port,
                Handler:      mux,
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
        }

        return hs
}</span>

// Start starts the health check server
func (hs *HealthServer) Start() error <span class="cov0" title="0">{
        hs.worker.logger.Info("starting health check server", "port", hs.server.Addr)
        hs.ready.Store(true)
        return hs.server.ListenAndServe()
}</span>

// Shutdown gracefully shuts down the health server
func (hs *HealthServer) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        hs.ready.Store(false)
        return hs.server.Shutdown(ctx)
}</span>

// SetReady sets the ready state
func (hs *HealthServer) SetReady(ready bool) <span class="cov0" title="0">{
        hs.ready.Store(ready)
}</span>

// handleLiveness handles Kubernetes liveness probe
// Returns 200 if worker process is alive
func (hs *HealthServer) handleLiveness(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{
                "status": "alive",
                "time":   time.Now().Format(time.RFC3339),
        })
}</span>

// handleReadiness handles Kubernetes readiness probe
// Returns 200 if worker is ready to process work
func (hs *HealthServer) handleReadiness(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !hs.ready.Load() </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]string{
                        "status": "not_ready",
                        "time":   time.Now().Format(time.RFC3339),
                })
                return
        }</span>

        // Check if worker can accept more work
        <span class="cov0" title="0">if hs.worker.getActiveExecutions() &gt;= int32(hs.worker.concurrency) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusServiceUnavailable)
                json.NewEncoder(w).Encode(map[string]string{
                        "status": "at_capacity",
                        "time":   time.Now().Format(time.RFC3339),
                })
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{
                "status": "ready",
                "time":   time.Now().Format(time.RFC3339),
        })</span>
}

// handleHealth provides detailed health information
func (hs *HealthServer) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
        defer cancel()

        response := HealthResponse{
                Status:    "healthy",
                Timestamp: time.Now(),
                Version:   "1.0.0", // TODO: Get from build info
                WorkerInfo: WorkerInfo{
                        Concurrency:      hs.worker.concurrency,
                        ActiveExecutions: hs.worker.getActiveExecutions(),
                        ProcessedTotal:   hs.worker.getProcessedCount(),
                        FailedTotal:      hs.worker.getFailedCount(),
                },
                Connections: ConnectionsHealth{
                        Database: hs.checkDatabase(ctx),
                        Redis:    hs.checkRedis(ctx),
                        Queue:    "ok", // TODO: Check queue connection
                },
        }

        // If any connection is unhealthy, set overall status to unhealthy
        if response.Connections.Database != "ok" || response.Connections.Redis != "ok" </span><span class="cov0" title="0">{
                response.Status = "unhealthy"
                w.WriteHeader(http.StatusServiceUnavailable)
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusOK)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// checkDatabase checks database connectivity
func (hs *HealthServer) checkDatabase(ctx context.Context) string <span class="cov0" title="0">{
        if err := hs.worker.db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return "error: " + err.Error()
        }</span>
        <span class="cov0" title="0">return "ok"</span>
}

// checkRedis checks Redis connectivity
func (hs *HealthServer) checkRedis(ctx context.Context) string <span class="cov0" title="0">{
        if err := hs.worker.redis.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return "error: " + err.Error()
        }</span>
        <span class="cov0" title="0">return "ok"</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package worker

import (
        "context"
        "log/slog"
        "sync"
        "sync/atomic"
        "time"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq"
        "github.com/redis/go-redis/v9"

        "github.com/gorax/gorax/internal/config"
        "github.com/gorax/gorax/internal/executor"
        "github.com/gorax/gorax/internal/queue"
        "github.com/gorax/gorax/internal/workflow"
)

// Worker processes workflow executions
type Worker struct {
        config   *config.Config
        logger   *slog.Logger
        db       *sqlx.DB
        redis    *redis.Client
        executor *executor.Executor
        workflowRepo *workflow.Repository

        // Queue-based processing
        queueConsumer  *queue.Consumer
        queueEnabled   bool

        concurrency      int
        concurrencyLimit *TenantConcurrencyLimiter
        wg               sync.WaitGroup

        // Metrics
        activeExecutions atomic.Int32
        processedTotal   atomic.Int64
        failedTotal      atomic.Int64
}

// New creates a new worker instance
func New(cfg *config.Config, logger *slog.Logger) (*Worker, error) <span class="cov0" title="0">{
        // Initialize database connection
        db, err := sqlx.Connect("postgres", cfg.Database.ConnectionString())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize Redis client
        <span class="cov0" title="0">redisClient := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Redis.Address,
                Password: cfg.Redis.Password,
                DB:       cfg.Redis.DB,
        })

        // Initialize workflow repository
        workflowRepo := workflow.NewRepository(db)

        // Initialize executor
        exec := executor.New(workflowRepo, logger)

        // Initialize tenant concurrency limiter
        // Default to 10 concurrent executions per tenant if not configured
        maxPerTenant := 10
        if cfg.Worker.MaxConcurrencyPerTenant &gt; 0 </span><span class="cov0" title="0">{
                maxPerTenant = cfg.Worker.MaxConcurrencyPerTenant
        }</span>
        <span class="cov0" title="0">concurrencyLimit := NewTenantConcurrencyLimiter(redisClient, maxPerTenant)

        w := &amp;Worker{
                config:           cfg,
                logger:           logger,
                db:               db,
                redis:            redisClient,
                executor:         exec,
                workflowRepo:     workflowRepo,
                concurrency:      cfg.Worker.Concurrency,
                concurrencyLimit: concurrencyLimit,
                queueEnabled:     cfg.Queue.Enabled,
        }

        // Initialize queue consumer if enabled
        if cfg.Queue.Enabled </span><span class="cov0" title="0">{
                if cfg.AWS.SQSQueueURL == "" </span><span class="cov0" title="0">{
                        return nil, ErrMissingQueueURL
                }</span>

                // Create SQS client
                <span class="cov0" title="0">sqsClient, err := queue.NewSQSClient(context.Background(), queue.SQSConfig{
                        QueueURL:        cfg.AWS.SQSQueueURL,
                        DLQueueURL:      cfg.AWS.SQSDLQueueURL,
                        Region:          cfg.AWS.Region,
                        AccessKeyID:     cfg.AWS.AccessKeyID,
                        SecretAccessKey: cfg.AWS.SecretAccessKey,
                        Endpoint:        cfg.AWS.Endpoint,
                }, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Create message handler
                <span class="cov0" title="0">handler := func(ctx context.Context, msg *queue.ExecutionMessage) error </span><span class="cov0" title="0">{
                        return w.processExecutionMessage(ctx, msg)
                }</span>

                // Create consumer config
                <span class="cov0" title="0">consumerConfig := queue.ConsumerConfig{
                        MaxMessages:        cfg.Queue.MaxMessages,
                        WaitTimeSeconds:    cfg.Queue.WaitTimeSeconds,
                        VisibilityTimeout:  cfg.Queue.VisibilityTimeout,
                        MaxRetries:         cfg.Queue.MaxRetries,
                        ProcessTimeout:     time.Duration(cfg.Queue.ProcessTimeout) * time.Second,
                        PollInterval:       time.Duration(cfg.Queue.PollInterval) * time.Second,
                        ConcurrentWorkers:  cfg.Queue.ConcurrentWorkers,
                        DeleteAfterProcess: cfg.Queue.DeleteAfterProcess,
                }

                // Create consumer
                w.queueConsumer = queue.NewConsumer(sqsClient, handler, consumerConfig, logger)
                logger.Info("queue consumer initialized", "queue_url", cfg.AWS.SQSQueueURL)</span>
        }

        <span class="cov0" title="0">return w, nil</span>
}

// Start begins processing jobs
func (w *Worker) Start(ctx context.Context) error <span class="cov0" title="0">{
        if w.queueEnabled &amp;&amp; w.queueConsumer != nil </span><span class="cov0" title="0">{
                // Use queue-based processing
                w.logger.Info("starting queue-based worker", "queue_enabled", true)
                return w.queueConsumer.Start(ctx)
        }</span>

        // Fallback to polling-based processing (backward compatibility)
        <span class="cov0" title="0">w.logger.Info("starting worker pool", "concurrency", w.concurrency, "queue_enabled", false)

        // Start worker goroutines
        for i := 0; i &lt; w.concurrency; i++ </span><span class="cov0" title="0">{
                w.wg.Add(1)
                go w.processLoop(ctx, i)
        }</span>

        // Wait for context cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()
        return ctx.Err()</span>
}

// processLoop is the main processing loop for a worker
func (w *Worker) processLoop(ctx context.Context, workerID int) <span class="cov0" title="0">{
        defer w.wg.Done()

        w.logger.Info("worker started", "worker_id", workerID)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        w.logger.Info("worker stopping", "worker_id", workerID)
                        return</span>
                default:<span class="cov0" title="0">
                        // Poll for pending executions
                        execution, err := w.pollExecution(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                // No work available, wait a bit
                                continue</span>
                        }

                        // Process the execution
                        <span class="cov0" title="0">if err := w.processExecution(ctx, execution); err != nil </span><span class="cov0" title="0">{
                                w.logger.Error("execution failed", "error", err, "execution_id", execution.ID)
                        }</span>
                }
        }
}

// pollExecution polls for pending executions
func (w *Worker) pollExecution(ctx context.Context) (*workflow.Execution, error) <span class="cov0" title="0">{
        // TODO: Implement polling from queue (SQS) or database
        // For now, this is a placeholder that returns an error to indicate no work

        // In production, this would:
        // 1. Receive message from SQS queue
        // 2. Parse execution ID from message
        // 3. Load execution from database
        // 4. Return execution for processing

        return nil, ErrNoWork
}</span>

// processExecution processes a single execution
func (w *Worker) processExecution(ctx context.Context, execution *workflow.Execution) error <span class="cov0" title="0">{
        w.logger.Info("processing execution", "execution_id", execution.ID, "workflow_id", execution.WorkflowID, "tenant_id", execution.TenantID)

        // Try to acquire tenant concurrency slot
        acquired, err := w.concurrencyLimit.Acquire(ctx, execution.TenantID, execution.ID)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("failed to acquire tenant concurrency slot", "error", err, "tenant_id", execution.TenantID)
                return err
        }</span>

        <span class="cov0" title="0">if !acquired </span><span class="cov0" title="0">{
                w.logger.Warn("tenant at concurrency limit, requeueing execution",
                        "tenant_id", execution.TenantID,
                        "execution_id", execution.ID,
                        "max_concurrent", w.concurrencyLimit.GetMaxPerTenant(),
                )
                // TODO: Requeue the message with delay
                return ErrTenantAtCapacity
        }</span>

        // Release the slot when done
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := w.concurrencyLimit.Release(ctx, execution.TenantID, execution.ID); err != nil </span><span class="cov0" title="0">{
                        w.logger.Error("failed to release tenant concurrency slot", "error", err, "tenant_id", execution.TenantID)
                }</span>
        }()

        // Track active executions
        <span class="cov0" title="0">w.activeExecutions.Add(1)
        defer w.activeExecutions.Add(-1)

        // Execute the workflow
        err = w.executor.Execute(ctx, execution)
        if err != nil </span><span class="cov0" title="0">{
                w.failedTotal.Add(1)
                return err
        }</span>

        <span class="cov0" title="0">w.logger.Info("execution completed", "execution_id", execution.ID)
        w.processedTotal.Add(1)
        return nil</span>
}

// processExecutionMessage processes an execution message from the queue
func (w *Worker) processExecutionMessage(ctx context.Context, msg *queue.ExecutionMessage) error <span class="cov0" title="0">{
        w.logger.Info("processing execution message",
                "execution_id", msg.ExecutionID,
                "workflow_id", msg.WorkflowID,
                "tenant_id", msg.TenantID,
        )

        // Load execution from database
        execution, err := w.workflowRepo.GetExecutionByID(ctx, msg.TenantID, msg.ExecutionID)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error("failed to load execution",
                        "error", err,
                        "execution_id", msg.ExecutionID,
                )
                return err
        }</span>

        // Process the execution
        <span class="cov0" title="0">if err := w.processExecution(ctx, execution); err != nil </span><span class="cov0" title="0">{
                w.logger.Error("execution processing failed",
                        "error", err,
                        "execution_id", msg.ExecutionID,
                )
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Wait waits for all workers to finish
func (w *Worker) Wait() <span class="cov0" title="0">{
        w.wg.Wait()
}</span>

// Close cleans up worker resources
func (w *Worker) Close() error <span class="cov0" title="0">{
        if w.db != nil </span><span class="cov0" title="0">{
                w.db.Close()
        }</span>
        <span class="cov0" title="0">if w.redis != nil </span><span class="cov0" title="0">{
                w.redis.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// getActiveExecutions returns the current number of active executions
func (w *Worker) getActiveExecutions() int32 <span class="cov0" title="0">{
        return w.activeExecutions.Load()
}</span>

// getProcessedCount returns the total number of processed executions
func (w *Worker) getProcessedCount() int64 <span class="cov0" title="0">{
        return w.processedTotal.Load()
}</span>

// getFailedCount returns the total number of failed executions
func (w *Worker) getFailedCount() int64 <span class="cov0" title="0">{
        return w.failedTotal.Load()
}</span>

// Custom errors
type WorkerError struct {
        Message string
}

func (e WorkerError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

var (
        ErrNoWork           = WorkerError{Message: "no work available"}
        ErrTenantAtCapacity = WorkerError{Message: "tenant at concurrency capacity"}
        ErrMissingQueueURL  = WorkerError{Message: "queue URL is required when queue is enabled"}
)
</pre>
		
		<pre class="file" id="file82" style="display: none">package formula

import (
        "fmt"
        "time"

        "github.com/expr-lang/expr"
        "github.com/expr-lang/expr/vm"
)

// Evaluator handles formula evaluation with built-in functions
type Evaluator struct {
        program *vm.Program
        env     map[string]interface{}
}

// NewEvaluator creates a new formula evaluator with all built-in functions
func NewEvaluator() *Evaluator <span class="cov8" title="1">{
        return &amp;Evaluator{
                env: buildEnvironment(),
        }
}</span>

// Evaluate compiles and evaluates an expression with the given context
func (e *Evaluator) Evaluate(expression string, context map[string]interface{}) (interface{}, error) <span class="cov8" title="1">{
        if expression == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression cannot be empty")
        }</span>

        // Merge context with built-in functions
        <span class="cov8" title="1">env := make(map[string]interface{})
        for k, v := range e.env </span><span class="cov8" title="1">{
                env[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range context </span><span class="cov8" title="1">{
                env[k] = v
        }</span>

        // Compile and run the expression
        <span class="cov8" title="1">program, err := expr.Compile(expression, expr.Env(env))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to compile expression: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := expr.Run(program, env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to evaluate expression: %w", err)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// EvaluateWithType evaluates an expression and ensures the result matches the expected type
func (e *Evaluator) EvaluateWithType(expression string, context map[string]interface{}, expectedType interface{}) (interface{}, error) <span class="cov0" title="0">{
        result, err := e.Evaluate(expression, context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Type checking would go here if needed
        <span class="cov0" title="0">return result, nil</span>
}

// buildEnvironment creates the environment with all built-in functions
func buildEnvironment() map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                // String functions
                "upper":  wrapStringFunc1(stringUpper),
                "lower":  wrapStringFunc1(stringLower),
                "trim":   wrapStringFunc1(stringTrim),
                "concat": stringConcat,
                "substr": stringSubstr,

                // Date functions
                "now":        dateNow,
                "dateFormat": dateFormat,
                "dateParse":  dateParse,
                "addDays":    dateAddDays,

                // Math functions
                "round": wrapMathFunc(mathRound),
                "ceil":  wrapMathFunc(mathCeil),
                "floor": wrapMathFunc(mathFloor),
                "abs":   wrapMathFunc(mathAbs),
                "min":   mathMin,
                "max":   mathMax,

                // Array/String functions
                "len": lenFunc,
        }
}</span>

// wrapStringFunc1 wraps a string function to handle the interface{} return
func wrapStringFunc1(fn func(interface{}) (string, error)) func(interface{}) interface{} <span class="cov8" title="1">{
        return func(arg interface{}) interface{} </span><span class="cov8" title="1">{
                result, err := fn(arg)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">return result</span>
        }
}

// wrapMathFunc wraps a math function to handle the float64 return
func wrapMathFunc(fn func(float64) (float64, error)) func(float64) float64 <span class="cov8" title="1">{
        return func(arg float64) float64 </span><span class="cov8" title="1">{
                result, err := fn(arg)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">return result</span>
        }
}

// ValidateExpression validates an expression without executing it
func (e *Evaluator) ValidateExpression(expression string) error <span class="cov0" title="0">{
        if expression == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("expression cannot be empty")
        }</span>

        <span class="cov0" title="0">_, err := expr.Compile(expression, expr.Env(e.env))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid expression: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAvailableFunctions returns a list of all available function names
func (e *Evaluator) GetAvailableFunctions() []string <span class="cov0" title="0">{
        functions := []string{
                "upper", "lower", "trim", "concat", "substr",
                "now", "dateFormat", "dateParse", "addDays",
                "round", "ceil", "floor", "abs", "min", "max",
                "len",
        }
        return functions
}</span>

// FunctionInfo provides documentation for a function
type FunctionInfo struct {
        Name        string
        Description string
        Parameters  []string
        ReturnType  string
        Example     string
}

// GetFunctionInfo returns documentation for all built-in functions
func GetFunctionInfo() []FunctionInfo <span class="cov0" title="0">{
        return []FunctionInfo{
                // String functions
                {
                        Name:        "upper",
                        Description: "Converts a string to uppercase",
                        Parameters:  []string{"string"},
                        ReturnType:  "string",
                        Example:     `upper("hello") =&gt; "HELLO"`,
                },
                {
                        Name:        "lower",
                        Description: "Converts a string to lowercase",
                        Parameters:  []string{"string"},
                        ReturnType:  "string",
                        Example:     `lower("HELLO") =&gt; "hello"`,
                },
                {
                        Name:        "trim",
                        Description: "Removes leading and trailing whitespace",
                        Parameters:  []string{"string"},
                        ReturnType:  "string",
                        Example:     `trim("  hello  ") =&gt; "hello"`,
                },
                {
                        Name:        "concat",
                        Description: "Concatenates multiple strings",
                        Parameters:  []string{"...strings"},
                        ReturnType:  "string",
                        Example:     `concat("hello", " ", "world") =&gt; "hello world"`,
                },
                {
                        Name:        "substr",
                        Description: "Extracts a substring",
                        Parameters:  []string{"string", "start", "length"},
                        ReturnType:  "string",
                        Example:     `substr("hello world", 0, 5) =&gt; "hello"`,
                },

                // Date functions
                {
                        Name:        "now",
                        Description: "Returns the current time",
                        Parameters:  []string{},
                        ReturnType:  "time",
                        Example:     `now()`,
                },
                {
                        Name:        "dateFormat",
                        Description: "Formats a time value",
                        Parameters:  []string{"time", "layout"},
                        ReturnType:  "string",
                        Example:     `dateFormat(now(), "2006-01-02") =&gt; "2025-12-17"`,
                },
                {
                        Name:        "dateParse",
                        Description: "Parses a time string",
                        Parameters:  []string{"value", "layout"},
                        ReturnType:  "time",
                        Example:     `dateParse("2025-12-17", "2006-01-02")`,
                },
                {
                        Name:        "addDays",
                        Description: "Adds days to a time value",
                        Parameters:  []string{"time", "days"},
                        ReturnType:  "time",
                        Example:     `addDays(now(), 5)`,
                },

                // Math functions
                {
                        Name:        "round",
                        Description: "Rounds to the nearest integer",
                        Parameters:  []string{"number"},
                        ReturnType:  "number",
                        Example:     `round(4.6) =&gt; 5`,
                },
                {
                        Name:        "ceil",
                        Description: "Rounds up to the nearest integer",
                        Parameters:  []string{"number"},
                        ReturnType:  "number",
                        Example:     `ceil(4.1) =&gt; 5`,
                },
                {
                        Name:        "floor",
                        Description: "Rounds down to the nearest integer",
                        Parameters:  []string{"number"},
                        ReturnType:  "number",
                        Example:     `floor(4.9) =&gt; 4`,
                },
                {
                        Name:        "abs",
                        Description: "Returns the absolute value",
                        Parameters:  []string{"number"},
                        ReturnType:  "number",
                        Example:     `abs(-5) =&gt; 5`,
                },
                {
                        Name:        "min",
                        Description: "Returns the minimum value",
                        Parameters:  []string{"...numbers"},
                        ReturnType:  "number",
                        Example:     `min(5, 3, 7, 1) =&gt; 1`,
                },
                {
                        Name:        "max",
                        Description: "Returns the maximum value",
                        Parameters:  []string{"...numbers"},
                        ReturnType:  "number",
                        Example:     `max(5, 3, 7, 1) =&gt; 7`,
                },

                // Array/String functions
                {
                        Name:        "len",
                        Description: "Returns the length of an array or string",
                        Parameters:  []string{"arrayOrString"},
                        ReturnType:  "number",
                        Example:     `len([1, 2, 3]) =&gt; 3, len("hello") =&gt; 5`,
                },
        }
}</span>

// Helper function to convert time.Time to a format that expr can handle
func timeToExpr(t time.Time) interface{} <span class="cov0" title="0">{
        return t
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package formula

import (
        "fmt"
        "math"
        "strconv"
        "strings"
        "time"
)

// String Functions

// stringUpper converts a string to uppercase
func stringUpper(s interface{}) (string, error) <span class="cov8" title="1">{
        str := toString(s)
        return strings.ToUpper(str), nil
}</span>

// stringLower converts a string to lowercase
func stringLower(s interface{}) (string, error) <span class="cov8" title="1">{
        str := toString(s)
        return strings.ToLower(str), nil
}</span>

// stringTrim removes leading and trailing whitespace
func stringTrim(s interface{}) (string, error) <span class="cov8" title="1">{
        str := toString(s)
        return strings.TrimSpace(str), nil
}</span>

// stringConcat concatenates multiple values into a string
func stringConcat(args ...interface{}) (string, error) <span class="cov8" title="1">{
        var result strings.Builder
        for _, arg := range args </span><span class="cov8" title="1">{
                str := toString(arg)
                result.WriteString(str)
        }</span>
        <span class="cov8" title="1">return result.String(), nil</span>
}

// stringSubstr extracts a substring
func stringSubstr(s string, start int, length int) (string, error) <span class="cov8" title="1">{
        if start &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("start index cannot be negative")
        }</span>
        <span class="cov8" title="1">if length &lt; 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("length cannot be negative")
        }</span>

        <span class="cov8" title="1">if start &gt;= len(s) </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">end := start + length
        if end &gt; len(s) </span><span class="cov8" title="1">{
                end = len(s)
        }</span>

        <span class="cov8" title="1">return s[start:end], nil</span>
}

// Date Functions

// dateNow returns the current time
func dateNow() (interface{}, error) <span class="cov8" title="1">{
        return time.Now(), nil
}</span>

// dateFormat formats a time value using the given layout
func dateFormat(t time.Time, layout string) (string, error) <span class="cov8" title="1">{
        return t.Format(layout), nil
}</span>

// dateParse parses a time string using the given layout
func dateParse(value string, layout string) (interface{}, error) <span class="cov8" title="1">{
        t, err := time.Parse(layout, value)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse time: %w", err)
        }</span>
        <span class="cov8" title="1">return t, nil</span>
}

// dateAddDays adds or subtracts days from a time value
func dateAddDays(t time.Time, days int) (interface{}, error) <span class="cov8" title="1">{
        return t.AddDate(0, 0, days), nil
}</span>

// Math Functions

// mathRound rounds to the nearest integer
func mathRound(x float64) (float64, error) <span class="cov8" title="1">{
        return math.Round(x), nil
}</span>

// mathCeil rounds up to the nearest integer
func mathCeil(x float64) (float64, error) <span class="cov8" title="1">{
        return math.Ceil(x), nil
}</span>

// mathFloor rounds down to the nearest integer
func mathFloor(x float64) (float64, error) <span class="cov8" title="1">{
        return math.Floor(x), nil
}</span>

// mathAbs returns the absolute value
func mathAbs(x float64) (float64, error) <span class="cov8" title="1">{
        return math.Abs(x), nil
}</span>

// mathMin returns the minimum value from the arguments
func mathMin(args ...interface{}) (float64, error) <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("min requires at least one argument")
        }</span>

        <span class="cov8" title="1">min, err := toFloat(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid argument type: %w", err)
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                val, err := toFloat(args[i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid argument type at position %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">if val &lt; min </span><span class="cov8" title="1">{
                        min = val
                }</span>
        }

        <span class="cov8" title="1">return min, nil</span>
}

// mathMax returns the maximum value from the arguments
func mathMax(args ...interface{}) (float64, error) <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("max requires at least one argument")
        }</span>

        <span class="cov8" title="1">max, err := toFloat(args[0])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid argument type: %w", err)
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                val, err := toFloat(args[i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid argument type at position %d: %w", i, err)
                }</span>
                <span class="cov8" title="1">if val &gt; max </span><span class="cov8" title="1">{
                        max = val
                }</span>
        }

        <span class="cov8" title="1">return max, nil</span>
}

// Array Functions

// arrayLength returns the length of an array
func arrayLength(arr interface{}) (int, error) <span class="cov8" title="1">{
        switch v := arr.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                return len(v), nil</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("argument must be an array, got %T", arr)</span>
        }
}

// lenFunc returns the length of an array or string
func lenFunc(v interface{}) (int, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                return len(val), nil</span>
        case string:<span class="cov8" title="1">
                return len(val), nil</span>
        case []string:<span class="cov0" title="0">
                return len(val), nil</span>
        case []int:<span class="cov0" title="0">
                return len(val), nil</span>
        case []float64:<span class="cov0" title="0">
                return len(val), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("len() requires an array or string, got %T", v)</span>
        }
}

// Helper Functions

// toString converts various types to string
func toString(v interface{}) string <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                return val</span>
        case int:<span class="cov8" title="1">
                return strconv.Itoa(val)</span>
        case int64:<span class="cov0" title="0">
                return strconv.FormatInt(val, 10)</span>
        case float64:<span class="cov8" title="1">
                return strconv.FormatFloat(val, 'f', -1, 64)</span>
        case bool:<span class="cov8" title="1">
                return strconv.FormatBool(val)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val)</span>
        }
}

// toFloat converts various types to float64
func toFloat(v interface{}) (float64, error) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case float64:<span class="cov8" title="1">
                return val, nil</span>
        case float32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case int:<span class="cov8" title="1">
                return float64(val), nil</span>
        case int64:<span class="cov8" title="1">
                return float64(val), nil</span>
        case int32:<span class="cov0" title="0">
                return float64(val), nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseFloat(val, 64)</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("cannot convert %T to float64", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package workflow

import (
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "time"
)

// Workflow represents a workflow definition
type Workflow struct {
        ID          string          `db:"id" json:"id"`
        TenantID    string          `db:"tenant_id" json:"tenant_id"`
        Name        string          `db:"name" json:"name"`
        Description string          `db:"description" json:"description"`
        Definition  json.RawMessage `db:"definition" json:"definition"`
        Status      string          `db:"status" json:"status"`
        Version     int             `db:"version" json:"version"`
        CreatedBy   string          `db:"created_by" json:"created_by"`
        CreatedAt   time.Time       `db:"created_at" json:"created_at"`
        UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
}

// WorkflowDefinition represents the full workflow structure
type WorkflowDefinition struct {
        Nodes []Node `json:"nodes"`
        Edges []Edge `json:"edges"`
}

// Node represents a node in the workflow
type NodeData struct {
        Name   string          `json:"name"`
        Config json.RawMessage `json:"config"`
}

type Node struct {
        ID       string          `json:"id"`
        Type     string          `json:"type"`
        Position Position        `json:"position"`
        Data     NodeData        `json:"data"`
        // Config is extracted from Data.Config for backward compatibility
        Config json.RawMessage `json:"-"`
}

// Position represents node position on the canvas
type Position struct {
        X float64 `json:"x"`
        Y float64 `json:"y"`
}

// Edge represents a connection between nodes
type Edge struct {
        ID       string `json:"id"`
        Source   string `json:"source"`
        Target   string `json:"target"`
        SourceID string `json:"sourceHandle,omitempty"`
        TargetID string `json:"targetHandle,omitempty"`
        Label    string `json:"label,omitempty"` // Used for conditional branches: "true" or "false"
}

// NodeType represents the type of a node
type NodeType string

const (
        NodeTypeTriggerWebhook        NodeType = "trigger:webhook"
        NodeTypeTriggerSchedule       NodeType = "trigger:schedule"
        NodeTypeActionHTTP            NodeType = "action:http"
        NodeTypeActionTransform       NodeType = "action:transform"
        NodeTypeActionFormula         NodeType = "action:formula"
        NodeTypeActionCode            NodeType = "action:code"
        NodeTypeActionEmail           NodeType = "action:email"
        NodeTypeActionSlackSendMessage NodeType = "slack:send_message"
        NodeTypeActionSlackSendDM      NodeType = "slack:send_dm"
        NodeTypeActionSlackUpdateMessage NodeType = "slack:update_message"
        NodeTypeActionSlackAddReaction NodeType = "slack:add_reaction"
        NodeTypeControlIf             NodeType = "control:if"
        NodeTypeControlLoop           NodeType = "control:loop"
        NodeTypeControlParallel       NodeType = "control:parallel"
)

// HTTPActionConfig represents HTTP action configuration
type HTTPActionConfig struct {
        Method  string            `json:"method"`
        URL     string            `json:"url"`
        Headers map[string]string `json:"headers,omitempty"`
        Body    json.RawMessage   `json:"body,omitempty"`
        Timeout int               `json:"timeout,omitempty"`
}

// TransformActionConfig represents transform action configuration
type TransformActionConfig struct {
        Expression string            `json:"expression"`
        Mapping    map[string]string `json:"mapping,omitempty"`
}

// FormulaActionConfig represents formula action configuration
type FormulaActionConfig struct {
        Expression     string `json:"expression"`
        OutputVariable string `json:"output_variable,omitempty"`
}

// ScriptActionConfig represents script (JavaScript) action configuration
type ScriptActionConfig struct {
        Script      string `json:"script"`                 // JavaScript code to execute
        Timeout     int    `json:"timeout,omitempty"`      // Max execution time in seconds (default: 30)
        MemoryLimit int    `json:"memory_limit,omitempty"` // Max memory in MB (future enhancement)
}

// WebhookTriggerConfig represents webhook trigger configuration
type WebhookTriggerConfig struct {
        Path        string `json:"path,omitempty"`
        AuthType    string `json:"auth_type,omitempty"` // none, basic, signature, api_key
        Secret      string `json:"secret,omitempty"`
        AllowedIPs  string `json:"allowed_ips,omitempty"`
        ResponseURL string `json:"response_url,omitempty"`
}

// ScheduleTriggerConfig represents schedule trigger configuration
type ScheduleTriggerConfig struct {
        Cron     string `json:"cron"`
        Timezone string `json:"timezone,omitempty"`
}

// ConditionalActionConfig represents conditional (if/else) action configuration
type ConditionalActionConfig struct {
        Condition     string `json:"condition"`                 // Boolean expression to evaluate
        TrueBranch    string `json:"true_branch,omitempty"`     // Edge ID or label for true branch
        FalseBranch   string `json:"false_branch,omitempty"`    // Edge ID or label for false branch
        Description   string `json:"description,omitempty"`     // Optional description of the condition
        StopOnTrue    bool   `json:"stop_on_true,omitempty"`    // Stop workflow if condition is true
        StopOnFalse   bool   `json:"stop_on_false,omitempty"`   // Stop workflow if condition is false
}

// LoopActionConfig represents loop (for-each) action configuration
type LoopActionConfig struct {
        Source        string `json:"source"`                    // JSONPath to array (e.g., ${steps.node1.output.items})
        ItemVariable  string `json:"item_variable"`             // Variable name for current item (e.g., "item")
        IndexVariable string `json:"index_variable,omitempty"`  // Variable name for current index (e.g., "index")
        MaxIterations int    `json:"max_iterations,omitempty"`  // Safety limit (default 1000)
        OnError       string `json:"on_error,omitempty"`        // "continue" or "stop" (default "stop")
}

// CreateWorkflowInput represents input for creating a workflow
type CreateWorkflowInput struct {
        Name        string          `json:"name" validate:"required,min=1,max=255"`
        Description string          `json:"description"`
        Definition  json.RawMessage `json:"definition" validate:"required"`
}

// UpdateWorkflowInput represents input for updating a workflow
type UpdateWorkflowInput struct {
        Name        string          `json:"name,omitempty"`
        Description string          `json:"description,omitempty"`
        Definition  json.RawMessage `json:"definition,omitempty"`
        Status      string          `json:"status,omitempty"`
}

// WorkflowStatus represents workflow status
type WorkflowStatus string

const (
        WorkflowStatusDraft    WorkflowStatus = "draft"
        WorkflowStatusActive   WorkflowStatus = "active"
        WorkflowStatusInactive WorkflowStatus = "inactive"
        WorkflowStatusArchived WorkflowStatus = "archived"
)

// Execution represents a workflow execution
type Execution struct {
        ID              string           `db:"id" json:"id"`
        TenantID        string           `db:"tenant_id" json:"tenant_id"`
        WorkflowID      string           `db:"workflow_id" json:"workflow_id"`
        WorkflowVersion int              `db:"workflow_version" json:"workflow_version"`
        Status          string           `db:"status" json:"status"`
        TriggerType     string           `db:"trigger_type" json:"trigger_type"`
        TriggerData     *json.RawMessage `db:"trigger_data" json:"trigger_data,omitempty"`
        OutputData      *json.RawMessage `db:"output_data" json:"output_data,omitempty"`
        ErrorMessage    *string          `db:"error_message" json:"error_message,omitempty"`
        StartedAt       *time.Time       `db:"started_at" json:"started_at,omitempty"`
        CompletedAt     *time.Time       `db:"completed_at" json:"completed_at,omitempty"`
        CreatedAt       time.Time        `db:"created_at" json:"created_at"`
}

// StepExecution represents a single step in an execution
type StepExecution struct {
        ID           string           `db:"id" json:"id"`
        ExecutionID  string           `db:"execution_id" json:"execution_id"`
        NodeID       string           `db:"node_id" json:"node_id"`
        NodeType     string           `db:"node_type" json:"node_type"`
        Status       string           `db:"status" json:"status"`
        InputData    *json.RawMessage `db:"input_data" json:"input_data,omitempty"`
        OutputData   *json.RawMessage `db:"output_data" json:"output_data,omitempty"`
        ErrorMessage *string          `db:"error_message" json:"error_message,omitempty"`
        RetryCount   int              `db:"retry_count" json:"retry_count"`
        StartedAt    *time.Time       `db:"started_at" json:"started_at,omitempty"`
        CompletedAt  *time.Time       `db:"completed_at" json:"completed_at,omitempty"`
        DurationMs   *int             `db:"duration_ms" json:"duration_ms,omitempty"`
}

// ExecutionStatus represents execution status
type ExecutionStatus string

const (
        ExecutionStatusPending   ExecutionStatus = "pending"
        ExecutionStatusRunning   ExecutionStatus = "running"
        ExecutionStatusCompleted ExecutionStatus = "completed"
        ExecutionStatusFailed    ExecutionStatus = "failed"
        ExecutionStatusCancelled ExecutionStatus = "cancelled"
)

// ExecutionFilter represents filters for listing executions
type ExecutionFilter struct {
        WorkflowID  string     `json:"workflow_id,omitempty"`
        Status      string     `json:"status,omitempty"`
        TriggerType string     `json:"trigger_type,omitempty"`
        StartDate   *time.Time `json:"start_date,omitempty"`
        EndDate     *time.Time `json:"end_date,omitempty"`
}

// Validate validates the execution filter
func (f ExecutionFilter) Validate() error <span class="cov8" title="1">{
        if f.StartDate != nil &amp;&amp; f.EndDate != nil </span><span class="cov8" title="1">{
                if f.EndDate.Before(*f.StartDate) </span><span class="cov8" title="1">{
                        return errors.New("end_date must be after start_date")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// PaginationCursor represents a cursor for pagination
type PaginationCursor struct {
        CreatedAt time.Time `json:"created_at"`
        ID        string    `json:"id"`
}

// Encode encodes the cursor to a base64 string
func (c PaginationCursor) Encode() string <span class="cov8" title="1">{
        data, err := json.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return base64.URLEncoding.EncodeToString(data)</span>
}

// DecodePaginationCursor decodes a base64 cursor string
func DecodePaginationCursor(encoded string) (PaginationCursor, error) <span class="cov8" title="1">{
        if encoded == "" </span><span class="cov8" title="1">{
                return PaginationCursor{}, errors.New("empty cursor")
        }</span>

        <span class="cov8" title="1">data, err := base64.URLEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov8" title="1">{
                return PaginationCursor{}, fmt.Errorf("invalid cursor encoding: %w", err)
        }</span>

        <span class="cov8" title="1">var cursor PaginationCursor
        if err := json.Unmarshal(data, &amp;cursor); err != nil </span><span class="cov8" title="1">{
                return PaginationCursor{}, fmt.Errorf("invalid cursor format: %w", err)
        }</span>

        <span class="cov8" title="1">return cursor, nil</span>
}

// ExecutionListResult represents a paginated list of executions
type ExecutionListResult struct {
        Data       []*Execution `json:"data"`
        Cursor     string       `json:"cursor,omitempty"`
        HasMore    bool         `json:"has_more"`
        TotalCount int          `json:"total_count"`
}

// ExecutionWithSteps represents an execution with its step executions
type ExecutionWithSteps struct {
        Execution *Execution       `json:"execution"`
        Steps     []*StepExecution `json:"steps"`
}

// ExecutionStats represents statistics about executions
type ExecutionStats struct {
        TotalCount   int            `json:"total_count"`
        StatusCounts map[string]int `json:"status_counts"`
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package workflow

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

var (
        ErrNotFound = errors.New("workflow not found")
)

// Repository handles workflow database operations
type Repository struct {
        db *sqlx.DB
}

// NewRepository creates a new workflow repository
func NewRepository(db *sqlx.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{db: db}
}</span>

// setTenantContext sets the tenant ID in the PostgreSQL session for RLS
func (r *Repository) setTenantContext(ctx context.Context, tenantID string) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx, "SET LOCAL app.current_tenant_id = $1", tenantID)
        return err
}</span>

// Create inserts a new workflow
func (r *Repository) Create(ctx context.Context, tenantID, createdBy string, input CreateWorkflowInput) (*Workflow, error) <span class="cov0" title="0">{
        id := uuid.New().String()
        now := time.Now()

        query := `
                INSERT INTO workflows (id, tenant_id, name, description, definition, status, version, created_by, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING *
        `

        var workflow Workflow
        err := r.db.QueryRowxContext(
                ctx, query,
                id, tenantID, input.Name, input.Description, input.Definition, "draft", 1, createdBy, now, now,
        ).StructScan(&amp;workflow)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;workflow, nil</span>
}

// GetByID retrieves a workflow by ID (tenant-scoped)
func (r *Repository) GetByID(ctx context.Context, tenantID, id string) (*Workflow, error) <span class="cov0" title="0">{
        query := `SELECT * FROM workflows WHERE id = $1 AND tenant_id = $2`

        var workflow Workflow
        err := r.db.GetContext(ctx, &amp;workflow, query, id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;workflow, nil</span>
}

// Update updates a workflow
func (r *Repository) Update(ctx context.Context, tenantID, id string, input UpdateWorkflowInput) (*Workflow, error) <span class="cov0" title="0">{
        // First get the current workflow to increment version if definition changed
        current, err := r.GetByID(ctx, tenantID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">newVersion := current.Version
        if input.Definition != nil </span><span class="cov0" title="0">{
                newVersion++
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE workflows
                SET name = COALESCE(NULLIF($3, ''), name),
                    description = COALESCE(NULLIF($4, ''), description),
                    definition = COALESCE($5, definition),
                    status = COALESCE(NULLIF($6, ''), status),
                    version = $7,
                    updated_at = $8
                WHERE id = $1 AND tenant_id = $2
                RETURNING *
        `

        var workflow Workflow
        err = r.db.QueryRowxContext(
                ctx, query,
                id, tenantID, input.Name, input.Description, input.Definition, input.Status, newVersion, time.Now(),
        ).StructScan(&amp;workflow)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;workflow, nil</span>
}

// Delete deletes a workflow (soft delete by setting status to 'archived')
func (r *Repository) Delete(ctx context.Context, tenantID, id string) error <span class="cov0" title="0">{
        query := `UPDATE workflows SET status = 'archived', updated_at = $3 WHERE id = $1 AND tenant_id = $2`

        result, err := r.db.ExecContext(ctx, query, id, tenantID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// List retrieves all workflows for a tenant with pagination
func (r *Repository) List(ctx context.Context, tenantID string, limit, offset int) ([]*Workflow, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM workflows
                WHERE tenant_id = $1 AND status != 'archived'
                ORDER BY updated_at DESC
                LIMIT $2 OFFSET $3
        `

        var workflows []*Workflow
        err := r.db.SelectContext(ctx, &amp;workflows, query, tenantID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return workflows, nil</span>
}

// Count returns the total number of workflows for a tenant
func (r *Repository) Count(ctx context.Context, tenantID string) (int, error) <span class="cov0" title="0">{
        query := `SELECT COUNT(*) FROM workflows WHERE tenant_id = $1 AND status != 'archived'`

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// CreateExecution creates a new execution record
func (r *Repository) CreateExecution(ctx context.Context, tenantID, workflowID string, workflowVersion int, triggerType string, triggerData []byte) (*Execution, error) <span class="cov0" title="0">{
        id := uuid.New().String()
        now := time.Now()

        // Handle nil or empty trigger data
        var triggerDataParam interface{}
        if len(triggerData) == 0 </span><span class="cov0" title="0">{
                triggerDataParam = nil
        }</span> else<span class="cov0" title="0"> {
                triggerDataParam = triggerData
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO executions (id, tenant_id, workflow_id, workflow_version, status, trigger_type, trigger_data, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING *
        `

        var execution Execution
        err := r.db.QueryRowxContext(
                ctx, query,
                id, tenantID, workflowID, workflowVersion, "pending", triggerType, triggerDataParam, now,
        ).StructScan(&amp;execution)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;execution, nil</span>
}

// GetExecutionByID retrieves an execution by ID
func (r *Repository) GetExecutionByID(ctx context.Context, tenantID, id string) (*Execution, error) <span class="cov0" title="0">{
        query := `SELECT * FROM executions WHERE id = $1 AND tenant_id = $2`

        var execution Execution
        err := r.db.GetContext(ctx, &amp;execution, query, id, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;execution, nil</span>
}

// UpdateExecutionStatus updates an execution's status
func (r *Repository) UpdateExecutionStatus(ctx context.Context, id string, status ExecutionStatus, outputData []byte, errorMessage *string) error <span class="cov0" title="0">{
        now := time.Now()

        var startedAt, completedAt *time.Time
        if status == ExecutionStatusRunning </span><span class="cov0" title="0">{
                startedAt = &amp;now
        }</span>
        <span class="cov0" title="0">if status == ExecutionStatusCompleted || status == ExecutionStatusFailed || status == ExecutionStatusCancelled </span><span class="cov0" title="0">{
                completedAt = &amp;now
        }</span>

        // Handle nil or empty output data
        <span class="cov0" title="0">var outputDataParam interface{}
        if len(outputData) == 0 </span><span class="cov0" title="0">{
                outputDataParam = nil
        }</span> else<span class="cov0" title="0"> {
                outputDataParam = outputData
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE executions
                SET status = $2,
                    output_data = COALESCE($3, output_data),
                    error_message = COALESCE($4, error_message),
                    started_at = COALESCE($5, started_at),
                    completed_at = COALESCE($6, completed_at)
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, id, status, outputDataParam, errorMessage, startedAt, completedAt)
        return err</span>
}

// ListExecutions retrieves executions for a tenant with pagination
func (r *Repository) ListExecutions(ctx context.Context, tenantID string, workflowID string, limit, offset int) ([]*Execution, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        if workflowID != "" </span><span class="cov0" title="0">{
                query = `
                        SELECT * FROM executions
                        WHERE tenant_id = $1 AND workflow_id = $2
                        ORDER BY created_at DESC
                        LIMIT $3 OFFSET $4
                `
                args = []interface{}{tenantID, workflowID, limit, offset}
        }</span> else<span class="cov0" title="0"> {
                query = `
                        SELECT * FROM executions
                        WHERE tenant_id = $1
                        ORDER BY created_at DESC
                        LIMIT $2 OFFSET $3
                `
                args = []interface{}{tenantID, limit, offset}
        }</span>

        <span class="cov0" title="0">var executions []*Execution
        err := r.db.SelectContext(ctx, &amp;executions, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return executions, nil</span>
}

// CreateStepExecution creates a new step execution record
func (r *Repository) CreateStepExecution(ctx context.Context, executionID, nodeID, nodeType string, inputData []byte) (*StepExecution, error) <span class="cov0" title="0">{
        id := uuid.New().String()
        now := time.Now()

        query := `
                INSERT INTO step_executions (id, execution_id, node_id, node_type, status, input_data, started_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING *
        `

        // Handle nil or empty input data
        var inputDataParam interface{}
        if len(inputData) == 0 </span><span class="cov0" title="0">{
                inputDataParam = nil
        }</span> else<span class="cov0" title="0"> {
                inputDataParam = inputData
        }</span>

        <span class="cov0" title="0">var stepExecution StepExecution
        err := r.db.QueryRowxContext(
                ctx, query,
                id, executionID, nodeID, nodeType, "running", inputDataParam, now,
        ).StructScan(&amp;stepExecution)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;stepExecution, nil</span>
}

// UpdateStepExecution updates a step execution with results
func (r *Repository) UpdateStepExecution(ctx context.Context, id, status string, outputData []byte, errorMessage *string) error <span class="cov0" title="0">{
        now := time.Now()

        // Handle nil or empty output data
        var outputDataParam interface{}
        if len(outputData) == 0 </span><span class="cov0" title="0">{
                outputDataParam = nil
        }</span> else<span class="cov0" title="0"> {
                outputDataParam = outputData
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE step_executions
                SET status = $2,
                    output_data = COALESCE($3, output_data),
                    error_message = COALESCE($4, error_message),
                    completed_at = $5,
                    duration_ms = EXTRACT(EPOCH FROM ($5 - started_at)) * 1000
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, id, status, outputDataParam, errorMessage, now)
        return err</span>
}

// GetStepExecutionsByExecutionID retrieves all step executions for an execution
func (r *Repository) GetStepExecutionsByExecutionID(ctx context.Context, executionID string) ([]*StepExecution, error) <span class="cov0" title="0">{
        query := `
                SELECT * FROM step_executions
                WHERE execution_id = $1
                ORDER BY started_at ASC
        `

        var stepExecutions []*StepExecution
        err := r.db.SelectContext(ctx, &amp;stepExecutions, query, executionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return stepExecutions, nil</span>
}

// buildExecutionFilterQuery builds the WHERE clause for execution filters
func (r *Repository) buildExecutionFilterQuery(filter ExecutionFilter, args []interface{}, argIndex int) (string, []interface{}) <span class="cov0" title="0">{
        var conditions []string

        if filter.WorkflowID != "" </span><span class="cov0" title="0">{
                argIndex++
                conditions = append(conditions, fmt.Sprintf("workflow_id = $%d", argIndex))
                args = append(args, filter.WorkflowID)
        }</span>

        <span class="cov0" title="0">if filter.Status != "" </span><span class="cov0" title="0">{
                argIndex++
                conditions = append(conditions, fmt.Sprintf("status = $%d", argIndex))
                args = append(args, filter.Status)
        }</span>

        <span class="cov0" title="0">if filter.TriggerType != "" </span><span class="cov0" title="0">{
                argIndex++
                conditions = append(conditions, fmt.Sprintf("trigger_type = $%d", argIndex))
                args = append(args, filter.TriggerType)
        }</span>

        <span class="cov0" title="0">if filter.StartDate != nil </span><span class="cov0" title="0">{
                argIndex++
                conditions = append(conditions, fmt.Sprintf("created_at &gt;= $%d", argIndex))
                args = append(args, filter.StartDate)
        }</span>

        <span class="cov0" title="0">if filter.EndDate != nil </span><span class="cov0" title="0">{
                argIndex++
                conditions = append(conditions, fmt.Sprintf("created_at &lt;= $%d", argIndex))
                args = append(args, filter.EndDate)
        }</span>

        <span class="cov0" title="0">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                whereClause = " AND " + joinConditions(conditions)
        }</span>

        <span class="cov0" title="0">return whereClause, args</span>
}

// joinConditions joins SQL conditions with AND
func joinConditions(conditions []string) string <span class="cov0" title="0">{
        result := ""
        for i, cond := range conditions </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += " AND "
                }</span>
                <span class="cov0" title="0">result += cond</span>
        }
        <span class="cov0" title="0">return result</span>
}

// ListExecutionsAdvanced retrieves executions with advanced filtering and cursor-based pagination
func (r *Repository) ListExecutionsAdvanced(ctx context.Context, tenantID string, filter ExecutionFilter, cursor string, limit int) (*ExecutionListResult, error) <span class="cov0" title="0">{
        if err := filter.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid filter: %w", err)
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        // Decode cursor if provided
        <span class="cov0" title="0">var cursorData PaginationCursor
        if cursor != "" </span><span class="cov0" title="0">{
                decoded, err := DecodePaginationCursor(cursor)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cursor: %w", err)
                }</span>
                <span class="cov0" title="0">cursorData = decoded</span>
        }

        // Build query
        <span class="cov0" title="0">args := []interface{}{tenantID}
        argIndex := 1

        // Add cursor conditions
        cursorCondition := ""
        if cursor != "" </span><span class="cov0" title="0">{
                argIndex++
                args = append(args, cursorData.CreatedAt)
                argIndex++
                args = append(args, cursorData.ID)
                cursorCondition = fmt.Sprintf(" AND (created_at &lt; $%d OR (created_at = $%d AND id &lt; $%d))", argIndex-1, argIndex-1, argIndex)
        }</span>

        // Add filter conditions
        <span class="cov0" title="0">filterConditions, args := r.buildExecutionFilterQuery(filter, args, argIndex)

        query := fmt.Sprintf(`
                SELECT * FROM executions
                WHERE tenant_id = $1%s%s
                ORDER BY created_at DESC, id DESC
                LIMIT %d
        `, cursorCondition, filterConditions, limit+1) // Fetch one extra to check if there are more

        var executions []*Execution
        err := r.db.SelectContext(ctx, &amp;executions, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list executions: %w", err)
        }</span>

        // Check if there are more results
        <span class="cov0" title="0">hasMore := len(executions) &gt; limit
        if hasMore </span><span class="cov0" title="0">{
                executions = executions[:limit]
        }</span>

        // Generate cursor for next page
        <span class="cov0" title="0">var nextCursor string
        if hasMore &amp;&amp; len(executions) &gt; 0 </span><span class="cov0" title="0">{
                lastExec := executions[len(executions)-1]
                cursorData := PaginationCursor{
                        CreatedAt: lastExec.CreatedAt,
                        ID:        lastExec.ID,
                }
                nextCursor = cursorData.Encode()
        }</span>

        // Get total count
        <span class="cov0" title="0">totalCount, err := r.CountExecutions(ctx, tenantID, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count executions: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ExecutionListResult{
                Data:       executions,
                Cursor:     nextCursor,
                HasMore:    hasMore,
                TotalCount: totalCount,
        }, nil</span>
}

// GetExecutionWithSteps retrieves an execution with all its step executions
func (r *Repository) GetExecutionWithSteps(ctx context.Context, tenantID, executionID string) (*ExecutionWithSteps, error) <span class="cov0" title="0">{
        execution, err := r.GetExecutionByID(ctx, tenantID, executionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get execution: %w", err)
        }</span>

        <span class="cov0" title="0">steps, err := r.GetStepExecutionsByExecutionID(ctx, executionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get step executions: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ExecutionWithSteps{
                Execution: execution,
                Steps:     steps,
        }, nil</span>
}

// CountExecutions returns the total count of executions matching the filter
func (r *Repository) CountExecutions(ctx context.Context, tenantID string, filter ExecutionFilter) (int, error) <span class="cov0" title="0">{
        if err := filter.Validate(); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid filter: %w", err)
        }</span>

        <span class="cov0" title="0">args := []interface{}{tenantID}
        filterConditions, args := r.buildExecutionFilterQuery(filter, args, 1)

        query := fmt.Sprintf(`
                SELECT COUNT(*) FROM executions
                WHERE tenant_id = $1%s
        `, filterConditions)

        var count int
        err := r.db.GetContext(ctx, &amp;count, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("count executions: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package workflow

import (
        "context"
        "encoding/json"
        "log/slog"
)

// WorkflowExecutor interface to avoid circular dependencies
type WorkflowExecutor interface {
        Execute(ctx context.Context, execution *Execution) error
}

// QueuePublisher interface for publishing execution messages
type QueuePublisher interface {
        PublishExecution(ctx context.Context, msg interface{}) error
}

// RepositoryInterface defines the repository methods used by Service
type RepositoryInterface interface {
        Create(ctx context.Context, tenantID, createdBy string, input CreateWorkflowInput) (*Workflow, error)
        GetByID(ctx context.Context, tenantID, id string) (*Workflow, error)
        Update(ctx context.Context, tenantID, id string, input UpdateWorkflowInput) (*Workflow, error)
        Delete(ctx context.Context, tenantID, id string) error
        List(ctx context.Context, tenantID string, limit, offset int) ([]*Workflow, error)
        CreateExecution(ctx context.Context, tenantID, workflowID string, workflowVersion int, triggerType string, triggerData []byte) (*Execution, error)
        GetExecutionByID(ctx context.Context, tenantID, id string) (*Execution, error)
        GetStepExecutionsByExecutionID(ctx context.Context, executionID string) ([]*StepExecution, error)
        ListExecutions(ctx context.Context, tenantID string, workflowID string, limit, offset int) ([]*Execution, error)
        ListExecutionsAdvanced(ctx context.Context, tenantID string, filter ExecutionFilter, cursor string, limit int) (*ExecutionListResult, error)
        GetExecutionWithSteps(ctx context.Context, tenantID, executionID string) (*ExecutionWithSteps, error)
        CountExecutions(ctx context.Context, tenantID string, filter ExecutionFilter) (int, error)
}

// Service handles workflow business logic
type Service struct {
        repo           RepositoryInterface
        executor       WorkflowExecutor
        webhookService WebhookService
        queuePublisher QueuePublisher
        logger         *slog.Logger
}

// NewService creates a new workflow service
func NewService(repo *Repository, logger *slog.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                repo:   repo,
                logger: logger,
        }
}</span>

// SetExecutor sets the workflow executor (called after initialization to avoid import cycles)
func (s *Service) SetExecutor(executor WorkflowExecutor) <span class="cov0" title="0">{
        s.executor = executor
}</span>

// SetWebhookService sets the webhook service (called after both services are created)
func (s *Service) SetWebhookService(webhookService WebhookService) <span class="cov0" title="0">{
        s.webhookService = webhookService
}</span>

// SetQueuePublisher sets the queue publisher (optional, for queue-based execution)
func (s *Service) SetQueuePublisher(publisher QueuePublisher) <span class="cov0" title="0">{
        s.queuePublisher = publisher
}</span>

// Create creates a new workflow
func (s *Service) Create(ctx context.Context, tenantID, userID string, input CreateWorkflowInput) (*Workflow, error) <span class="cov0" title="0">{
        // Validate definition structure
        if err := s.validateDefinition(input.Definition); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">workflow, err := s.repo.Create(ctx, tenantID, userID, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create workflow", "error", err, "tenant_id", tenantID)
                return nil, err
        }</span>

        // Sync webhooks if webhook service is available
        <span class="cov0" title="0">if s.webhookService != nil </span><span class="cov0" title="0">{
                webhookNodes := s.extractWebhookNodes(input.Definition)
                if len(webhookNodes) &gt; 0 </span><span class="cov0" title="0">{
                        if err := s.webhookService.SyncWorkflowWebhooks(ctx, tenantID, workflow.ID, webhookNodes); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("failed to sync webhooks", "error", err, "workflow_id", workflow.ID)
                                // Don't fail the workflow creation if webhook sync fails
                        }</span>
                }
        }

        <span class="cov0" title="0">s.logger.Info("workflow created", "workflow_id", workflow.ID, "tenant_id", tenantID)
        return workflow, nil</span>
}

// GetByID retrieves a workflow by ID
func (s *Service) GetByID(ctx context.Context, tenantID, id string) (*Workflow, error) <span class="cov0" title="0">{
        return s.repo.GetByID(ctx, tenantID, id)
}</span>

// Update updates a workflow
func (s *Service) Update(ctx context.Context, tenantID, id string, input UpdateWorkflowInput) (*Workflow, error) <span class="cov0" title="0">{
        // Validate definition if provided
        if input.Definition != nil </span><span class="cov0" title="0">{
                if err := s.validateDefinition(input.Definition); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">workflow, err := s.repo.Update(ctx, tenantID, id, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update workflow", "error", err, "workflow_id", id)
                return nil, err
        }</span>

        // Sync webhooks if definition was updated and webhook service is available
        <span class="cov0" title="0">if input.Definition != nil &amp;&amp; s.webhookService != nil </span><span class="cov0" title="0">{
                webhookNodes := s.extractWebhookNodes(input.Definition)
                if err := s.webhookService.SyncWorkflowWebhooks(ctx, tenantID, workflow.ID, webhookNodes); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to sync webhooks", "error", err, "workflow_id", workflow.ID)
                        // Don't fail the workflow update if webhook sync fails
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("workflow updated", "workflow_id", workflow.ID, "version", workflow.Version)
        return workflow, nil</span>
}

// Delete deletes a workflow
func (s *Service) Delete(ctx context.Context, tenantID, id string) error <span class="cov0" title="0">{
        // Delete associated webhooks first if webhook service is available
        if s.webhookService != nil </span><span class="cov0" title="0">{
                if err := s.webhookService.DeleteByWorkflowID(ctx, id); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to delete webhooks", "error", err, "workflow_id", id)
                        // Continue with workflow deletion even if webhook deletion fails
                }</span>
        }

        <span class="cov0" title="0">err := s.repo.Delete(ctx, tenantID, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete workflow", "error", err, "workflow_id", id)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("workflow deleted", "workflow_id", id)
        return nil</span>
}

// List retrieves all workflows for a tenant
func (s *Service) List(ctx context.Context, tenantID string, limit, offset int) ([]*Workflow, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.repo.List(ctx, tenantID, limit, offset)</span>
}

// Execute starts a workflow execution
func (s *Service) Execute(ctx context.Context, tenantID, workflowID, triggerType string, triggerData []byte) (*Execution, error) <span class="cov0" title="0">{
        // Get workflow
        workflow, err := s.repo.GetByID(ctx, tenantID, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get workflow", "error", err, "workflow_id", workflowID)
                return nil, err
        }</span>

        // Validate workflow is active
        <span class="cov0" title="0">if workflow.Status != string(WorkflowStatusActive) </span><span class="cov0" title="0">{
                s.logger.Warn("attempted to execute inactive workflow",
                        "workflow_id", workflowID,
                        "status", workflow.Status,
                )
                return nil, &amp;ValidationError{Message: "workflow must be active to execute"}
        }</span>

        // Create execution record
        <span class="cov0" title="0">execution, err := s.repo.CreateExecution(ctx, tenantID, workflowID, workflow.Version, triggerType, triggerData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create execution", "error", err, "workflow_id", workflowID)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("execution created", "execution_id", execution.ID, "workflow_id", workflowID)

        // If queue publisher is configured, publish to queue
        // Otherwise, execute in goroutine (backward compatibility)
        if s.queuePublisher != nil </span><span class="cov0" title="0">{
                // Import json for RawMessage
                var triggerDataPtr *[]byte
                if triggerData != nil </span><span class="cov0" title="0">{
                        data := []byte(triggerData)
                        triggerDataPtr = &amp;data
                }</span>

                // Create execution message for queue
                <span class="cov0" title="0">execMsg := map[string]interface{}{
                        "execution_id":     execution.ID,
                        "tenant_id":        tenantID,
                        "workflow_id":      workflowID,
                        "workflow_version": workflow.Version,
                        "trigger_type":     triggerType,
                }
                if triggerDataPtr != nil </span><span class="cov0" title="0">{
                        execMsg["trigger_data"] = *triggerDataPtr
                }</span>

                // Publish to queue
                <span class="cov0" title="0">if err := s.queuePublisher.PublishExecution(ctx, execMsg); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to publish execution to queue",
                                "error", err,
                                "execution_id", execution.ID,
                                "workflow_id", workflowID,
                        )
                        // Don't fail the request, fall back to goroutine execution
                        s.executeInGoroutine(execution, workflowID)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Info("execution published to queue", "execution_id", execution.ID, "workflow_id", workflowID)
                }</span>
        } else<span class="cov0" title="0"> {
                // Backward compatibility: execute in goroutine
                s.executeInGoroutine(execution, workflowID)
        }</span>

        <span class="cov0" title="0">return execution, nil</span>
}

// executeInGoroutine executes workflow in a goroutine (backward compatibility)
func (s *Service) executeInGoroutine(execution *Execution, workflowID string) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                // Create a new context for the execution to avoid cancellation
                execCtx := context.Background()

                if s.executor != nil </span><span class="cov0" title="0">{
                        if err := s.executor.Execute(execCtx, execution); err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("workflow execution failed",
                                        "error", err,
                                        "execution_id", execution.ID,
                                        "workflow_id", workflowID,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        s.logger.Warn("executor not set, execution will remain in pending state", "execution_id", execution.ID)
                }</span>
        }()
}

// ExecuteSync executes a workflow synchronously (useful for testing)
func (s *Service) ExecuteSync(ctx context.Context, tenantID, workflowID, triggerType string, triggerData []byte) (*Execution, error) <span class="cov0" title="0">{
        // Get workflow
        workflow, err := s.repo.GetByID(ctx, tenantID, workflowID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get workflow", "error", err, "workflow_id", workflowID)
                return nil, err
        }</span>

        // Validate workflow is active
        <span class="cov0" title="0">if workflow.Status != string(WorkflowStatusActive) </span><span class="cov0" title="0">{
                s.logger.Warn("attempted to execute inactive workflow",
                        "workflow_id", workflowID,
                        "status", workflow.Status,
                )
                return nil, &amp;ValidationError{Message: "workflow must be active to execute"}
        }</span>

        // Create execution record
        <span class="cov0" title="0">execution, err := s.repo.CreateExecution(ctx, tenantID, workflowID, workflow.Version, triggerType, triggerData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create execution", "error", err, "workflow_id", workflowID)
                return nil, err
        }</span>

        <span class="cov0" title="0">s.logger.Info("execution created", "execution_id", execution.ID, "workflow_id", workflowID)

        // Execute the workflow synchronously
        if s.executor == nil </span><span class="cov0" title="0">{
                err := &amp;ValidationError{Message: "executor not configured"}
                s.logger.Error("executor not set", "execution_id", execution.ID)
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.executor.Execute(ctx, execution); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("workflow execution failed",
                        "error", err,
                        "execution_id", execution.ID,
                        "workflow_id", workflowID,
                )
                return execution, err
        }</span>

        // Reload execution to get final state
        <span class="cov0" title="0">return s.repo.GetExecutionByID(ctx, tenantID, execution.ID)</span>
}

// GetExecution retrieves an execution by ID
func (s *Service) GetExecution(ctx context.Context, tenantID, executionID string) (*Execution, error) <span class="cov0" title="0">{
        return s.repo.GetExecutionByID(ctx, tenantID, executionID)
}</span>

// GetStepExecutions retrieves all step executions for an execution
func (s *Service) GetStepExecutions(ctx context.Context, executionID string) ([]*StepExecution, error) <span class="cov0" title="0">{
        return s.repo.GetStepExecutionsByExecutionID(ctx, executionID)
}</span>

// ListExecutions retrieves executions for a tenant
func (s *Service) ListExecutions(ctx context.Context, tenantID, workflowID string, limit, offset int) ([]*Execution, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">return s.repo.ListExecutions(ctx, tenantID, workflowID, limit, offset)</span>
}

// ListExecutionsAdvanced retrieves executions with advanced filtering and cursor-based pagination
func (s *Service) ListExecutionsAdvanced(ctx context.Context, tenantID string, filter ExecutionFilter, cursor string, limit int) (*ExecutionListResult, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 20
        }</span>
        <span class="cov8" title="1">if limit &gt; 100 </span><span class="cov8" title="1">{
                limit = 100
        }</span>

        <span class="cov8" title="1">if err := filter.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ValidationError{Message: "invalid filter: " + err.Error()}
        }</span>

        <span class="cov8" title="1">return s.repo.ListExecutionsAdvanced(ctx, tenantID, filter, cursor, limit)</span>
}

// GetExecutionWithSteps retrieves an execution with all its step executions
func (s *Service) GetExecutionWithSteps(ctx context.Context, tenantID, executionID string) (*ExecutionWithSteps, error) <span class="cov8" title="1">{
        return s.repo.GetExecutionWithSteps(ctx, tenantID, executionID)
}</span>

// GetExecutionStats retrieves execution statistics grouped by status
func (s *Service) GetExecutionStats(ctx context.Context, tenantID string, filter ExecutionFilter) (*ExecutionStats, error) <span class="cov8" title="1">{
        if err := filter.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;ValidationError{Message: "invalid filter: " + err.Error()}
        }</span>

        <span class="cov8" title="1">stats := &amp;ExecutionStats{
                StatusCounts: make(map[string]int),
        }

        statuses := []ExecutionStatus{
                ExecutionStatusPending,
                ExecutionStatusRunning,
                ExecutionStatusCompleted,
                ExecutionStatusFailed,
                ExecutionStatusCancelled,
        }

        for _, status := range statuses </span><span class="cov8" title="1">{
                statusFilter := filter
                statusFilter.Status = string(status)

                count, err := s.repo.CountExecutions(ctx, tenantID, statusFilter)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">stats.StatusCounts[string(status)] = count
                stats.TotalCount += count</span>
        }

        <span class="cov8" title="1">return stats, nil</span>
}

// validateDefinition validates a workflow definition
func (s *Service) validateDefinition(definition json.RawMessage) error <span class="cov0" title="0">{
        var def WorkflowDefinition
        if err := json.Unmarshal(definition, &amp;def); err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "invalid definition JSON: " + err.Error()}
        }</span>

        // Validate nodes exist
        <span class="cov0" title="0">if len(def.Nodes) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "workflow must have at least one node"}
        }</span>

        // Validate at least one trigger
        <span class="cov0" title="0">hasTrigger := false
        nodeIDs := make(map[string]bool)
        for _, node := range def.Nodes </span><span class="cov0" title="0">{
                nodeIDs[node.ID] = true
                if node.Type == string(NodeTypeTriggerWebhook) || node.Type == string(NodeTypeTriggerSchedule) </span><span class="cov0" title="0">{
                        hasTrigger = true
                }</span>
        }

        <span class="cov0" title="0">if !hasTrigger </span><span class="cov0" title="0">{
                return &amp;ValidationError{Message: "workflow must have at least one trigger"}
        }</span>

        // Validate edges reference existing nodes
        <span class="cov0" title="0">for _, edge := range def.Edges </span><span class="cov0" title="0">{
                if !nodeIDs[edge.Source] </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Message: "edge references non-existent source node: " + edge.Source}
                }</span>
                <span class="cov0" title="0">if !nodeIDs[edge.Target] </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Message: "edge references non-existent target node: " + edge.Target}
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// extractWebhookNodes extracts webhook trigger nodes from a workflow definition
func (s *Service) extractWebhookNodes(definition json.RawMessage) []WebhookNodeConfig <span class="cov0" title="0">{
        var def WorkflowDefinition
        if err := json.Unmarshal(definition, &amp;def); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var webhookNodes []WebhookNodeConfig
        for _, node := range def.Nodes </span><span class="cov0" title="0">{
                if node.Type == string(NodeTypeTriggerWebhook) </span><span class="cov0" title="0">{
                        // Parse config to get auth type
                        var config WebhookTriggerConfig
                        authType := AuthTypeSignature // Default
                        if node.Config != nil </span><span class="cov0" title="0">{
                                if err := json.Unmarshal(node.Config, &amp;config); err == nil </span><span class="cov0" title="0">{
                                        if config.AuthType != "" </span><span class="cov0" title="0">{
                                                authType = config.AuthType
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">webhookNodes = append(webhookNodes, WebhookNodeConfig{
                                NodeID:   node.ID,
                                AuthType: authType,
                        })</span>
                }
        }

        <span class="cov0" title="0">return webhookNodes</span>
}

// GetWebhooks retrieves all webhooks for a workflow
func (s *Service) GetWebhooks(ctx context.Context, workflowID string) ([]*WebhookInfo, error) <span class="cov0" title="0">{
        if s.webhookService == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return s.webhookService.GetByWorkflowID(ctx, workflowID)</span>
}

// ValidationError represents a validation error
type ValidationError struct {
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// AuthType constants
const (
        AuthTypeNone      = "none"
        AuthTypeSignature = "signature"
        AuthTypeBasic     = "basic"
        AuthTypeAPIKey    = "api_key"
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
