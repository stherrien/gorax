// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Execution struct {
		CompletedAt       func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		ErrorMessage      func(childComplexity int) int
		ExecutionDepth    func(childComplexity int) int
		ID                func(childComplexity int) int
		OutputData        func(childComplexity int) int
		ParentExecutionID func(childComplexity int) int
		StartedAt         func(childComplexity int) int
		Status            func(childComplexity int) int
		Steps             func(childComplexity int) int
		TenantID          func(childComplexity int) int
		TriggerData       func(childComplexity int) int
		TriggerType       func(childComplexity int) int
		Workflow          func(childComplexity int) int
		WorkflowID        func(childComplexity int) int
		WorkflowVersion   func(childComplexity int) int
	}

	ExecutionConnection struct {
		Cursor     func(childComplexity int) int
		Data       func(childComplexity int) int
		HasMore    func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	Mutation struct {
		CancelExecution         func(childComplexity int, id string) int
		CreateSchedule          func(childComplexity int, workflowID string, input CreateScheduleInput) int
		CreateTemplate          func(childComplexity int, input CreateTemplateInput) int
		CreateWebhook           func(childComplexity int, input CreateWebhookInput) int
		CreateWorkflow          func(childComplexity int, input CreateWorkflowInput) int
		DeleteSchedule          func(childComplexity int, id string) int
		DeleteTemplate          func(childComplexity int, id string) int
		DeleteWebhook           func(childComplexity int, id string) int
		DeleteWorkflow          func(childComplexity int, id string) int
		ExecuteWorkflow         func(childComplexity int, id string, input *string) int
		RegenerateWebhookSecret func(childComplexity int, id string) int
		UpdateSchedule          func(childComplexity int, id string, input UpdateScheduleInput) int
		UpdateTemplate          func(childComplexity int, id string, input UpdateTemplateInput) int
		UpdateWebhook           func(childComplexity int, id string, input UpdateWebhookInput) int
		UpdateWorkflow          func(childComplexity int, id string, input UpdateWorkflowInput) int
	}

	Query struct {
		Execution  func(childComplexity int, id string) int
		Executions func(childComplexity int, workflowID *string, status *string, limit *int, offset *int) int
		Schedule   func(childComplexity int, id string) int
		Schedules  func(childComplexity int, workflowID *string, limit *int, offset *int) int
		Template   func(childComplexity int, id string) int
		Templates  func(childComplexity int, category *string, limit *int, offset *int) int
		Webhook    func(childComplexity int, id string) int
		Webhooks   func(childComplexity int, limit *int, offset *int) int
		Workflow   func(childComplexity int, id string) int
		Workflows  func(childComplexity int, limit *int, offset *int) int
	}

	Schedule struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CronExpression  func(childComplexity int) int
		Enabled         func(childComplexity int) int
		ID              func(childComplexity int) int
		LastExecutionID func(childComplexity int) int
		LastRunAt       func(childComplexity int) int
		Name            func(childComplexity int) int
		NextRunAt       func(childComplexity int) int
		TenantID        func(childComplexity int) int
		Timezone        func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		Workflow        func(childComplexity int) int
		WorkflowID      func(childComplexity int) int
	}

	StepExecution struct {
		CompletedAt  func(childComplexity int) int
		DurationMs   func(childComplexity int) int
		ErrorMessage func(childComplexity int) int
		ExecutionID  func(childComplexity int) int
		ID           func(childComplexity int) int
		InputData    func(childComplexity int) int
		NodeID       func(childComplexity int) int
		NodeType     func(childComplexity int) int
		OutputData   func(childComplexity int) int
		RetryCount   func(childComplexity int) int
		StartedAt    func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	Subscription struct {
		ExecutionUpdated func(childComplexity int, workflowID *string) int
	}

	Template struct {
		Category    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Definition  func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		IsPublic    func(childComplexity int) int
		Name        func(childComplexity int) int
		Tags        func(childComplexity int) int
		TenantID    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UsageCount  func(childComplexity int) int
	}

	Webhook struct {
		AuthType        func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Description     func(childComplexity int) int
		Enabled         func(childComplexity int) int
		Events          func(childComplexity int, limit *int) int
		ID              func(childComplexity int) int
		LastTriggeredAt func(childComplexity int) int
		Name            func(childComplexity int) int
		NodeID          func(childComplexity int) int
		Path            func(childComplexity int) int
		Priority        func(childComplexity int) int
		Secret          func(childComplexity int) int
		TenantID        func(childComplexity int) int
		TriggerCount    func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		Workflow        func(childComplexity int) int
		WorkflowID      func(childComplexity int) int
	}

	WebhookEvent struct {
		CreatedAt        func(childComplexity int) int
		ErrorMessage     func(childComplexity int) int
		ExecutionID      func(childComplexity int) int
		FilteredReason   func(childComplexity int) int
		ID               func(childComplexity int) int
		Metadata         func(childComplexity int) int
		ProcessingTimeMs func(childComplexity int) int
		ReplayCount      func(childComplexity int) int
		RequestBody      func(childComplexity int) int
		RequestHeaders   func(childComplexity int) int
		RequestMethod    func(childComplexity int) int
		ResponseStatus   func(childComplexity int) int
		SourceEventID    func(childComplexity int) int
		Status           func(childComplexity int) int
		TenantID         func(childComplexity int) int
		WebhookID        func(childComplexity int) int
	}

	Workflow struct {
		CreatedAt   func(childComplexity int) int
		CreatedBy   func(childComplexity int) int
		Definition  func(childComplexity int) int
		Description func(childComplexity int) int
		Executions  func(childComplexity int, limit *int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Schedules   func(childComplexity int) int
		Status      func(childComplexity int) int
		TenantID    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Version     func(childComplexity int) int
		Webhooks    func(childComplexity int) int
	}

	WorkflowConnection struct {
		Data       func(childComplexity int) int
		HasMore    func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateWorkflow(ctx context.Context, input CreateWorkflowInput) (*Workflow, error)
	UpdateWorkflow(ctx context.Context, id string, input UpdateWorkflowInput) (*Workflow, error)
	DeleteWorkflow(ctx context.Context, id string) (bool, error)
	ExecuteWorkflow(ctx context.Context, id string, input *string) (*Execution, error)
	CancelExecution(ctx context.Context, id string) (*Execution, error)
	CreateWebhook(ctx context.Context, input CreateWebhookInput) (*Webhook, error)
	UpdateWebhook(ctx context.Context, id string, input UpdateWebhookInput) (*Webhook, error)
	DeleteWebhook(ctx context.Context, id string) (bool, error)
	RegenerateWebhookSecret(ctx context.Context, id string) (*Webhook, error)
	CreateSchedule(ctx context.Context, workflowID string, input CreateScheduleInput) (*Schedule, error)
	UpdateSchedule(ctx context.Context, id string, input UpdateScheduleInput) (*Schedule, error)
	DeleteSchedule(ctx context.Context, id string) (bool, error)
	CreateTemplate(ctx context.Context, input CreateTemplateInput) (*Template, error)
	UpdateTemplate(ctx context.Context, id string, input UpdateTemplateInput) (*Template, error)
	DeleteTemplate(ctx context.Context, id string) (bool, error)
}
type QueryResolver interface {
	Workflows(ctx context.Context, limit *int, offset *int) (*WorkflowConnection, error)
	Workflow(ctx context.Context, id string) (*Workflow, error)
	Executions(ctx context.Context, workflowID *string, status *string, limit *int, offset *int) (*ExecutionConnection, error)
	Execution(ctx context.Context, id string) (*Execution, error)
	Webhooks(ctx context.Context, limit *int, offset *int) ([]*Webhook, error)
	Webhook(ctx context.Context, id string) (*Webhook, error)
	Schedules(ctx context.Context, workflowID *string, limit *int, offset *int) ([]*Schedule, error)
	Schedule(ctx context.Context, id string) (*Schedule, error)
	Templates(ctx context.Context, category *string, limit *int, offset *int) ([]*Template, error)
	Template(ctx context.Context, id string) (*Template, error)
}
type SubscriptionResolver interface {
	ExecutionUpdated(ctx context.Context, workflowID *string) (<-chan *Execution, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Execution.completedAt":
		if e.complexity.Execution.CompletedAt == nil {
			break
		}

		return e.complexity.Execution.CompletedAt(childComplexity), true
	case "Execution.createdAt":
		if e.complexity.Execution.CreatedAt == nil {
			break
		}

		return e.complexity.Execution.CreatedAt(childComplexity), true
	case "Execution.errorMessage":
		if e.complexity.Execution.ErrorMessage == nil {
			break
		}

		return e.complexity.Execution.ErrorMessage(childComplexity), true
	case "Execution.executionDepth":
		if e.complexity.Execution.ExecutionDepth == nil {
			break
		}

		return e.complexity.Execution.ExecutionDepth(childComplexity), true
	case "Execution.id":
		if e.complexity.Execution.ID == nil {
			break
		}

		return e.complexity.Execution.ID(childComplexity), true
	case "Execution.outputData":
		if e.complexity.Execution.OutputData == nil {
			break
		}

		return e.complexity.Execution.OutputData(childComplexity), true
	case "Execution.parentExecutionId":
		if e.complexity.Execution.ParentExecutionID == nil {
			break
		}

		return e.complexity.Execution.ParentExecutionID(childComplexity), true
	case "Execution.startedAt":
		if e.complexity.Execution.StartedAt == nil {
			break
		}

		return e.complexity.Execution.StartedAt(childComplexity), true
	case "Execution.status":
		if e.complexity.Execution.Status == nil {
			break
		}

		return e.complexity.Execution.Status(childComplexity), true
	case "Execution.steps":
		if e.complexity.Execution.Steps == nil {
			break
		}

		return e.complexity.Execution.Steps(childComplexity), true
	case "Execution.tenantId":
		if e.complexity.Execution.TenantID == nil {
			break
		}

		return e.complexity.Execution.TenantID(childComplexity), true
	case "Execution.triggerData":
		if e.complexity.Execution.TriggerData == nil {
			break
		}

		return e.complexity.Execution.TriggerData(childComplexity), true
	case "Execution.triggerType":
		if e.complexity.Execution.TriggerType == nil {
			break
		}

		return e.complexity.Execution.TriggerType(childComplexity), true
	case "Execution.workflow":
		if e.complexity.Execution.Workflow == nil {
			break
		}

		return e.complexity.Execution.Workflow(childComplexity), true
	case "Execution.workflowId":
		if e.complexity.Execution.WorkflowID == nil {
			break
		}

		return e.complexity.Execution.WorkflowID(childComplexity), true
	case "Execution.workflowVersion":
		if e.complexity.Execution.WorkflowVersion == nil {
			break
		}

		return e.complexity.Execution.WorkflowVersion(childComplexity), true

	case "ExecutionConnection.cursor":
		if e.complexity.ExecutionConnection.Cursor == nil {
			break
		}

		return e.complexity.ExecutionConnection.Cursor(childComplexity), true
	case "ExecutionConnection.data":
		if e.complexity.ExecutionConnection.Data == nil {
			break
		}

		return e.complexity.ExecutionConnection.Data(childComplexity), true
	case "ExecutionConnection.hasMore":
		if e.complexity.ExecutionConnection.HasMore == nil {
			break
		}

		return e.complexity.ExecutionConnection.HasMore(childComplexity), true
	case "ExecutionConnection.totalCount":
		if e.complexity.ExecutionConnection.TotalCount == nil {
			break
		}

		return e.complexity.ExecutionConnection.TotalCount(childComplexity), true

	case "Mutation.cancelExecution":
		if e.complexity.Mutation.CancelExecution == nil {
			break
		}

		args, err := ec.field_Mutation_cancelExecution_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelExecution(childComplexity, args["id"].(string)), true
	case "Mutation.createSchedule":
		if e.complexity.Mutation.CreateSchedule == nil {
			break
		}

		args, err := ec.field_Mutation_createSchedule_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSchedule(childComplexity, args["workflowId"].(string), args["input"].(CreateScheduleInput)), true
	case "Mutation.createTemplate":
		if e.complexity.Mutation.CreateTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_createTemplate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTemplate(childComplexity, args["input"].(CreateTemplateInput)), true
	case "Mutation.createWebhook":
		if e.complexity.Mutation.CreateWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_createWebhook_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateWebhook(childComplexity, args["input"].(CreateWebhookInput)), true
	case "Mutation.createWorkflow":
		if e.complexity.Mutation.CreateWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_createWorkflow_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateWorkflow(childComplexity, args["input"].(CreateWorkflowInput)), true
	case "Mutation.deleteSchedule":
		if e.complexity.Mutation.DeleteSchedule == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSchedule_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSchedule(childComplexity, args["id"].(string)), true
	case "Mutation.deleteTemplate":
		if e.complexity.Mutation.DeleteTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTemplate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTemplate(childComplexity, args["id"].(string)), true
	case "Mutation.deleteWebhook":
		if e.complexity.Mutation.DeleteWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWebhook_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWebhook(childComplexity, args["id"].(string)), true
	case "Mutation.deleteWorkflow":
		if e.complexity.Mutation.DeleteWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWorkflow_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWorkflow(childComplexity, args["id"].(string)), true
	case "Mutation.executeWorkflow":
		if e.complexity.Mutation.ExecuteWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_executeWorkflow_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExecuteWorkflow(childComplexity, args["id"].(string), args["input"].(*string)), true
	case "Mutation.regenerateWebhookSecret":
		if e.complexity.Mutation.RegenerateWebhookSecret == nil {
			break
		}

		args, err := ec.field_Mutation_regenerateWebhookSecret_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegenerateWebhookSecret(childComplexity, args["id"].(string)), true
	case "Mutation.updateSchedule":
		if e.complexity.Mutation.UpdateSchedule == nil {
			break
		}

		args, err := ec.field_Mutation_updateSchedule_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSchedule(childComplexity, args["id"].(string), args["input"].(UpdateScheduleInput)), true
	case "Mutation.updateTemplate":
		if e.complexity.Mutation.UpdateTemplate == nil {
			break
		}

		args, err := ec.field_Mutation_updateTemplate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTemplate(childComplexity, args["id"].(string), args["input"].(UpdateTemplateInput)), true
	case "Mutation.updateWebhook":
		if e.complexity.Mutation.UpdateWebhook == nil {
			break
		}

		args, err := ec.field_Mutation_updateWebhook_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateWebhook(childComplexity, args["id"].(string), args["input"].(UpdateWebhookInput)), true
	case "Mutation.updateWorkflow":
		if e.complexity.Mutation.UpdateWorkflow == nil {
			break
		}

		args, err := ec.field_Mutation_updateWorkflow_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateWorkflow(childComplexity, args["id"].(string), args["input"].(UpdateWorkflowInput)), true

	case "Query.execution":
		if e.complexity.Query.Execution == nil {
			break
		}

		args, err := ec.field_Query_execution_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Execution(childComplexity, args["id"].(string)), true
	case "Query.executions":
		if e.complexity.Query.Executions == nil {
			break
		}

		args, err := ec.field_Query_executions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Executions(childComplexity, args["workflowId"].(*string), args["status"].(*string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.schedule":
		if e.complexity.Query.Schedule == nil {
			break
		}

		args, err := ec.field_Query_schedule_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Schedule(childComplexity, args["id"].(string)), true
	case "Query.schedules":
		if e.complexity.Query.Schedules == nil {
			break
		}

		args, err := ec.field_Query_schedules_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Schedules(childComplexity, args["workflowId"].(*string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.template":
		if e.complexity.Query.Template == nil {
			break
		}

		args, err := ec.field_Query_template_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Template(childComplexity, args["id"].(string)), true
	case "Query.templates":
		if e.complexity.Query.Templates == nil {
			break
		}

		args, err := ec.field_Query_templates_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Templates(childComplexity, args["category"].(*string), args["limit"].(*int), args["offset"].(*int)), true
	case "Query.webhook":
		if e.complexity.Query.Webhook == nil {
			break
		}

		args, err := ec.field_Query_webhook_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Webhook(childComplexity, args["id"].(string)), true
	case "Query.webhooks":
		if e.complexity.Query.Webhooks == nil {
			break
		}

		args, err := ec.field_Query_webhooks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Webhooks(childComplexity, args["limit"].(*int), args["offset"].(*int)), true
	case "Query.workflow":
		if e.complexity.Query.Workflow == nil {
			break
		}

		args, err := ec.field_Query_workflow_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Workflow(childComplexity, args["id"].(string)), true
	case "Query.workflows":
		if e.complexity.Query.Workflows == nil {
			break
		}

		args, err := ec.field_Query_workflows_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Workflows(childComplexity, args["limit"].(*int), args["offset"].(*int)), true

	case "Schedule.createdAt":
		if e.complexity.Schedule.CreatedAt == nil {
			break
		}

		return e.complexity.Schedule.CreatedAt(childComplexity), true
	case "Schedule.createdBy":
		if e.complexity.Schedule.CreatedBy == nil {
			break
		}

		return e.complexity.Schedule.CreatedBy(childComplexity), true
	case "Schedule.cronExpression":
		if e.complexity.Schedule.CronExpression == nil {
			break
		}

		return e.complexity.Schedule.CronExpression(childComplexity), true
	case "Schedule.enabled":
		if e.complexity.Schedule.Enabled == nil {
			break
		}

		return e.complexity.Schedule.Enabled(childComplexity), true
	case "Schedule.id":
		if e.complexity.Schedule.ID == nil {
			break
		}

		return e.complexity.Schedule.ID(childComplexity), true
	case "Schedule.lastExecutionId":
		if e.complexity.Schedule.LastExecutionID == nil {
			break
		}

		return e.complexity.Schedule.LastExecutionID(childComplexity), true
	case "Schedule.lastRunAt":
		if e.complexity.Schedule.LastRunAt == nil {
			break
		}

		return e.complexity.Schedule.LastRunAt(childComplexity), true
	case "Schedule.name":
		if e.complexity.Schedule.Name == nil {
			break
		}

		return e.complexity.Schedule.Name(childComplexity), true
	case "Schedule.nextRunAt":
		if e.complexity.Schedule.NextRunAt == nil {
			break
		}

		return e.complexity.Schedule.NextRunAt(childComplexity), true
	case "Schedule.tenantId":
		if e.complexity.Schedule.TenantID == nil {
			break
		}

		return e.complexity.Schedule.TenantID(childComplexity), true
	case "Schedule.timezone":
		if e.complexity.Schedule.Timezone == nil {
			break
		}

		return e.complexity.Schedule.Timezone(childComplexity), true
	case "Schedule.updatedAt":
		if e.complexity.Schedule.UpdatedAt == nil {
			break
		}

		return e.complexity.Schedule.UpdatedAt(childComplexity), true
	case "Schedule.workflow":
		if e.complexity.Schedule.Workflow == nil {
			break
		}

		return e.complexity.Schedule.Workflow(childComplexity), true
	case "Schedule.workflowId":
		if e.complexity.Schedule.WorkflowID == nil {
			break
		}

		return e.complexity.Schedule.WorkflowID(childComplexity), true

	case "StepExecution.completedAt":
		if e.complexity.StepExecution.CompletedAt == nil {
			break
		}

		return e.complexity.StepExecution.CompletedAt(childComplexity), true
	case "StepExecution.durationMs":
		if e.complexity.StepExecution.DurationMs == nil {
			break
		}

		return e.complexity.StepExecution.DurationMs(childComplexity), true
	case "StepExecution.errorMessage":
		if e.complexity.StepExecution.ErrorMessage == nil {
			break
		}

		return e.complexity.StepExecution.ErrorMessage(childComplexity), true
	case "StepExecution.executionId":
		if e.complexity.StepExecution.ExecutionID == nil {
			break
		}

		return e.complexity.StepExecution.ExecutionID(childComplexity), true
	case "StepExecution.id":
		if e.complexity.StepExecution.ID == nil {
			break
		}

		return e.complexity.StepExecution.ID(childComplexity), true
	case "StepExecution.inputData":
		if e.complexity.StepExecution.InputData == nil {
			break
		}

		return e.complexity.StepExecution.InputData(childComplexity), true
	case "StepExecution.nodeId":
		if e.complexity.StepExecution.NodeID == nil {
			break
		}

		return e.complexity.StepExecution.NodeID(childComplexity), true
	case "StepExecution.nodeType":
		if e.complexity.StepExecution.NodeType == nil {
			break
		}

		return e.complexity.StepExecution.NodeType(childComplexity), true
	case "StepExecution.outputData":
		if e.complexity.StepExecution.OutputData == nil {
			break
		}

		return e.complexity.StepExecution.OutputData(childComplexity), true
	case "StepExecution.retryCount":
		if e.complexity.StepExecution.RetryCount == nil {
			break
		}

		return e.complexity.StepExecution.RetryCount(childComplexity), true
	case "StepExecution.startedAt":
		if e.complexity.StepExecution.StartedAt == nil {
			break
		}

		return e.complexity.StepExecution.StartedAt(childComplexity), true
	case "StepExecution.status":
		if e.complexity.StepExecution.Status == nil {
			break
		}

		return e.complexity.StepExecution.Status(childComplexity), true

	case "Subscription.executionUpdated":
		if e.complexity.Subscription.ExecutionUpdated == nil {
			break
		}

		args, err := ec.field_Subscription_executionUpdated_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ExecutionUpdated(childComplexity, args["workflowId"].(*string)), true

	case "Template.category":
		if e.complexity.Template.Category == nil {
			break
		}

		return e.complexity.Template.Category(childComplexity), true
	case "Template.createdAt":
		if e.complexity.Template.CreatedAt == nil {
			break
		}

		return e.complexity.Template.CreatedAt(childComplexity), true
	case "Template.createdBy":
		if e.complexity.Template.CreatedBy == nil {
			break
		}

		return e.complexity.Template.CreatedBy(childComplexity), true
	case "Template.definition":
		if e.complexity.Template.Definition == nil {
			break
		}

		return e.complexity.Template.Definition(childComplexity), true
	case "Template.description":
		if e.complexity.Template.Description == nil {
			break
		}

		return e.complexity.Template.Description(childComplexity), true
	case "Template.id":
		if e.complexity.Template.ID == nil {
			break
		}

		return e.complexity.Template.ID(childComplexity), true
	case "Template.isPublic":
		if e.complexity.Template.IsPublic == nil {
			break
		}

		return e.complexity.Template.IsPublic(childComplexity), true
	case "Template.name":
		if e.complexity.Template.Name == nil {
			break
		}

		return e.complexity.Template.Name(childComplexity), true
	case "Template.tags":
		if e.complexity.Template.Tags == nil {
			break
		}

		return e.complexity.Template.Tags(childComplexity), true
	case "Template.tenantId":
		if e.complexity.Template.TenantID == nil {
			break
		}

		return e.complexity.Template.TenantID(childComplexity), true
	case "Template.updatedAt":
		if e.complexity.Template.UpdatedAt == nil {
			break
		}

		return e.complexity.Template.UpdatedAt(childComplexity), true
	case "Template.usageCount":
		if e.complexity.Template.UsageCount == nil {
			break
		}

		return e.complexity.Template.UsageCount(childComplexity), true

	case "Webhook.authType":
		if e.complexity.Webhook.AuthType == nil {
			break
		}

		return e.complexity.Webhook.AuthType(childComplexity), true
	case "Webhook.createdAt":
		if e.complexity.Webhook.CreatedAt == nil {
			break
		}

		return e.complexity.Webhook.CreatedAt(childComplexity), true
	case "Webhook.description":
		if e.complexity.Webhook.Description == nil {
			break
		}

		return e.complexity.Webhook.Description(childComplexity), true
	case "Webhook.enabled":
		if e.complexity.Webhook.Enabled == nil {
			break
		}

		return e.complexity.Webhook.Enabled(childComplexity), true
	case "Webhook.events":
		if e.complexity.Webhook.Events == nil {
			break
		}

		args, err := ec.field_Webhook_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Webhook.Events(childComplexity, args["limit"].(*int)), true
	case "Webhook.id":
		if e.complexity.Webhook.ID == nil {
			break
		}

		return e.complexity.Webhook.ID(childComplexity), true
	case "Webhook.lastTriggeredAt":
		if e.complexity.Webhook.LastTriggeredAt == nil {
			break
		}

		return e.complexity.Webhook.LastTriggeredAt(childComplexity), true
	case "Webhook.name":
		if e.complexity.Webhook.Name == nil {
			break
		}

		return e.complexity.Webhook.Name(childComplexity), true
	case "Webhook.nodeId":
		if e.complexity.Webhook.NodeID == nil {
			break
		}

		return e.complexity.Webhook.NodeID(childComplexity), true
	case "Webhook.path":
		if e.complexity.Webhook.Path == nil {
			break
		}

		return e.complexity.Webhook.Path(childComplexity), true
	case "Webhook.priority":
		if e.complexity.Webhook.Priority == nil {
			break
		}

		return e.complexity.Webhook.Priority(childComplexity), true
	case "Webhook.secret":
		if e.complexity.Webhook.Secret == nil {
			break
		}

		return e.complexity.Webhook.Secret(childComplexity), true
	case "Webhook.tenantId":
		if e.complexity.Webhook.TenantID == nil {
			break
		}

		return e.complexity.Webhook.TenantID(childComplexity), true
	case "Webhook.triggerCount":
		if e.complexity.Webhook.TriggerCount == nil {
			break
		}

		return e.complexity.Webhook.TriggerCount(childComplexity), true
	case "Webhook.updatedAt":
		if e.complexity.Webhook.UpdatedAt == nil {
			break
		}

		return e.complexity.Webhook.UpdatedAt(childComplexity), true
	case "Webhook.workflow":
		if e.complexity.Webhook.Workflow == nil {
			break
		}

		return e.complexity.Webhook.Workflow(childComplexity), true
	case "Webhook.workflowId":
		if e.complexity.Webhook.WorkflowID == nil {
			break
		}

		return e.complexity.Webhook.WorkflowID(childComplexity), true

	case "WebhookEvent.createdAt":
		if e.complexity.WebhookEvent.CreatedAt == nil {
			break
		}

		return e.complexity.WebhookEvent.CreatedAt(childComplexity), true
	case "WebhookEvent.errorMessage":
		if e.complexity.WebhookEvent.ErrorMessage == nil {
			break
		}

		return e.complexity.WebhookEvent.ErrorMessage(childComplexity), true
	case "WebhookEvent.executionId":
		if e.complexity.WebhookEvent.ExecutionID == nil {
			break
		}

		return e.complexity.WebhookEvent.ExecutionID(childComplexity), true
	case "WebhookEvent.filteredReason":
		if e.complexity.WebhookEvent.FilteredReason == nil {
			break
		}

		return e.complexity.WebhookEvent.FilteredReason(childComplexity), true
	case "WebhookEvent.id":
		if e.complexity.WebhookEvent.ID == nil {
			break
		}

		return e.complexity.WebhookEvent.ID(childComplexity), true
	case "WebhookEvent.metadata":
		if e.complexity.WebhookEvent.Metadata == nil {
			break
		}

		return e.complexity.WebhookEvent.Metadata(childComplexity), true
	case "WebhookEvent.processingTimeMs":
		if e.complexity.WebhookEvent.ProcessingTimeMs == nil {
			break
		}

		return e.complexity.WebhookEvent.ProcessingTimeMs(childComplexity), true
	case "WebhookEvent.replayCount":
		if e.complexity.WebhookEvent.ReplayCount == nil {
			break
		}

		return e.complexity.WebhookEvent.ReplayCount(childComplexity), true
	case "WebhookEvent.requestBody":
		if e.complexity.WebhookEvent.RequestBody == nil {
			break
		}

		return e.complexity.WebhookEvent.RequestBody(childComplexity), true
	case "WebhookEvent.requestHeaders":
		if e.complexity.WebhookEvent.RequestHeaders == nil {
			break
		}

		return e.complexity.WebhookEvent.RequestHeaders(childComplexity), true
	case "WebhookEvent.requestMethod":
		if e.complexity.WebhookEvent.RequestMethod == nil {
			break
		}

		return e.complexity.WebhookEvent.RequestMethod(childComplexity), true
	case "WebhookEvent.responseStatus":
		if e.complexity.WebhookEvent.ResponseStatus == nil {
			break
		}

		return e.complexity.WebhookEvent.ResponseStatus(childComplexity), true
	case "WebhookEvent.sourceEventId":
		if e.complexity.WebhookEvent.SourceEventID == nil {
			break
		}

		return e.complexity.WebhookEvent.SourceEventID(childComplexity), true
	case "WebhookEvent.status":
		if e.complexity.WebhookEvent.Status == nil {
			break
		}

		return e.complexity.WebhookEvent.Status(childComplexity), true
	case "WebhookEvent.tenantId":
		if e.complexity.WebhookEvent.TenantID == nil {
			break
		}

		return e.complexity.WebhookEvent.TenantID(childComplexity), true
	case "WebhookEvent.webhookId":
		if e.complexity.WebhookEvent.WebhookID == nil {
			break
		}

		return e.complexity.WebhookEvent.WebhookID(childComplexity), true

	case "Workflow.createdAt":
		if e.complexity.Workflow.CreatedAt == nil {
			break
		}

		return e.complexity.Workflow.CreatedAt(childComplexity), true
	case "Workflow.createdBy":
		if e.complexity.Workflow.CreatedBy == nil {
			break
		}

		return e.complexity.Workflow.CreatedBy(childComplexity), true
	case "Workflow.definition":
		if e.complexity.Workflow.Definition == nil {
			break
		}

		return e.complexity.Workflow.Definition(childComplexity), true
	case "Workflow.description":
		if e.complexity.Workflow.Description == nil {
			break
		}

		return e.complexity.Workflow.Description(childComplexity), true
	case "Workflow.executions":
		if e.complexity.Workflow.Executions == nil {
			break
		}

		args, err := ec.field_Workflow_executions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workflow.Executions(childComplexity, args["limit"].(*int)), true
	case "Workflow.id":
		if e.complexity.Workflow.ID == nil {
			break
		}

		return e.complexity.Workflow.ID(childComplexity), true
	case "Workflow.name":
		if e.complexity.Workflow.Name == nil {
			break
		}

		return e.complexity.Workflow.Name(childComplexity), true
	case "Workflow.schedules":
		if e.complexity.Workflow.Schedules == nil {
			break
		}

		return e.complexity.Workflow.Schedules(childComplexity), true
	case "Workflow.status":
		if e.complexity.Workflow.Status == nil {
			break
		}

		return e.complexity.Workflow.Status(childComplexity), true
	case "Workflow.tenantId":
		if e.complexity.Workflow.TenantID == nil {
			break
		}

		return e.complexity.Workflow.TenantID(childComplexity), true
	case "Workflow.updatedAt":
		if e.complexity.Workflow.UpdatedAt == nil {
			break
		}

		return e.complexity.Workflow.UpdatedAt(childComplexity), true
	case "Workflow.version":
		if e.complexity.Workflow.Version == nil {
			break
		}

		return e.complexity.Workflow.Version(childComplexity), true
	case "Workflow.webhooks":
		if e.complexity.Workflow.Webhooks == nil {
			break
		}

		return e.complexity.Workflow.Webhooks(childComplexity), true

	case "WorkflowConnection.data":
		if e.complexity.WorkflowConnection.Data == nil {
			break
		}

		return e.complexity.WorkflowConnection.Data(childComplexity), true
	case "WorkflowConnection.hasMore":
		if e.complexity.WorkflowConnection.HasMore == nil {
			break
		}

		return e.complexity.WorkflowConnection.HasMore(childComplexity), true
	case "WorkflowConnection.totalCount":
		if e.complexity.WorkflowConnection.TotalCount == nil {
			break
		}

		return e.complexity.WorkflowConnection.TotalCount(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateScheduleInput,
		ec.unmarshalInputCreateTemplateInput,
		ec.unmarshalInputCreateWebhookInput,
		ec.unmarshalInputCreateWorkflowInput,
		ec.unmarshalInputUpdateScheduleInput,
		ec.unmarshalInputUpdateTemplateInput,
		ec.unmarshalInputUpdateWebhookInput,
		ec.unmarshalInputUpdateWorkflowInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphql", Input: `# GraphQL schema for Gorax workflow automation platform
# For MVP, using String for JSON and Time types for simplicity

type Query {
  # Workflows
  workflows(limit: Int, offset: Int): WorkflowConnection!
  workflow(id: ID!): Workflow

  # Executions
  executions(workflowId: ID, status: String, limit: Int, offset: Int): ExecutionConnection!
  execution(id: ID!): Execution

  # Webhooks
  webhooks(limit: Int, offset: Int): [Webhook!]!
  webhook(id: ID!): Webhook

  # Schedules
  schedules(workflowId: ID, limit: Int, offset: Int): [Schedule!]!
  schedule(id: ID!): Schedule

  # Templates
  templates(category: String, limit: Int, offset: Int): [Template!]!
  template(id: ID!): Template
}

type Mutation {
  # Workflow mutations
  createWorkflow(input: CreateWorkflowInput!): Workflow!
  updateWorkflow(id: ID!, input: UpdateWorkflowInput!): Workflow!
  deleteWorkflow(id: ID!): Boolean!
  executeWorkflow(id: ID!, input: String): Execution!

  # Execution mutations
  cancelExecution(id: ID!): Execution!

  # Webhook mutations
  createWebhook(input: CreateWebhookInput!): Webhook!
  updateWebhook(id: ID!, input: UpdateWebhookInput!): Webhook!
  deleteWebhook(id: ID!): Boolean!
  regenerateWebhookSecret(id: ID!): Webhook!

  # Schedule mutations
  createSchedule(workflowId: ID!, input: CreateScheduleInput!): Schedule!
  updateSchedule(id: ID!, input: UpdateScheduleInput!): Schedule!
  deleteSchedule(id: ID!): Boolean!

  # Template mutations
  createTemplate(input: CreateTemplateInput!): Template!
  updateTemplate(id: ID!, input: UpdateTemplateInput!): Template!
  deleteTemplate(id: ID!): Boolean!
}

type Subscription {
  # Execution subscriptions
  executionUpdated(workflowId: ID): Execution!
}

# Workflow types
type Workflow {
  id: ID!
  tenantId: String!
  name: String!
  description: String!
  definition: String!
  status: String!
  version: Int!
  createdBy: String!
  createdAt: String!
  updatedAt: String!
  executions(limit: Int): [Execution!]
  schedules: [Schedule!]
  webhooks: [Webhook!]
}

type WorkflowConnection {
  data: [Workflow!]!
  totalCount: Int!
  hasMore: Boolean!
}

input CreateWorkflowInput {
  name: String!
  description: String
  definition: String!
}

input UpdateWorkflowInput {
  name: String
  description: String
  definition: String
  status: String
}

# Execution types
type Execution {
  id: ID!
  tenantId: String!
  workflowId: String!
  workflowVersion: Int!
  status: String!
  triggerType: String!
  triggerData: String
  outputData: String
  errorMessage: String
  parentExecutionId: String
  executionDepth: Int!
  startedAt: String
  completedAt: String
  createdAt: String!
  workflow: Workflow
  steps: [StepExecution!]
}

type ExecutionConnection {
  data: [Execution!]!
  totalCount: Int!
  hasMore: Boolean!
  cursor: String
}

type StepExecution {
  id: ID!
  executionId: String!
  nodeId: String!
  nodeType: String!
  status: String!
  inputData: String
  outputData: String
  errorMessage: String
  retryCount: Int!
  startedAt: String
  completedAt: String
  durationMs: Int
}

# Webhook types
type Webhook {
  id: ID!
  tenantId: String!
  workflowId: String!
  nodeId: String!
  name: String!
  path: String!
  secret: String!
  authType: String!
  description: String!
  priority: Int!
  enabled: Boolean!
  triggerCount: Int!
  lastTriggeredAt: String
  createdAt: String!
  updatedAt: String!
  workflow: Workflow
  events(limit: Int): [WebhookEvent!]
}

type WebhookEvent {
  id: ID!
  tenantId: String!
  webhookId: String!
  executionId: String
  requestMethod: String!
  requestHeaders: String!
  requestBody: String!
  responseStatus: Int
  processingTimeMs: Int
  status: String!
  errorMessage: String
  filteredReason: String
  replayCount: Int!
  sourceEventId: String
  metadata: String
  createdAt: String!
}

input CreateWebhookInput {
  workflowId: ID!
  nodeId: String!
  name: String!
  authType: String
  description: String
}

input UpdateWebhookInput {
  name: String
  authType: String
  description: String
  enabled: Boolean
}

# Schedule types
type Schedule {
  id: ID!
  tenantId: String!
  workflowId: String!
  name: String!
  cronExpression: String!
  timezone: String!
  enabled: Boolean!
  nextRunAt: String
  lastRunAt: String
  lastExecutionId: String
  createdBy: String!
  createdAt: String!
  updatedAt: String!
  workflow: Workflow
}

input CreateScheduleInput {
  name: String!
  cronExpression: String!
  timezone: String
  enabled: Boolean
}

input UpdateScheduleInput {
  name: String
  cronExpression: String
  timezone: String
  enabled: Boolean
}

# Template types
type Template {
  id: ID!
  tenantId: String
  name: String!
  description: String!
  category: String!
  definition: String!
  tags: [String!]
  isPublic: Boolean!
  usageCount: Int!
  createdBy: String!
  createdAt: String!
  updatedAt: String!
}

input CreateTemplateInput {
  name: String!
  description: String
  category: String!
  definition: String!
  tags: [String!]
  isPublic: Boolean
}

input UpdateTemplateInput {
  name: String
  description: String
  category: String
  definition: String
  tags: [String!]
  isPublic: Boolean
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_cancelExecution_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSchedule_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "workflowId", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["workflowId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateScheduleInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateScheduleInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createTemplate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateTemplateInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateTemplateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createWebhook_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateWebhookInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateWebhookInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createWorkflow_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateWorkflowInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateWorkflowInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSchedule_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTemplate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWebhook_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWorkflow_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_executeWorkflow_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_regenerateWebhookSecret_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSchedule_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateScheduleInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateScheduleInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTemplate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateTemplateInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateTemplateInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateWebhook_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateWebhookInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateWebhookInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateWorkflow_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateWorkflowInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateWorkflowInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_execution_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_executions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "workflowId", ec.unmarshalOID2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["workflowId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "status", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["status"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_schedule_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_schedules_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "workflowId", ec.unmarshalOID2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["workflowId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_template_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_templates_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "category", ec.unmarshalOString2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["category"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_webhook_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_webhooks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_workflow_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2string)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_workflows_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_executionUpdated_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "workflowId", ec.unmarshalOID2ᚖstring)
	if err != nil {
		return nil, err
	}
	args["workflowId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Webhook_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Workflow_executions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Execution_id(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_tenantId(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_tenantId,
		func(ctx context.Context) (any, error) {
			return obj.TenantID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_tenantId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_workflowId(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_workflowId,
		func(ctx context.Context) (any, error) {
			return obj.WorkflowID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_workflowId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_workflowVersion(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_workflowVersion,
		func(ctx context.Context) (any, error) {
			return obj.WorkflowVersion, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_workflowVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_status(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_triggerType(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_triggerType,
		func(ctx context.Context) (any, error) {
			return obj.TriggerType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_triggerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_triggerData(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_triggerData,
		func(ctx context.Context) (any, error) {
			return obj.TriggerData, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_triggerData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_outputData(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_outputData,
		func(ctx context.Context) (any, error) {
			return obj.OutputData, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_outputData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_errorMessage(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_errorMessage,
		func(ctx context.Context) (any, error) {
			return obj.ErrorMessage, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_parentExecutionId(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_parentExecutionId,
		func(ctx context.Context) (any, error) {
			return obj.ParentExecutionID, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_parentExecutionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_executionDepth(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_executionDepth,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionDepth, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_executionDepth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_startedAt(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_startedAt,
		func(ctx context.Context) (any, error) {
			return obj.StartedAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_completedAt(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_completedAt,
		func(ctx context.Context) (any, error) {
			return obj.CompletedAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_createdAt(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Execution_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_workflow(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_workflow,
		func(ctx context.Context) (any, error) {
			return obj.Workflow, nil
		},
		nil,
		ec.marshalOWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_workflow(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Execution_steps(ctx context.Context, field graphql.CollectedField, obj *Execution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Execution_steps,
		func(ctx context.Context) (any, error) {
			return obj.Steps, nil
		},
		nil,
		ec.marshalOStepExecution2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐStepExecutionᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Execution_steps(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Execution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StepExecution_id(ctx, field)
			case "executionId":
				return ec.fieldContext_StepExecution_executionId(ctx, field)
			case "nodeId":
				return ec.fieldContext_StepExecution_nodeId(ctx, field)
			case "nodeType":
				return ec.fieldContext_StepExecution_nodeType(ctx, field)
			case "status":
				return ec.fieldContext_StepExecution_status(ctx, field)
			case "inputData":
				return ec.fieldContext_StepExecution_inputData(ctx, field)
			case "outputData":
				return ec.fieldContext_StepExecution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_StepExecution_errorMessage(ctx, field)
			case "retryCount":
				return ec.fieldContext_StepExecution_retryCount(ctx, field)
			case "startedAt":
				return ec.fieldContext_StepExecution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_StepExecution_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_StepExecution_durationMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepExecution", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExecutionConnection_data(ctx context.Context, field graphql.CollectedField, obj *ExecutionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExecutionConnection_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNExecution2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExecutionConnection_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExecutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Execution_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Execution_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Execution_workflowId(ctx, field)
			case "workflowVersion":
				return ec.fieldContext_Execution_workflowVersion(ctx, field)
			case "status":
				return ec.fieldContext_Execution_status(ctx, field)
			case "triggerType":
				return ec.fieldContext_Execution_triggerType(ctx, field)
			case "triggerData":
				return ec.fieldContext_Execution_triggerData(ctx, field)
			case "outputData":
				return ec.fieldContext_Execution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_Execution_errorMessage(ctx, field)
			case "parentExecutionId":
				return ec.fieldContext_Execution_parentExecutionId(ctx, field)
			case "executionDepth":
				return ec.fieldContext_Execution_executionDepth(ctx, field)
			case "startedAt":
				return ec.fieldContext_Execution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Execution_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Execution_createdAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Execution_workflow(ctx, field)
			case "steps":
				return ec.fieldContext_Execution_steps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Execution", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExecutionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ExecutionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExecutionConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExecutionConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExecutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExecutionConnection_hasMore(ctx context.Context, field graphql.CollectedField, obj *ExecutionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExecutionConnection_hasMore,
		func(ctx context.Context) (any, error) {
			return obj.HasMore, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExecutionConnection_hasMore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExecutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExecutionConnection_cursor(ctx context.Context, field graphql.CollectedField, obj *ExecutionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExecutionConnection_cursor,
		func(ctx context.Context) (any, error) {
			return obj.Cursor, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ExecutionConnection_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExecutionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createWorkflow,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateWorkflow(ctx, fc.Args["input"].(CreateWorkflowInput))
		},
		nil,
		ec.marshalNWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createWorkflow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createWorkflow_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateWorkflow,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateWorkflow(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateWorkflowInput))
		},
		nil,
		ec.marshalNWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateWorkflow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateWorkflow_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteWorkflow,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteWorkflow(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteWorkflow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWorkflow_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_executeWorkflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_executeWorkflow,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ExecuteWorkflow(ctx, fc.Args["id"].(string), fc.Args["input"].(*string))
		},
		nil,
		ec.marshalNExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_executeWorkflow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Execution_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Execution_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Execution_workflowId(ctx, field)
			case "workflowVersion":
				return ec.fieldContext_Execution_workflowVersion(ctx, field)
			case "status":
				return ec.fieldContext_Execution_status(ctx, field)
			case "triggerType":
				return ec.fieldContext_Execution_triggerType(ctx, field)
			case "triggerData":
				return ec.fieldContext_Execution_triggerData(ctx, field)
			case "outputData":
				return ec.fieldContext_Execution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_Execution_errorMessage(ctx, field)
			case "parentExecutionId":
				return ec.fieldContext_Execution_parentExecutionId(ctx, field)
			case "executionDepth":
				return ec.fieldContext_Execution_executionDepth(ctx, field)
			case "startedAt":
				return ec.fieldContext_Execution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Execution_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Execution_createdAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Execution_workflow(ctx, field)
			case "steps":
				return ec.fieldContext_Execution_steps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Execution", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_executeWorkflow_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelExecution(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_cancelExecution,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CancelExecution(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_cancelExecution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Execution_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Execution_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Execution_workflowId(ctx, field)
			case "workflowVersion":
				return ec.fieldContext_Execution_workflowVersion(ctx, field)
			case "status":
				return ec.fieldContext_Execution_status(ctx, field)
			case "triggerType":
				return ec.fieldContext_Execution_triggerType(ctx, field)
			case "triggerData":
				return ec.fieldContext_Execution_triggerData(ctx, field)
			case "outputData":
				return ec.fieldContext_Execution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_Execution_errorMessage(ctx, field)
			case "parentExecutionId":
				return ec.fieldContext_Execution_parentExecutionId(ctx, field)
			case "executionDepth":
				return ec.fieldContext_Execution_executionDepth(ctx, field)
			case "startedAt":
				return ec.fieldContext_Execution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Execution_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Execution_createdAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Execution_workflow(ctx, field)
			case "steps":
				return ec.fieldContext_Execution_steps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Execution", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelExecution_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createWebhook,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateWebhook(ctx, fc.Args["input"].(CreateWebhookInput))
		},
		nil,
		ec.marshalNWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Webhook_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Webhook_workflowId(ctx, field)
			case "nodeId":
				return ec.fieldContext_Webhook_nodeId(ctx, field)
			case "name":
				return ec.fieldContext_Webhook_name(ctx, field)
			case "path":
				return ec.fieldContext_Webhook_path(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			case "authType":
				return ec.fieldContext_Webhook_authType(ctx, field)
			case "description":
				return ec.fieldContext_Webhook_description(ctx, field)
			case "priority":
				return ec.fieldContext_Webhook_priority(ctx, field)
			case "enabled":
				return ec.fieldContext_Webhook_enabled(ctx, field)
			case "triggerCount":
				return ec.fieldContext_Webhook_triggerCount(ctx, field)
			case "lastTriggeredAt":
				return ec.fieldContext_Webhook_lastTriggeredAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Webhook_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Webhook_workflow(ctx, field)
			case "events":
				return ec.fieldContext_Webhook_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateWebhook,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateWebhook(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateWebhookInput))
		},
		nil,
		ec.marshalNWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Webhook_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Webhook_workflowId(ctx, field)
			case "nodeId":
				return ec.fieldContext_Webhook_nodeId(ctx, field)
			case "name":
				return ec.fieldContext_Webhook_name(ctx, field)
			case "path":
				return ec.fieldContext_Webhook_path(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			case "authType":
				return ec.fieldContext_Webhook_authType(ctx, field)
			case "description":
				return ec.fieldContext_Webhook_description(ctx, field)
			case "priority":
				return ec.fieldContext_Webhook_priority(ctx, field)
			case "enabled":
				return ec.fieldContext_Webhook_enabled(ctx, field)
			case "triggerCount":
				return ec.fieldContext_Webhook_triggerCount(ctx, field)
			case "lastTriggeredAt":
				return ec.fieldContext_Webhook_lastTriggeredAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Webhook_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Webhook_workflow(ctx, field)
			case "events":
				return ec.fieldContext_Webhook_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWebhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteWebhook,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteWebhook(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWebhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_regenerateWebhookSecret(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_regenerateWebhookSecret,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RegenerateWebhookSecret(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_regenerateWebhookSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Webhook_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Webhook_workflowId(ctx, field)
			case "nodeId":
				return ec.fieldContext_Webhook_nodeId(ctx, field)
			case "name":
				return ec.fieldContext_Webhook_name(ctx, field)
			case "path":
				return ec.fieldContext_Webhook_path(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			case "authType":
				return ec.fieldContext_Webhook_authType(ctx, field)
			case "description":
				return ec.fieldContext_Webhook_description(ctx, field)
			case "priority":
				return ec.fieldContext_Webhook_priority(ctx, field)
			case "enabled":
				return ec.fieldContext_Webhook_enabled(ctx, field)
			case "triggerCount":
				return ec.fieldContext_Webhook_triggerCount(ctx, field)
			case "lastTriggeredAt":
				return ec.fieldContext_Webhook_lastTriggeredAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Webhook_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Webhook_workflow(ctx, field)
			case "events":
				return ec.fieldContext_Webhook_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_regenerateWebhookSecret_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSchedule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createSchedule,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateSchedule(ctx, fc.Args["workflowId"].(string), fc.Args["input"].(CreateScheduleInput))
		},
		nil,
		ec.marshalNSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createSchedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Schedule_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Schedule_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Schedule_workflowId(ctx, field)
			case "name":
				return ec.fieldContext_Schedule_name(ctx, field)
			case "cronExpression":
				return ec.fieldContext_Schedule_cronExpression(ctx, field)
			case "timezone":
				return ec.fieldContext_Schedule_timezone(ctx, field)
			case "enabled":
				return ec.fieldContext_Schedule_enabled(ctx, field)
			case "nextRunAt":
				return ec.fieldContext_Schedule_nextRunAt(ctx, field)
			case "lastRunAt":
				return ec.fieldContext_Schedule_lastRunAt(ctx, field)
			case "lastExecutionId":
				return ec.fieldContext_Schedule_lastExecutionId(ctx, field)
			case "createdBy":
				return ec.fieldContext_Schedule_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Schedule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Schedule_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Schedule_workflow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Schedule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSchedule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSchedule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateSchedule,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateSchedule(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateScheduleInput))
		},
		nil,
		ec.marshalNSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateSchedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Schedule_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Schedule_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Schedule_workflowId(ctx, field)
			case "name":
				return ec.fieldContext_Schedule_name(ctx, field)
			case "cronExpression":
				return ec.fieldContext_Schedule_cronExpression(ctx, field)
			case "timezone":
				return ec.fieldContext_Schedule_timezone(ctx, field)
			case "enabled":
				return ec.fieldContext_Schedule_enabled(ctx, field)
			case "nextRunAt":
				return ec.fieldContext_Schedule_nextRunAt(ctx, field)
			case "lastRunAt":
				return ec.fieldContext_Schedule_lastRunAt(ctx, field)
			case "lastExecutionId":
				return ec.fieldContext_Schedule_lastExecutionId(ctx, field)
			case "createdBy":
				return ec.fieldContext_Schedule_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Schedule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Schedule_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Schedule_workflow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Schedule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSchedule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSchedule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteSchedule,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteSchedule(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteSchedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSchedule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createTemplate,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateTemplate(ctx, fc.Args["input"].(CreateTemplateInput))
		},
		nil,
		ec.marshalNTemplate2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Template_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Template_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Template_name(ctx, field)
			case "description":
				return ec.fieldContext_Template_description(ctx, field)
			case "category":
				return ec.fieldContext_Template_category(ctx, field)
			case "definition":
				return ec.fieldContext_Template_definition(ctx, field)
			case "tags":
				return ec.fieldContext_Template_tags(ctx, field)
			case "isPublic":
				return ec.fieldContext_Template_isPublic(ctx, field)
			case "usageCount":
				return ec.fieldContext_Template_usageCount(ctx, field)
			case "createdBy":
				return ec.fieldContext_Template_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Template_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Template_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Template", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateTemplate,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateTemplate(ctx, fc.Args["id"].(string), fc.Args["input"].(UpdateTemplateInput))
		},
		nil,
		ec.marshalNTemplate2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Template_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Template_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Template_name(ctx, field)
			case "description":
				return ec.fieldContext_Template_description(ctx, field)
			case "category":
				return ec.fieldContext_Template_category(ctx, field)
			case "definition":
				return ec.fieldContext_Template_definition(ctx, field)
			case "tags":
				return ec.fieldContext_Template_tags(ctx, field)
			case "isPublic":
				return ec.fieldContext_Template_isPublic(ctx, field)
			case "usageCount":
				return ec.fieldContext_Template_usageCount(ctx, field)
			case "createdBy":
				return ec.fieldContext_Template_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Template_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Template_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Template", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteTemplate,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteTemplate(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_workflows(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_workflows,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Workflows(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNWorkflowConnection2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflowConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_workflows(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_WorkflowConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_WorkflowConnection_totalCount(ctx, field)
			case "hasMore":
				return ec.fieldContext_WorkflowConnection_hasMore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkflowConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_workflows_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_workflow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_workflow,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Workflow(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_workflow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_workflow_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_executions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_executions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Executions(ctx, fc.Args["workflowId"].(*string), fc.Args["status"].(*string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNExecutionConnection2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_executions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ExecutionConnection_data(ctx, field)
			case "totalCount":
				return ec.fieldContext_ExecutionConnection_totalCount(ctx, field)
			case "hasMore":
				return ec.fieldContext_ExecutionConnection_hasMore(ctx, field)
			case "cursor":
				return ec.fieldContext_ExecutionConnection_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExecutionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_executions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_execution(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_execution,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Execution(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_execution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Execution_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Execution_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Execution_workflowId(ctx, field)
			case "workflowVersion":
				return ec.fieldContext_Execution_workflowVersion(ctx, field)
			case "status":
				return ec.fieldContext_Execution_status(ctx, field)
			case "triggerType":
				return ec.fieldContext_Execution_triggerType(ctx, field)
			case "triggerData":
				return ec.fieldContext_Execution_triggerData(ctx, field)
			case "outputData":
				return ec.fieldContext_Execution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_Execution_errorMessage(ctx, field)
			case "parentExecutionId":
				return ec.fieldContext_Execution_parentExecutionId(ctx, field)
			case "executionDepth":
				return ec.fieldContext_Execution_executionDepth(ctx, field)
			case "startedAt":
				return ec.fieldContext_Execution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Execution_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Execution_createdAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Execution_workflow(ctx, field)
			case "steps":
				return ec.fieldContext_Execution_steps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Execution", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_execution_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_webhooks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_webhooks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Webhooks(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNWebhook2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_webhooks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Webhook_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Webhook_workflowId(ctx, field)
			case "nodeId":
				return ec.fieldContext_Webhook_nodeId(ctx, field)
			case "name":
				return ec.fieldContext_Webhook_name(ctx, field)
			case "path":
				return ec.fieldContext_Webhook_path(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			case "authType":
				return ec.fieldContext_Webhook_authType(ctx, field)
			case "description":
				return ec.fieldContext_Webhook_description(ctx, field)
			case "priority":
				return ec.fieldContext_Webhook_priority(ctx, field)
			case "enabled":
				return ec.fieldContext_Webhook_enabled(ctx, field)
			case "triggerCount":
				return ec.fieldContext_Webhook_triggerCount(ctx, field)
			case "lastTriggeredAt":
				return ec.fieldContext_Webhook_lastTriggeredAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Webhook_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Webhook_workflow(ctx, field)
			case "events":
				return ec.fieldContext_Webhook_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_webhooks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_webhook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_webhook,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Webhook(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_webhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Webhook_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Webhook_workflowId(ctx, field)
			case "nodeId":
				return ec.fieldContext_Webhook_nodeId(ctx, field)
			case "name":
				return ec.fieldContext_Webhook_name(ctx, field)
			case "path":
				return ec.fieldContext_Webhook_path(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			case "authType":
				return ec.fieldContext_Webhook_authType(ctx, field)
			case "description":
				return ec.fieldContext_Webhook_description(ctx, field)
			case "priority":
				return ec.fieldContext_Webhook_priority(ctx, field)
			case "enabled":
				return ec.fieldContext_Webhook_enabled(ctx, field)
			case "triggerCount":
				return ec.fieldContext_Webhook_triggerCount(ctx, field)
			case "lastTriggeredAt":
				return ec.fieldContext_Webhook_lastTriggeredAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Webhook_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Webhook_workflow(ctx, field)
			case "events":
				return ec.fieldContext_Webhook_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_webhook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_schedules(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_schedules,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Schedules(ctx, fc.Args["workflowId"].(*string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNSchedule2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐScheduleᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_schedules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Schedule_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Schedule_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Schedule_workflowId(ctx, field)
			case "name":
				return ec.fieldContext_Schedule_name(ctx, field)
			case "cronExpression":
				return ec.fieldContext_Schedule_cronExpression(ctx, field)
			case "timezone":
				return ec.fieldContext_Schedule_timezone(ctx, field)
			case "enabled":
				return ec.fieldContext_Schedule_enabled(ctx, field)
			case "nextRunAt":
				return ec.fieldContext_Schedule_nextRunAt(ctx, field)
			case "lastRunAt":
				return ec.fieldContext_Schedule_lastRunAt(ctx, field)
			case "lastExecutionId":
				return ec.fieldContext_Schedule_lastExecutionId(ctx, field)
			case "createdBy":
				return ec.fieldContext_Schedule_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Schedule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Schedule_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Schedule_workflow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Schedule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_schedules_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_schedule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_schedule,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Schedule(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_schedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Schedule_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Schedule_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Schedule_workflowId(ctx, field)
			case "name":
				return ec.fieldContext_Schedule_name(ctx, field)
			case "cronExpression":
				return ec.fieldContext_Schedule_cronExpression(ctx, field)
			case "timezone":
				return ec.fieldContext_Schedule_timezone(ctx, field)
			case "enabled":
				return ec.fieldContext_Schedule_enabled(ctx, field)
			case "nextRunAt":
				return ec.fieldContext_Schedule_nextRunAt(ctx, field)
			case "lastRunAt":
				return ec.fieldContext_Schedule_lastRunAt(ctx, field)
			case "lastExecutionId":
				return ec.fieldContext_Schedule_lastExecutionId(ctx, field)
			case "createdBy":
				return ec.fieldContext_Schedule_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Schedule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Schedule_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Schedule_workflow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Schedule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_schedule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_templates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_templates,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Templates(ctx, fc.Args["category"].(*string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
		},
		nil,
		ec.marshalNTemplate2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplateᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_templates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Template_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Template_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Template_name(ctx, field)
			case "description":
				return ec.fieldContext_Template_description(ctx, field)
			case "category":
				return ec.fieldContext_Template_category(ctx, field)
			case "definition":
				return ec.fieldContext_Template_definition(ctx, field)
			case "tags":
				return ec.fieldContext_Template_tags(ctx, field)
			case "isPublic":
				return ec.fieldContext_Template_isPublic(ctx, field)
			case "usageCount":
				return ec.fieldContext_Template_usageCount(ctx, field)
			case "createdBy":
				return ec.fieldContext_Template_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Template_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Template_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Template", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_templates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_template(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_template,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Template(ctx, fc.Args["id"].(string))
		},
		nil,
		ec.marshalOTemplate2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_template(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Template_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Template_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Template_name(ctx, field)
			case "description":
				return ec.fieldContext_Template_description(ctx, field)
			case "category":
				return ec.fieldContext_Template_category(ctx, field)
			case "definition":
				return ec.fieldContext_Template_definition(ctx, field)
			case "tags":
				return ec.fieldContext_Template_tags(ctx, field)
			case "isPublic":
				return ec.fieldContext_Template_isPublic(ctx, field)
			case "usageCount":
				return ec.fieldContext_Template_usageCount(ctx, field)
			case "createdBy":
				return ec.fieldContext_Template_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Template_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Template_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Template", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_template_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_id(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_tenantId(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_tenantId,
		func(ctx context.Context) (any, error) {
			return obj.TenantID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_tenantId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_workflowId(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_workflowId,
		func(ctx context.Context) (any, error) {
			return obj.WorkflowID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_workflowId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_name(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_cronExpression(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_cronExpression,
		func(ctx context.Context) (any, error) {
			return obj.CronExpression, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_cronExpression(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_timezone(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_timezone,
		func(ctx context.Context) (any, error) {
			return obj.Timezone, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_enabled(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_nextRunAt(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_nextRunAt,
		func(ctx context.Context) (any, error) {
			return obj.NextRunAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Schedule_nextRunAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_lastRunAt(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_lastRunAt,
		func(ctx context.Context) (any, error) {
			return obj.LastRunAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Schedule_lastRunAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_lastExecutionId(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_lastExecutionId,
		func(ctx context.Context) (any, error) {
			return obj.LastExecutionID, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Schedule_lastExecutionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_createdBy(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_createdBy,
		func(ctx context.Context) (any, error) {
			return obj.CreatedBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_createdAt(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Schedule_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Schedule_workflow(ctx context.Context, field graphql.CollectedField, obj *Schedule) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Schedule_workflow,
		func(ctx context.Context) (any, error) {
			return obj.Workflow, nil
		},
		nil,
		ec.marshalOWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Schedule_workflow(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Schedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_id(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StepExecution_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_executionId(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_executionId,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StepExecution_executionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_nodeId(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_nodeId,
		func(ctx context.Context) (any, error) {
			return obj.NodeID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StepExecution_nodeId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_nodeType(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_nodeType,
		func(ctx context.Context) (any, error) {
			return obj.NodeType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StepExecution_nodeType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_status(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StepExecution_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_inputData(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_inputData,
		func(ctx context.Context) (any, error) {
			return obj.InputData, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepExecution_inputData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_outputData(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_outputData,
		func(ctx context.Context) (any, error) {
			return obj.OutputData, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepExecution_outputData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_errorMessage(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_errorMessage,
		func(ctx context.Context) (any, error) {
			return obj.ErrorMessage, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepExecution_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_retryCount(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_retryCount,
		func(ctx context.Context) (any, error) {
			return obj.RetryCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StepExecution_retryCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_startedAt(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_startedAt,
		func(ctx context.Context) (any, error) {
			return obj.StartedAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepExecution_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_completedAt(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_completedAt,
		func(ctx context.Context) (any, error) {
			return obj.CompletedAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepExecution_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepExecution_durationMs(ctx context.Context, field graphql.CollectedField, obj *StepExecution) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepExecution_durationMs,
		func(ctx context.Context) (any, error) {
			return obj.DurationMs, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepExecution_durationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepExecution",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_executionUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_executionUpdated,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().ExecutionUpdated(ctx, fc.Args["workflowId"].(*string))
		},
		nil,
		ec.marshalNExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_executionUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Execution_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Execution_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Execution_workflowId(ctx, field)
			case "workflowVersion":
				return ec.fieldContext_Execution_workflowVersion(ctx, field)
			case "status":
				return ec.fieldContext_Execution_status(ctx, field)
			case "triggerType":
				return ec.fieldContext_Execution_triggerType(ctx, field)
			case "triggerData":
				return ec.fieldContext_Execution_triggerData(ctx, field)
			case "outputData":
				return ec.fieldContext_Execution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_Execution_errorMessage(ctx, field)
			case "parentExecutionId":
				return ec.fieldContext_Execution_parentExecutionId(ctx, field)
			case "executionDepth":
				return ec.fieldContext_Execution_executionDepth(ctx, field)
			case "startedAt":
				return ec.fieldContext_Execution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Execution_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Execution_createdAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Execution_workflow(ctx, field)
			case "steps":
				return ec.fieldContext_Execution_steps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Execution", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_executionUpdated_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Template_id(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_tenantId(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_tenantId,
		func(ctx context.Context) (any, error) {
			return obj.TenantID, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Template_tenantId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_name(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_description(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_category(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_category,
		func(ctx context.Context) (any, error) {
			return obj.Category, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_definition(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_definition,
		func(ctx context.Context) (any, error) {
			return obj.Definition, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_definition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_tags(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_tags,
		func(ctx context.Context) (any, error) {
			return obj.Tags, nil
		},
		nil,
		ec.marshalOString2ᚕstringᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Template_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_isPublic(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_isPublic,
		func(ctx context.Context) (any, error) {
			return obj.IsPublic, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_isPublic(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_usageCount(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_usageCount,
		func(ctx context.Context) (any, error) {
			return obj.UsageCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_usageCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_createdBy(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_createdBy,
		func(ctx context.Context) (any, error) {
			return obj.CreatedBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_createdAt(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Template_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Template) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Template_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Template_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Template",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_id(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_tenantId(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_tenantId,
		func(ctx context.Context) (any, error) {
			return obj.TenantID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_tenantId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_workflowId(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_workflowId,
		func(ctx context.Context) (any, error) {
			return obj.WorkflowID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_workflowId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_nodeId(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_nodeId,
		func(ctx context.Context) (any, error) {
			return obj.NodeID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_nodeId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_name(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_path(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_secret(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_authType(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_authType,
		func(ctx context.Context) (any, error) {
			return obj.AuthType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_authType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_description(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_priority(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_priority,
		func(ctx context.Context) (any, error) {
			return obj.Priority, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_enabled(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_triggerCount(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_triggerCount,
		func(ctx context.Context) (any, error) {
			return obj.TriggerCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_triggerCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_lastTriggeredAt(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_lastTriggeredAt,
		func(ctx context.Context) (any, error) {
			return obj.LastTriggeredAt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Webhook_lastTriggeredAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_createdAt(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_workflow(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_workflow,
		func(ctx context.Context) (any, error) {
			return obj.Workflow, nil
		},
		nil,
		ec.marshalOWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Webhook_workflow(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_events(ctx context.Context, field graphql.CollectedField, obj *Webhook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_events,
		func(ctx context.Context) (any, error) {
			return obj.Events, nil
		},
		nil,
		ec.marshalOWebhookEvent2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookEventᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Webhook_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WebhookEvent_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_WebhookEvent_tenantId(ctx, field)
			case "webhookId":
				return ec.fieldContext_WebhookEvent_webhookId(ctx, field)
			case "executionId":
				return ec.fieldContext_WebhookEvent_executionId(ctx, field)
			case "requestMethod":
				return ec.fieldContext_WebhookEvent_requestMethod(ctx, field)
			case "requestHeaders":
				return ec.fieldContext_WebhookEvent_requestHeaders(ctx, field)
			case "requestBody":
				return ec.fieldContext_WebhookEvent_requestBody(ctx, field)
			case "responseStatus":
				return ec.fieldContext_WebhookEvent_responseStatus(ctx, field)
			case "processingTimeMs":
				return ec.fieldContext_WebhookEvent_processingTimeMs(ctx, field)
			case "status":
				return ec.fieldContext_WebhookEvent_status(ctx, field)
			case "errorMessage":
				return ec.fieldContext_WebhookEvent_errorMessage(ctx, field)
			case "filteredReason":
				return ec.fieldContext_WebhookEvent_filteredReason(ctx, field)
			case "replayCount":
				return ec.fieldContext_WebhookEvent_replayCount(ctx, field)
			case "sourceEventId":
				return ec.fieldContext_WebhookEvent_sourceEventId(ctx, field)
			case "metadata":
				return ec.fieldContext_WebhookEvent_metadata(ctx, field)
			case "createdAt":
				return ec.fieldContext_WebhookEvent_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Webhook_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_id(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_tenantId(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_tenantId,
		func(ctx context.Context) (any, error) {
			return obj.TenantID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_tenantId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_webhookId(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_webhookId,
		func(ctx context.Context) (any, error) {
			return obj.WebhookID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_webhookId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_executionId(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_executionId,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionID, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_executionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_requestMethod(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_requestMethod,
		func(ctx context.Context) (any, error) {
			return obj.RequestMethod, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_requestMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_requestHeaders(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_requestHeaders,
		func(ctx context.Context) (any, error) {
			return obj.RequestHeaders, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_requestHeaders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_requestBody(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_requestBody,
		func(ctx context.Context) (any, error) {
			return obj.RequestBody, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_requestBody(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_responseStatus(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_responseStatus,
		func(ctx context.Context) (any, error) {
			return obj.ResponseStatus, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_responseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_processingTimeMs(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_processingTimeMs,
		func(ctx context.Context) (any, error) {
			return obj.ProcessingTimeMs, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_processingTimeMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_status(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_errorMessage(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_errorMessage,
		func(ctx context.Context) (any, error) {
			return obj.ErrorMessage, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_filteredReason(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_filteredReason,
		func(ctx context.Context) (any, error) {
			return obj.FilteredReason, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_filteredReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_replayCount(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_replayCount,
		func(ctx context.Context) (any, error) {
			return obj.ReplayCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_replayCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_sourceEventId(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_sourceEventId,
		func(ctx context.Context) (any, error) {
			return obj.SourceEventID, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_sourceEventId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_metadata(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_metadata,
		func(ctx context.Context) (any, error) {
			return obj.Metadata, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookEvent_createdAt(ctx context.Context, field graphql.CollectedField, obj *WebhookEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookEvent_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookEvent_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_id(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_tenantId(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_tenantId,
		func(ctx context.Context) (any, error) {
			return obj.TenantID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_tenantId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_name(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_description(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_definition(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_definition,
		func(ctx context.Context) (any, error) {
			return obj.Definition, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_definition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_status(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_version(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_createdBy(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_createdBy,
		func(ctx context.Context) (any, error) {
			return obj.CreatedBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_createdAt(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_updatedAt(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Workflow_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_executions(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_executions,
		func(ctx context.Context) (any, error) {
			return obj.Executions, nil
		},
		nil,
		ec.marshalOExecution2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Workflow_executions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Execution_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Execution_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Execution_workflowId(ctx, field)
			case "workflowVersion":
				return ec.fieldContext_Execution_workflowVersion(ctx, field)
			case "status":
				return ec.fieldContext_Execution_status(ctx, field)
			case "triggerType":
				return ec.fieldContext_Execution_triggerType(ctx, field)
			case "triggerData":
				return ec.fieldContext_Execution_triggerData(ctx, field)
			case "outputData":
				return ec.fieldContext_Execution_outputData(ctx, field)
			case "errorMessage":
				return ec.fieldContext_Execution_errorMessage(ctx, field)
			case "parentExecutionId":
				return ec.fieldContext_Execution_parentExecutionId(ctx, field)
			case "executionDepth":
				return ec.fieldContext_Execution_executionDepth(ctx, field)
			case "startedAt":
				return ec.fieldContext_Execution_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_Execution_completedAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Execution_createdAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Execution_workflow(ctx, field)
			case "steps":
				return ec.fieldContext_Execution_steps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Execution", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Workflow_executions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_schedules(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_schedules,
		func(ctx context.Context) (any, error) {
			return obj.Schedules, nil
		},
		nil,
		ec.marshalOSchedule2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐScheduleᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Workflow_schedules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Schedule_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Schedule_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Schedule_workflowId(ctx, field)
			case "name":
				return ec.fieldContext_Schedule_name(ctx, field)
			case "cronExpression":
				return ec.fieldContext_Schedule_cronExpression(ctx, field)
			case "timezone":
				return ec.fieldContext_Schedule_timezone(ctx, field)
			case "enabled":
				return ec.fieldContext_Schedule_enabled(ctx, field)
			case "nextRunAt":
				return ec.fieldContext_Schedule_nextRunAt(ctx, field)
			case "lastRunAt":
				return ec.fieldContext_Schedule_lastRunAt(ctx, field)
			case "lastExecutionId":
				return ec.fieldContext_Schedule_lastExecutionId(ctx, field)
			case "createdBy":
				return ec.fieldContext_Schedule_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Schedule_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Schedule_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Schedule_workflow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Schedule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Workflow_webhooks(ctx context.Context, field graphql.CollectedField, obj *Workflow) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Workflow_webhooks,
		func(ctx context.Context) (any, error) {
			return obj.Webhooks, nil
		},
		nil,
		ec.marshalOWebhook2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Workflow_webhooks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Webhook_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Webhook_tenantId(ctx, field)
			case "workflowId":
				return ec.fieldContext_Webhook_workflowId(ctx, field)
			case "nodeId":
				return ec.fieldContext_Webhook_nodeId(ctx, field)
			case "name":
				return ec.fieldContext_Webhook_name(ctx, field)
			case "path":
				return ec.fieldContext_Webhook_path(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			case "authType":
				return ec.fieldContext_Webhook_authType(ctx, field)
			case "description":
				return ec.fieldContext_Webhook_description(ctx, field)
			case "priority":
				return ec.fieldContext_Webhook_priority(ctx, field)
			case "enabled":
				return ec.fieldContext_Webhook_enabled(ctx, field)
			case "triggerCount":
				return ec.fieldContext_Webhook_triggerCount(ctx, field)
			case "lastTriggeredAt":
				return ec.fieldContext_Webhook_lastTriggeredAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Webhook_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Webhook_updatedAt(ctx, field)
			case "workflow":
				return ec.fieldContext_Webhook_workflow(ctx, field)
			case "events":
				return ec.fieldContext_Webhook_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkflowConnection_data(ctx context.Context, field graphql.CollectedField, obj *WorkflowConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkflowConnection_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNWorkflow2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflowᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WorkflowConnection_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkflowConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "tenantId":
				return ec.fieldContext_Workflow_tenantId(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "description":
				return ec.fieldContext_Workflow_description(ctx, field)
			case "definition":
				return ec.fieldContext_Workflow_definition(ctx, field)
			case "status":
				return ec.fieldContext_Workflow_status(ctx, field)
			case "version":
				return ec.fieldContext_Workflow_version(ctx, field)
			case "createdBy":
				return ec.fieldContext_Workflow_createdBy(ctx, field)
			case "createdAt":
				return ec.fieldContext_Workflow_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Workflow_updatedAt(ctx, field)
			case "executions":
				return ec.fieldContext_Workflow_executions(ctx, field)
			case "schedules":
				return ec.fieldContext_Workflow_schedules(ctx, field)
			case "webhooks":
				return ec.fieldContext_Workflow_webhooks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkflowConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *WorkflowConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkflowConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WorkflowConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkflowConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkflowConnection_hasMore(ctx context.Context, field graphql.CollectedField, obj *WorkflowConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkflowConnection_hasMore,
		func(ctx context.Context) (any, error) {
			return obj.HasMore, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WorkflowConnection_hasMore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkflowConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateScheduleInput(ctx context.Context, obj any) (CreateScheduleInput, error) {
	var it CreateScheduleInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cronExpression", "timezone", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cronExpression":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cronExpression"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CronExpression = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTemplateInput(ctx context.Context, obj any) (CreateTemplateInput, error) {
	var it CreateTemplateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "category", "definition", "tags", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "definition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definition"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Definition = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateWebhookInput(ctx context.Context, obj any) (CreateWebhookInput, error) {
	var it CreateWebhookInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"workflowId", "nodeId", "name", "authType", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "workflowId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workflowId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkflowID = data
		case "nodeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nodeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NodeID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "authType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthType = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateWorkflowInput(ctx context.Context, obj any) (CreateWorkflowInput, error) {
	var it CreateWorkflowInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "definition"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "definition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definition"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Definition = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateScheduleInput(ctx context.Context, obj any) (UpdateScheduleInput, error) {
	var it UpdateScheduleInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cronExpression", "timezone", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cronExpression":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cronExpression"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CronExpression = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTemplateInput(ctx context.Context, obj any) (UpdateTemplateInput, error) {
	var it UpdateTemplateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "category", "definition", "tags", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "category":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Category = data
		case "definition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definition"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Definition = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateWebhookInput(ctx context.Context, obj any) (UpdateWebhookInput, error) {
	var it UpdateWebhookInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "authType", "description", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "authType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthType = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateWorkflowInput(ctx context.Context, obj any) (UpdateWorkflowInput, error) {
	var it UpdateWorkflowInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "definition", "status"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "definition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("definition"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Definition = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var executionImplementors = []string{"Execution"}

func (ec *executionContext) _Execution(ctx context.Context, sel ast.SelectionSet, obj *Execution) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, executionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Execution")
		case "id":
			out.Values[i] = ec._Execution_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Execution_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflowId":
			out.Values[i] = ec._Execution_workflowId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflowVersion":
			out.Values[i] = ec._Execution_workflowVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Execution_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerType":
			out.Values[i] = ec._Execution_triggerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerData":
			out.Values[i] = ec._Execution_triggerData(ctx, field, obj)
		case "outputData":
			out.Values[i] = ec._Execution_outputData(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._Execution_errorMessage(ctx, field, obj)
		case "parentExecutionId":
			out.Values[i] = ec._Execution_parentExecutionId(ctx, field, obj)
		case "executionDepth":
			out.Values[i] = ec._Execution_executionDepth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._Execution_startedAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._Execution_completedAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Execution_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflow":
			out.Values[i] = ec._Execution_workflow(ctx, field, obj)
		case "steps":
			out.Values[i] = ec._Execution_steps(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var executionConnectionImplementors = []string{"ExecutionConnection"}

func (ec *executionContext) _ExecutionConnection(ctx context.Context, sel ast.SelectionSet, obj *ExecutionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, executionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExecutionConnection")
		case "data":
			out.Values[i] = ec._ExecutionConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ExecutionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasMore":
			out.Values[i] = ec._ExecutionConnection_hasMore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cursor":
			out.Values[i] = ec._ExecutionConnection_cursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createWorkflow":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createWorkflow(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateWorkflow":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateWorkflow(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWorkflow":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWorkflow(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executeWorkflow":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_executeWorkflow(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelExecution":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelExecution(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWebhook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWebhook(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regenerateWebhookSecret":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_regenerateWebhookSecret(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createSchedule":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSchedule(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSchedule":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSchedule(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSchedule":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSchedule(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTemplate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTemplate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "workflows":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_workflows(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "workflow":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_workflow(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "executions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_executions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "execution":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_execution(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "webhooks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_webhooks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "webhook":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_webhook(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "schedules":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_schedules(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "schedule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_schedule(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "templates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_templates(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "template":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_template(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var scheduleImplementors = []string{"Schedule"}

func (ec *executionContext) _Schedule(ctx context.Context, sel ast.SelectionSet, obj *Schedule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scheduleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Schedule")
		case "id":
			out.Values[i] = ec._Schedule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Schedule_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflowId":
			out.Values[i] = ec._Schedule_workflowId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Schedule_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cronExpression":
			out.Values[i] = ec._Schedule_cronExpression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timezone":
			out.Values[i] = ec._Schedule_timezone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._Schedule_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextRunAt":
			out.Values[i] = ec._Schedule_nextRunAt(ctx, field, obj)
		case "lastRunAt":
			out.Values[i] = ec._Schedule_lastRunAt(ctx, field, obj)
		case "lastExecutionId":
			out.Values[i] = ec._Schedule_lastExecutionId(ctx, field, obj)
		case "createdBy":
			out.Values[i] = ec._Schedule_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Schedule_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Schedule_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflow":
			out.Values[i] = ec._Schedule_workflow(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stepExecutionImplementors = []string{"StepExecution"}

func (ec *executionContext) _StepExecution(ctx context.Context, sel ast.SelectionSet, obj *StepExecution) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepExecutionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepExecution")
		case "id":
			out.Values[i] = ec._StepExecution_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executionId":
			out.Values[i] = ec._StepExecution_executionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodeId":
			out.Values[i] = ec._StepExecution_nodeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodeType":
			out.Values[i] = ec._StepExecution_nodeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._StepExecution_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "inputData":
			out.Values[i] = ec._StepExecution_inputData(ctx, field, obj)
		case "outputData":
			out.Values[i] = ec._StepExecution_outputData(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._StepExecution_errorMessage(ctx, field, obj)
		case "retryCount":
			out.Values[i] = ec._StepExecution_retryCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._StepExecution_startedAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._StepExecution_completedAt(ctx, field, obj)
		case "durationMs":
			out.Values[i] = ec._StepExecution_durationMs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		graphql.AddErrorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "executionUpdated":
		return ec._Subscription_executionUpdated(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var templateImplementors = []string{"Template"}

func (ec *executionContext) _Template(ctx context.Context, sel ast.SelectionSet, obj *Template) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, templateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Template")
		case "id":
			out.Values[i] = ec._Template_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Template_tenantId(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Template_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Template_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "category":
			out.Values[i] = ec._Template_category(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "definition":
			out.Values[i] = ec._Template_definition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tags":
			out.Values[i] = ec._Template_tags(ctx, field, obj)
		case "isPublic":
			out.Values[i] = ec._Template_isPublic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "usageCount":
			out.Values[i] = ec._Template_usageCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdBy":
			out.Values[i] = ec._Template_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Template_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Template_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *Webhook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "id":
			out.Values[i] = ec._Webhook_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Webhook_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflowId":
			out.Values[i] = ec._Webhook_workflowId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nodeId":
			out.Values[i] = ec._Webhook_nodeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Webhook_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Webhook_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._Webhook_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "authType":
			out.Values[i] = ec._Webhook_authType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Webhook_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._Webhook_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._Webhook_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerCount":
			out.Values[i] = ec._Webhook_triggerCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastTriggeredAt":
			out.Values[i] = ec._Webhook_lastTriggeredAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Webhook_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Webhook_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workflow":
			out.Values[i] = ec._Webhook_workflow(ctx, field, obj)
		case "events":
			out.Values[i] = ec._Webhook_events(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookEventImplementors = []string{"WebhookEvent"}

func (ec *executionContext) _WebhookEvent(ctx context.Context, sel ast.SelectionSet, obj *WebhookEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookEvent")
		case "id":
			out.Values[i] = ec._WebhookEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._WebhookEvent_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "webhookId":
			out.Values[i] = ec._WebhookEvent_webhookId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executionId":
			out.Values[i] = ec._WebhookEvent_executionId(ctx, field, obj)
		case "requestMethod":
			out.Values[i] = ec._WebhookEvent_requestMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestHeaders":
			out.Values[i] = ec._WebhookEvent_requestHeaders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestBody":
			out.Values[i] = ec._WebhookEvent_requestBody(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "responseStatus":
			out.Values[i] = ec._WebhookEvent_responseStatus(ctx, field, obj)
		case "processingTimeMs":
			out.Values[i] = ec._WebhookEvent_processingTimeMs(ctx, field, obj)
		case "status":
			out.Values[i] = ec._WebhookEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorMessage":
			out.Values[i] = ec._WebhookEvent_errorMessage(ctx, field, obj)
		case "filteredReason":
			out.Values[i] = ec._WebhookEvent_filteredReason(ctx, field, obj)
		case "replayCount":
			out.Values[i] = ec._WebhookEvent_replayCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sourceEventId":
			out.Values[i] = ec._WebhookEvent_sourceEventId(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._WebhookEvent_metadata(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._WebhookEvent_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workflowImplementors = []string{"Workflow"}

func (ec *executionContext) _Workflow(ctx context.Context, sel ast.SelectionSet, obj *Workflow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Workflow")
		case "id":
			out.Values[i] = ec._Workflow_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tenantId":
			out.Values[i] = ec._Workflow_tenantId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Workflow_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Workflow_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "definition":
			out.Values[i] = ec._Workflow_definition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Workflow_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Workflow_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdBy":
			out.Values[i] = ec._Workflow_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Workflow_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Workflow_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "executions":
			out.Values[i] = ec._Workflow_executions(ctx, field, obj)
		case "schedules":
			out.Values[i] = ec._Workflow_schedules(ctx, field, obj)
		case "webhooks":
			out.Values[i] = ec._Workflow_webhooks(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workflowConnectionImplementors = []string{"WorkflowConnection"}

func (ec *executionContext) _WorkflowConnection(ctx context.Context, sel ast.SelectionSet, obj *WorkflowConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkflowConnection")
		case "data":
			out.Values[i] = ec._WorkflowConnection_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._WorkflowConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasMore":
			out.Values[i] = ec._WorkflowConnection_hasMore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateScheduleInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateScheduleInput(ctx context.Context, v any) (CreateScheduleInput, error) {
	res, err := ec.unmarshalInputCreateScheduleInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTemplateInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateTemplateInput(ctx context.Context, v any) (CreateTemplateInput, error) {
	res, err := ec.unmarshalInputCreateTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateWebhookInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateWebhookInput(ctx context.Context, v any) (CreateWebhookInput, error) {
	res, err := ec.unmarshalInputCreateWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateWorkflowInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐCreateWorkflowInput(ctx context.Context, v any) (CreateWorkflowInput, error) {
	res, err := ec.unmarshalInputCreateWorkflowInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNExecution2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution(ctx context.Context, sel ast.SelectionSet, v Execution) graphql.Marshaler {
	return ec._Execution(ctx, sel, &v)
}

func (ec *executionContext) marshalNExecution2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionᚄ(ctx context.Context, sel ast.SelectionSet, v []*Execution) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution(ctx context.Context, sel ast.SelectionSet, v *Execution) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Execution(ctx, sel, v)
}

func (ec *executionContext) marshalNExecutionConnection2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionConnection(ctx context.Context, sel ast.SelectionSet, v ExecutionConnection) graphql.Marshaler {
	return ec._ExecutionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNExecutionConnection2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionConnection(ctx context.Context, sel ast.SelectionSet, v *ExecutionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExecutionConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSchedule2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule(ctx context.Context, sel ast.SelectionSet, v Schedule) graphql.Marshaler {
	return ec._Schedule(ctx, sel, &v)
}

func (ec *executionContext) marshalNSchedule2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐScheduleᚄ(ctx context.Context, sel ast.SelectionSet, v []*Schedule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule(ctx context.Context, sel ast.SelectionSet, v *Schedule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Schedule(ctx, sel, v)
}

func (ec *executionContext) marshalNStepExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐStepExecution(ctx context.Context, sel ast.SelectionSet, v *StepExecution) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StepExecution(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTemplate2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate(ctx context.Context, sel ast.SelectionSet, v Template) graphql.Marshaler {
	return ec._Template(ctx, sel, &v)
}

func (ec *executionContext) marshalNTemplate2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplateᚄ(ctx context.Context, sel ast.SelectionSet, v []*Template) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTemplate2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTemplate2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate(ctx context.Context, sel ast.SelectionSet, v *Template) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Template(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateScheduleInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateScheduleInput(ctx context.Context, v any) (UpdateScheduleInput, error) {
	res, err := ec.unmarshalInputUpdateScheduleInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTemplateInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateTemplateInput(ctx context.Context, v any) (UpdateTemplateInput, error) {
	res, err := ec.unmarshalInputUpdateTemplateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateWebhookInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateWebhookInput(ctx context.Context, v any) (UpdateWebhookInput, error) {
	res, err := ec.unmarshalInputUpdateWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateWorkflowInput2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐUpdateWorkflowInput(ctx context.Context, v any) (UpdateWorkflowInput, error) {
	res, err := ec.unmarshalInputUpdateWorkflowInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWebhook2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook(ctx context.Context, sel ast.SelectionSet, v Webhook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhook2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookᚄ(ctx context.Context, sel ast.SelectionSet, v []*Webhook) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook(ctx context.Context, sel ast.SelectionSet, v *Webhook) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Webhook(ctx, sel, v)
}

func (ec *executionContext) marshalNWebhookEvent2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookEvent(ctx context.Context, sel ast.SelectionSet, v *WebhookEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WebhookEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkflow2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v Workflow) graphql.Marshaler {
	return ec._Workflow(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflow2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflowᚄ(ctx context.Context, sel ast.SelectionSet, v []*Workflow) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v *Workflow) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Workflow(ctx, sel, v)
}

func (ec *executionContext) marshalNWorkflowConnection2githubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflowConnection(ctx context.Context, sel ast.SelectionSet, v WorkflowConnection) graphql.Marshaler {
	return ec._WorkflowConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflowConnection2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflowConnection(ctx context.Context, sel ast.SelectionSet, v *WorkflowConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorkflowConnection(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOExecution2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecutionᚄ(ctx context.Context, sel ast.SelectionSet, v []*Execution) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐExecution(ctx context.Context, sel ast.SelectionSet, v *Execution) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Execution(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOSchedule2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐScheduleᚄ(ctx context.Context, sel ast.SelectionSet, v []*Schedule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSchedule2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐSchedule(ctx context.Context, sel ast.SelectionSet, v *Schedule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Schedule(ctx, sel, v)
}

func (ec *executionContext) marshalOStepExecution2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐStepExecutionᚄ(ctx context.Context, sel ast.SelectionSet, v []*StepExecution) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStepExecution2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐStepExecution(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTemplate2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐTemplate(ctx context.Context, sel ast.SelectionSet, v *Template) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Template(ctx, sel, v)
}

func (ec *executionContext) marshalOWebhook2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookᚄ(ctx context.Context, sel ast.SelectionSet, v []*Webhook) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWebhook2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhook(ctx context.Context, sel ast.SelectionSet, v *Webhook) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Webhook(ctx, sel, v)
}

func (ec *executionContext) marshalOWebhookEvent2ᚕᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*WebhookEvent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhookEvent2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWebhookEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWorkflow2ᚖgithubᚗcomᚋgoraxᚋgoraxᚋinternalᚋgraphqlᚋgeneratedᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v *Workflow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workflow(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
