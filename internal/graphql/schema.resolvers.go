package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/gorax/gorax/internal/graphql/generated"
	"github.com/gorax/gorax/internal/schedule"
	"github.com/gorax/gorax/internal/template"
	"github.com/gorax/gorax/internal/workflow"
)

// CreateWorkflow is the resolver for the createWorkflow field.
func (r *mutationResolver) CreateWorkflow(ctx context.Context, input generated.CreateWorkflowInput) (*generated.Workflow, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := getUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	createInput := workflow.CreateWorkflowInput{
		Name:       input.Name,
		Definition: json.RawMessage(input.Definition),
	}

	if input.Description != nil {
		createInput.Description = *input.Description
	}

	// Create workflow via service
	wf, err := r.WorkflowService.Create(ctx, tenantID, userID, createInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create workflow: %w", err)
	}

	return toGraphQLWorkflow(wf)
}

// UpdateWorkflow is the resolver for the updateWorkflow field.
func (r *mutationResolver) UpdateWorkflow(ctx context.Context, id string, input generated.UpdateWorkflowInput) (*generated.Workflow, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	updateInput := workflow.UpdateWorkflowInput{}

	if input.Name != nil {
		updateInput.Name = *input.Name
	}

	if input.Description != nil {
		updateInput.Description = *input.Description
	}

	if input.Status != nil {
		updateInput.Status = *input.Status
	}

	if input.Definition != nil {
		defJSON := json.RawMessage(*input.Definition)
		updateInput.Definition = defJSON
	}

	// Update workflow via service
	wf, err := r.WorkflowService.Update(ctx, tenantID, id, updateInput)
	if err != nil {
		return nil, fmt.Errorf("failed to update workflow: %w", err)
	}

	return toGraphQLWorkflow(wf)
}

// DeleteWorkflow is the resolver for the deleteWorkflow field.
func (r *mutationResolver) DeleteWorkflow(ctx context.Context, id string) (bool, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return false, err
	}

	if err := r.WorkflowService.Delete(ctx, tenantID, id); err != nil {
		return false, fmt.Errorf("failed to delete workflow: %w", err)
	}

	return true, nil
}

// ExecuteWorkflow is the resolver for the executeWorkflow field.
func (r *mutationResolver) ExecuteWorkflow(ctx context.Context, id string, input *string) (*generated.Execution, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	var triggerData []byte
	if input != nil {
		triggerData = []byte(*input)
	}

	// Execute workflow via service
	execution, err := r.WorkflowService.Execute(ctx, tenantID, id, "manual", triggerData)
	if err != nil {
		return nil, fmt.Errorf("failed to execute workflow: %w", err)
	}

	return toGraphQLExecution(execution)
}

// CancelExecution is the resolver for the cancelExecution field.
func (r *mutationResolver) CancelExecution(ctx context.Context, id string) (*generated.Execution, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Cancel execution via service
	execution, err := r.WorkflowService.CancelExecution(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to cancel execution: %w", err)
	}

	return toGraphQLExecution(execution)
}

// CreateWebhook is the resolver for the createWebhook field.
func (r *mutationResolver) CreateWebhook(ctx context.Context, input generated.CreateWebhookInput) (*generated.Webhook, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Set default auth type if not provided
	authType := "signature"
	if input.AuthType != nil {
		authType = *input.AuthType
	}

	// Set default description and priority
	description := ""
	if input.Description != nil {
		description = *input.Description
	}
	priority := 0

	// Create webhook via service
	webhook, err := r.WebhookService.CreateWithDetails(ctx, tenantID, input.WorkflowID, input.Name, "", authType, description, priority)
	if err != nil {
		return nil, fmt.Errorf("failed to create webhook: %w", err)
	}

	return toGraphQLWebhook(webhook)
}

// UpdateWebhook is the resolver for the updateWebhook field.
func (r *mutationResolver) UpdateWebhook(ctx context.Context, id string, input generated.UpdateWebhookInput) (*generated.Webhook, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Get existing webhook to preserve unchanged fields
	existing, err := r.WebhookService.GetByID(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get webhook: %w", err)
	}

	// Build update parameters with defaults from existing webhook
	name := existing.Name
	if input.Name != nil {
		name = *input.Name
	}

	authType := existing.AuthType
	if input.AuthType != nil {
		authType = *input.AuthType
	}

	description := existing.Description
	if input.Description != nil {
		description = *input.Description
	}

	enabled := existing.Enabled
	if input.Enabled != nil {
		enabled = *input.Enabled
	}

	// Update webhook via service
	webhook, err := r.WebhookService.Update(ctx, tenantID, id, name, authType, description, existing.Priority, enabled)
	if err != nil {
		return nil, fmt.Errorf("failed to update webhook: %w", err)
	}

	return toGraphQLWebhook(webhook)
}

// DeleteWebhook is the resolver for the deleteWebhook field.
func (r *mutationResolver) DeleteWebhook(ctx context.Context, id string) (bool, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return false, err
	}

	if err := r.WebhookService.DeleteByID(ctx, tenantID, id); err != nil {
		return false, fmt.Errorf("failed to delete webhook: %w", err)
	}

	return true, nil
}

// RegenerateWebhookSecret is the resolver for the regenerateWebhookSecret field.
func (r *mutationResolver) RegenerateWebhookSecret(ctx context.Context, id string) (*generated.Webhook, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Regenerate secret via service
	webhook, err := r.WebhookService.RegenerateSecret(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to regenerate webhook secret: %w", err)
	}

	return toGraphQLWebhook(webhook)
}

// CreateSchedule is the resolver for the createSchedule field.
func (r *mutationResolver) CreateSchedule(ctx context.Context, workflowID string, input generated.CreateScheduleInput) (*generated.Schedule, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := getUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	createInput := schedule.CreateScheduleInput{
		Name:           input.Name,
		CronExpression: input.CronExpression,
		Enabled:        input.Enabled != nil && *input.Enabled,
	}

	if input.Timezone != nil {
		createInput.Timezone = *input.Timezone
	}

	// Create schedule via service
	sched, err := r.ScheduleService.Create(ctx, tenantID, workflowID, userID, createInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create schedule: %w", err)
	}

	return toGraphQLSchedule(sched)
}

// UpdateSchedule is the resolver for the updateSchedule field.
func (r *mutationResolver) UpdateSchedule(ctx context.Context, id string, input generated.UpdateScheduleInput) (*generated.Schedule, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	updateInput := schedule.UpdateScheduleInput{
		Name:           input.Name,
		CronExpression: input.CronExpression,
		Timezone:       input.Timezone,
		Enabled:        input.Enabled,
	}

	// Update schedule via service
	sched, err := r.ScheduleService.Update(ctx, tenantID, id, updateInput)
	if err != nil {
		return nil, fmt.Errorf("failed to update schedule: %w", err)
	}

	return toGraphQLSchedule(sched)
}

// DeleteSchedule is the resolver for the deleteSchedule field.
func (r *mutationResolver) DeleteSchedule(ctx context.Context, id string) (bool, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return false, err
	}

	if err := r.ScheduleService.Delete(ctx, tenantID, id); err != nil {
		return false, fmt.Errorf("failed to delete schedule: %w", err)
	}

	return true, nil
}

// CreateTemplate is the resolver for the createTemplate field.
func (r *mutationResolver) CreateTemplate(ctx context.Context, input generated.CreateTemplateInput) (*generated.Template, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := getUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	createInput := template.CreateTemplateInput{
		Name:       input.Name,
		Category:   input.Category,
		Definition: json.RawMessage(input.Definition),
		IsPublic:   input.IsPublic != nil && *input.IsPublic,
	}

	if input.Description != nil {
		createInput.Description = *input.Description
	}

	if input.Tags != nil {
		createInput.Tags = input.Tags
	}

	// Create template via service
	tmpl, err := r.TemplateService.CreateTemplate(ctx, tenantID, userID, createInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create template: %w", err)
	}

	return toGraphQLTemplate(tmpl)
}

// UpdateTemplate is the resolver for the updateTemplate field.
func (r *mutationResolver) UpdateTemplate(ctx context.Context, id string, input generated.UpdateTemplateInput) (*generated.Template, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	updateInput := template.UpdateTemplateInput{}

	if input.Name != nil {
		updateInput.Name = *input.Name
	}

	if input.Description != nil {
		updateInput.Description = *input.Description
	}

	if input.Category != nil {
		updateInput.Category = *input.Category
	}

	if input.Tags != nil {
		updateInput.Tags = input.Tags
	}

	if input.IsPublic != nil {
		updateInput.IsPublic = input.IsPublic
	}

	if input.Definition != nil {
		defJSON := json.RawMessage(*input.Definition)
		updateInput.Definition = defJSON
	}

	// Update template via service
	if err := r.TemplateService.UpdateTemplate(ctx, tenantID, id, updateInput); err != nil {
		return nil, fmt.Errorf("failed to update template: %w", err)
	}

	// Fetch updated template
	tmpl, err := r.TemplateService.GetTemplate(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get updated template: %w", err)
	}

	return toGraphQLTemplate(tmpl)
}

// DeleteTemplate is the resolver for the deleteTemplate field.
func (r *mutationResolver) DeleteTemplate(ctx context.Context, id string) (bool, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return false, err
	}

	if err := r.TemplateService.DeleteTemplate(ctx, tenantID, id); err != nil {
		return false, fmt.Errorf("failed to delete template: %w", err)
	}

	return true, nil
}

// Workflows is the resolver for the workflows field.
func (r *queryResolver) Workflows(ctx context.Context, limit *int, offset *int) (*generated.WorkflowConnection, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Set defaults
	defaultLimit := 20
	defaultOffset := 0
	if limit != nil {
		defaultLimit = *limit
	}
	if offset != nil {
		defaultOffset = *offset
	}

	// List workflows via service
	workflows, err := r.WorkflowService.List(ctx, tenantID, defaultLimit, defaultOffset)
	if err != nil {
		return nil, fmt.Errorf("failed to list workflows: %w", err)
	}

	// Convert to GraphQL types
	gqlWorkflows, err := toGraphQLWorkflows(workflows)
	if err != nil {
		return nil, err
	}

	return &generated.WorkflowConnection{
		Data:       gqlWorkflows,
		TotalCount: len(gqlWorkflows),
		HasMore:    len(gqlWorkflows) == defaultLimit,
	}, nil
}

// Workflow is the resolver for the workflow field.
func (r *queryResolver) Workflow(ctx context.Context, id string) (*generated.Workflow, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Get workflow via service
	wf, err := r.WorkflowService.GetByID(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get workflow: %w", err)
	}

	return toGraphQLWorkflow(wf)
}

// Executions is the resolver for the executions field.
func (r *queryResolver) Executions(ctx context.Context, workflowID *string, status *string, limit *int, offset *int) (*generated.ExecutionConnection, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Set defaults
	defaultLimit := 20
	defaultOffset := 0
	wfID := ""
	if limit != nil {
		defaultLimit = *limit
	}
	if offset != nil {
		defaultOffset = *offset
	}
	if workflowID != nil {
		wfID = *workflowID
	}

	// List executions via service
	executions, err := r.WorkflowService.ListExecutions(ctx, tenantID, wfID, defaultLimit, defaultOffset)
	if err != nil {
		return nil, fmt.Errorf("failed to list executions: %w", err)
	}

	// Convert to GraphQL types
	gqlExecutions, err := toGraphQLExecutions(executions)
	if err != nil {
		return nil, err
	}

	return &generated.ExecutionConnection{
		Data:       gqlExecutions,
		TotalCount: len(gqlExecutions),
		HasMore:    len(gqlExecutions) == defaultLimit,
	}, nil
}

// Execution is the resolver for the execution field.
func (r *queryResolver) Execution(ctx context.Context, id string) (*generated.Execution, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Get execution via service
	exec, err := r.WorkflowService.GetExecution(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get execution: %w", err)
	}

	return toGraphQLExecution(exec)
}

// Webhooks is the resolver for the webhooks field.
func (r *queryResolver) Webhooks(ctx context.Context, limit *int, offset *int) ([]*generated.Webhook, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Set defaults
	defaultLimit := 20
	defaultOffset := 0
	if limit != nil {
		defaultLimit = *limit
	}
	if offset != nil {
		defaultOffset = *offset
	}

	// List webhooks via service
	webhooks, _, err := r.WebhookService.List(ctx, tenantID, defaultLimit, defaultOffset)
	if err != nil {
		return nil, fmt.Errorf("failed to list webhooks: %w", err)
	}

	return toGraphQLWebhooks(webhooks)
}

// Webhook is the resolver for the webhook field.
func (r *queryResolver) Webhook(ctx context.Context, id string) (*generated.Webhook, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Get webhook via service
	wh, err := r.WebhookService.GetByID(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get webhook: %w", err)
	}

	return toGraphQLWebhook(wh)
}

// Schedules is the resolver for the schedules field.
func (r *queryResolver) Schedules(ctx context.Context, workflowID *string, limit *int, offset *int) ([]*generated.Schedule, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Set defaults
	defaultLimit := 20
	defaultOffset := 0
	if limit != nil {
		defaultLimit = *limit
	}
	if offset != nil {
		defaultOffset = *offset
	}

	var schedules []*schedule.Schedule
	if workflowID != nil {
		// List schedules for specific workflow
		schedules, err = r.ScheduleService.List(ctx, tenantID, *workflowID, defaultLimit, defaultOffset)
	} else {
		// List all schedules - convert ScheduleWithWorkflow to Schedule
		schedulesWithWorkflow, err := r.ScheduleService.ListAll(ctx, tenantID, defaultLimit, defaultOffset)
		if err == nil {
			schedules = make([]*schedule.Schedule, len(schedulesWithWorkflow))
			for i, sw := range schedulesWithWorkflow {
				schedules[i] = &sw.Schedule
			}
		}
	}

	if err != nil {
		return nil, fmt.Errorf("failed to list schedules: %w", err)
	}

	return toGraphQLSchedules(schedules)
}

// Schedule is the resolver for the schedule field.
func (r *queryResolver) Schedule(ctx context.Context, id string) (*generated.Schedule, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Get schedule via service
	sched, err := r.ScheduleService.GetByID(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get schedule: %w", err)
	}

	return toGraphQLSchedule(sched)
}

// Templates is the resolver for the templates field.
func (r *queryResolver) Templates(ctx context.Context, category *string, limit *int, offset *int) ([]*generated.Template, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Create filter
	filter := template.TemplateFilter{}
	if category != nil {
		filter.Category = *category
	}

	// List templates via service
	templates, err := r.TemplateService.ListTemplates(ctx, tenantID, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to list templates: %w", err)
	}

	return toGraphQLTemplates(templates)
}

// Template is the resolver for the template field.
func (r *queryResolver) Template(ctx context.Context, id string) (*generated.Template, error) {
	tenantID, err := getTenantID(ctx)
	if err != nil {
		return nil, err
	}

	// Get template via service
	tmpl, err := r.TemplateService.GetTemplate(ctx, tenantID, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get template: %w", err)
	}

	return toGraphQLTemplate(tmpl)
}

// ExecutionUpdated is the resolver for the executionUpdated field.
func (r *subscriptionResolver) ExecutionUpdated(ctx context.Context, workflowID *string) (<-chan *generated.Execution, error) {
	// TODO: Implement execution subscription using WebSocket hub
	return nil, fmt.Errorf("not implemented: ExecutionUpdated subscription")
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
