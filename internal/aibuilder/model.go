package aibuilder

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// ConversationStatus represents the status of an AI builder conversation
type ConversationStatus string

const (
	ConversationStatusActive    ConversationStatus = "active"
	ConversationStatusCompleted ConversationStatus = "completed"
	ConversationStatusAbandoned ConversationStatus = "abandoned"
)

// IsValid checks if the conversation status is valid
func (s ConversationStatus) IsValid() bool {
	switch s {
	case ConversationStatusActive, ConversationStatusCompleted, ConversationStatusAbandoned:
		return true
	default:
		return false
	}
}

// MessageRole represents the role of a conversation message
type MessageRole string

const (
	MessageRoleUser      MessageRole = "user"
	MessageRoleAssistant MessageRole = "assistant"
	MessageRoleSystem    MessageRole = "system"
)

// IsValid checks if the message role is valid
func (r MessageRole) IsValid() bool {
	switch r {
	case MessageRoleUser, MessageRoleAssistant, MessageRoleSystem:
		return true
	default:
		return false
	}
}

// BuildRequest represents a request to generate a workflow from natural language
type BuildRequest struct {
	Description string            `json:"description"`
	Context     *BuildContext     `json:"context,omitempty"`
	Constraints *BuildConstraints `json:"constraints,omitempty"`
}

// Validate validates the build request
func (r *BuildRequest) Validate() error {
	if r.Description == "" {
		return errors.New("description is required")
	}
	if len(r.Description) < 10 {
		return errors.New("description must be at least 10 characters")
	}
	if r.Constraints != nil && r.Constraints.MaxNodes < 0 {
		return errors.New("max_nodes must be positive")
	}
	return nil
}

// BuildContext provides context about available resources for workflow generation
type BuildContext struct {
	AvailableCredentials  []string               `json:"available_credentials,omitempty"`
	AvailableIntegrations []string               `json:"available_integrations,omitempty"`
	ExistingWorkflows     []string               `json:"existing_workflows,omitempty"`
	CustomData            map[string]interface{} `json:"custom_data,omitempty"`
}

// HasCredential checks if a credential is available
func (c *BuildContext) HasCredential(name string) bool {
	for _, cred := range c.AvailableCredentials {
		if cred == name {
			return true
		}
	}
	return false
}

// HasIntegration checks if an integration is available
func (c *BuildContext) HasIntegration(name string) bool {
	for _, integ := range c.AvailableIntegrations {
		if integ == name {
			return true
		}
	}
	return false
}

// BuildConstraints defines constraints for workflow generation
type BuildConstraints struct {
	MaxNodes       int      `json:"max_nodes,omitempty"`
	AllowedTypes   []string `json:"allowed_types,omitempty"`
	ForbiddenTypes []string `json:"forbidden_types,omitempty"`
	RequireTrigger bool     `json:"require_trigger,omitempty"`
}

// IsTypeAllowed checks if a node type is allowed by constraints
func (c *BuildConstraints) IsTypeAllowed(nodeType string) bool {
	if len(c.AllowedTypes) == 0 {
		return true
	}
	for _, allowed := range c.AllowedTypes {
		if allowed == nodeType {
			return true
		}
	}
	return false
}

// BuildResult contains the result of a workflow generation request
type BuildResult struct {
	ConversationID   string             `json:"conversation_id"`
	Workflow         *GeneratedWorkflow `json:"workflow,omitempty"`
	Explanation      string             `json:"explanation"`
	Warnings         []string           `json:"warnings,omitempty"`
	Suggestions      []string           `json:"suggestions,omitempty"`
	PromptTokens     int                `json:"prompt_tokens,omitempty"`
	CompletionTokens int                `json:"completion_tokens,omitempty"`
}

// HasWarnings returns true if there are any warnings
func (r *BuildResult) HasWarnings() bool {
	return len(r.Warnings) > 0
}

// HasSuggestions returns true if there are any suggestions
func (r *BuildResult) HasSuggestions() bool {
	return len(r.Suggestions) > 0
}

// NewBuildResult creates a new build result
func NewBuildResult(conversationID string, workflow *GeneratedWorkflow, explanation string) *BuildResult {
	return &BuildResult{
		ConversationID: conversationID,
		Workflow:       workflow,
		Explanation:    explanation,
		Warnings:       []string{},
		Suggestions:    []string{},
	}
}

// GeneratedWorkflow represents a workflow generated by the AI builder
type GeneratedWorkflow struct {
	Name        string              `json:"name"`
	Description string              `json:"description,omitempty"`
	Definition  *WorkflowDefinition `json:"definition"`
}

// Validate validates the generated workflow
func (w *GeneratedWorkflow) Validate() error {
	if w.Name == "" {
		return errors.New("name is required")
	}
	if w.Definition == nil {
		return errors.New("definition is required")
	}
	return w.Definition.Validate()
}

// WorkflowDefinition represents the structure of a generated workflow
type WorkflowDefinition struct {
	Nodes []GeneratedNode `json:"nodes"`
	Edges []GeneratedEdge `json:"edges,omitempty"`
}

// Validate validates the workflow definition
func (d *WorkflowDefinition) Validate() error {
	if len(d.Nodes) == 0 {
		return errors.New("at least one node is required")
	}

	nodeIDs := make(map[string]bool)
	for _, node := range d.Nodes {
		if err := node.Validate(); err != nil {
			return err
		}
		if nodeIDs[node.ID] {
			return fmt.Errorf("duplicate node id: %s", node.ID)
		}
		nodeIDs[node.ID] = true
	}

	for _, edge := range d.Edges {
		if err := edge.Validate(); err != nil {
			return err
		}
		if !nodeIDs[edge.Source] {
			return fmt.Errorf("edge source node not found: %s", edge.Source)
		}
		if !nodeIDs[edge.Target] {
			return fmt.Errorf("edge target node not found: %s", edge.Target)
		}
	}

	return nil
}

// GeneratedNode represents a node in the generated workflow
type GeneratedNode struct {
	ID          string          `json:"id"`
	Type        string          `json:"type"`
	Name        string          `json:"name"`
	Description string          `json:"description,omitempty"`
	Config      json.RawMessage `json:"config,omitempty"`
	Position    *NodePosition   `json:"position,omitempty"`
}

// Validate validates the generated node
func (n *GeneratedNode) Validate() error {
	if n.ID == "" {
		return errors.New("node id is required")
	}
	if n.Type == "" {
		return errors.New("node type is required")
	}
	if n.Name == "" {
		return errors.New("node name is required")
	}
	return nil
}

// NodePosition represents the position of a node on the canvas
type NodePosition struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

// GeneratedEdge represents an edge in the generated workflow
type GeneratedEdge struct {
	ID           string `json:"id"`
	Source       string `json:"source"`
	Target       string `json:"target"`
	SourceHandle string `json:"sourceHandle,omitempty"`
	TargetHandle string `json:"targetHandle,omitempty"`
	Label        string `json:"label,omitempty"`
}

// Validate validates the generated edge
func (e *GeneratedEdge) Validate() error {
	if e.ID == "" {
		return errors.New("edge id is required")
	}
	if e.Source == "" {
		return errors.New("edge source is required")
	}
	if e.Target == "" {
		return errors.New("edge target is required")
	}
	if e.Source == e.Target {
		return errors.New("edge cannot reference the same node")
	}
	return nil
}

// Conversation represents a multi-turn conversation for workflow building
type Conversation struct {
	ID              string                `json:"id" db:"id"`
	TenantID        string                `json:"tenant_id" db:"tenant_id"`
	UserID          string                `json:"user_id" db:"user_id"`
	Status          ConversationStatus    `json:"status" db:"status"`
	CurrentWorkflow *GeneratedWorkflow    `json:"current_workflow,omitempty" db:"-"`
	Messages        []ConversationMessage `json:"messages" db:"-"`
	CreatedAt       time.Time             `json:"created_at" db:"created_at"`
	UpdatedAt       time.Time             `json:"updated_at" db:"updated_at"`
}

// NewConversation creates a new conversation
func NewConversation(tenantID, userID string) *Conversation {
	now := time.Now()
	return &Conversation{
		ID:        uuid.New().String(),
		TenantID:  tenantID,
		UserID:    userID,
		Status:    ConversationStatusActive,
		Messages:  []ConversationMessage{},
		CreatedAt: now,
		UpdatedAt: now,
	}
}

// AddMessage adds a message to the conversation
func (c *Conversation) AddMessage(role MessageRole, content string) *ConversationMessage {
	msg := ConversationMessage{
		ID:        uuid.New().String(),
		Role:      role,
		Content:   content,
		CreatedAt: time.Now(),
	}
	c.Messages = append(c.Messages, msg)
	c.UpdatedAt = time.Now()
	return &msg
}

// GetLastMessage returns the last message in the conversation
func (c *Conversation) GetLastMessage() *ConversationMessage {
	if len(c.Messages) == 0 {
		return nil
	}
	return &c.Messages[len(c.Messages)-1]
}

// GetMessagesByRole returns all messages with the specified role
func (c *Conversation) GetMessagesByRole(role MessageRole) []ConversationMessage {
	var messages []ConversationMessage
	for _, msg := range c.Messages {
		if msg.Role == role {
			messages = append(messages, msg)
		}
	}
	return messages
}

// IsActive returns true if the conversation is active
func (c *Conversation) IsActive() bool {
	return c.Status == ConversationStatusActive
}

// Complete marks the conversation as completed
func (c *Conversation) Complete() {
	c.Status = ConversationStatusCompleted
	c.UpdatedAt = time.Now()
}

// Abandon marks the conversation as abandoned
func (c *Conversation) Abandon() {
	c.Status = ConversationStatusAbandoned
	c.UpdatedAt = time.Now()
}

// SetCurrentWorkflow sets the current workflow for the conversation
func (c *Conversation) SetCurrentWorkflow(workflow *GeneratedWorkflow) {
	c.CurrentWorkflow = workflow
	c.UpdatedAt = time.Now()
}

// ConversationMessage represents a message in a conversation
type ConversationMessage struct {
	ID               string             `json:"id" db:"id"`
	ConversationID   string             `json:"conversation_id,omitempty" db:"conversation_id"`
	Role             MessageRole        `json:"role" db:"role"`
	Content          string             `json:"content" db:"content"`
	Workflow         *GeneratedWorkflow `json:"workflow,omitempty" db:"-"`
	PromptTokens     int                `json:"prompt_tokens,omitempty" db:"prompt_tokens"`
	CompletionTokens int                `json:"completion_tokens,omitempty" db:"completion_tokens"`
	CreatedAt        time.Time          `json:"created_at" db:"created_at"`
}

// RefineRequest represents a request to refine an existing workflow
type RefineRequest struct {
	ConversationID string `json:"conversation_id"`
	Message        string `json:"message"`
}

// Validate validates the refine request
func (r *RefineRequest) Validate() error {
	if r.ConversationID == "" {
		return errors.New("conversation_id is required")
	}
	if r.Message == "" {
		return errors.New("message is required")
	}
	return nil
}

// ApplyRequest represents a request to apply (create) a generated workflow
type ApplyRequest struct {
	ConversationID string `json:"conversation_id"`
	WorkflowName   string `json:"workflow_name,omitempty"`
}

// Validate validates the apply request
func (r *ApplyRequest) Validate() error {
	if r.ConversationID == "" {
		return errors.New("conversation_id is required")
	}
	return nil
}

// Service interface for AI workflow builder
type Service interface {
	// Generate creates a new workflow from a description
	Generate(ctx interface{}, tenantID string, request *BuildRequest) (*BuildResult, error)

	// Refine modifies an existing workflow based on feedback
	Refine(ctx interface{}, tenantID string, request *RefineRequest) (*BuildResult, error)

	// GetConversation retrieves a conversation by ID
	GetConversation(ctx interface{}, tenantID, conversationID string) (*Conversation, error)

	// ListConversations lists all conversations for a tenant/user
	ListConversations(ctx interface{}, tenantID, userID string) ([]*Conversation, error)

	// Apply creates a real workflow from a generated workflow
	Apply(ctx interface{}, tenantID string, request *ApplyRequest) (string, error)

	// AbandonConversation marks a conversation as abandoned
	AbandonConversation(ctx interface{}, tenantID, conversationID string) error
}

// Repository interface for conversation persistence
type Repository interface {
	// CreateConversation creates a new conversation
	CreateConversation(ctx interface{}, conv *Conversation) error

	// GetConversation retrieves a conversation by ID
	GetConversation(ctx interface{}, tenantID, conversationID string) (*Conversation, error)

	// UpdateConversation updates a conversation
	UpdateConversation(ctx interface{}, conv *Conversation) error

	// ListConversations lists conversations for a tenant/user
	ListConversations(ctx interface{}, tenantID, userID string, limit, offset int) ([]*Conversation, error)

	// CreateMessage creates a new message
	CreateMessage(ctx interface{}, msg *ConversationMessage) error

	// GetMessages retrieves messages for a conversation
	GetMessages(ctx interface{}, conversationID string) ([]ConversationMessage, error)

	// UpdateConversationWorkflow updates the current workflow for a conversation
	UpdateConversationWorkflow(ctx interface{}, conversationID string, workflow *GeneratedWorkflow) error
}

// Generator interface for LLM-based workflow generation
type Generator interface {
	// Generate generates a workflow from a description
	Generate(ctx interface{}, request *BuildRequest, history []ConversationMessage) (*GeneratedWorkflow, string, error)

	// Refine refines a workflow based on feedback
	Refine(ctx interface{}, workflow *GeneratedWorkflow, feedback string, history []ConversationMessage) (*GeneratedWorkflow, string, error)
}
