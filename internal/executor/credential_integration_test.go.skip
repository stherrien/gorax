package executor

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
	"github.com/rflow/rflow/internal/credential"
	"github.com/rflow/rflow/internal/workflow"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestE2E_WorkflowWithCredentialInjection tests end-to-end workflow execution with credential injection
func TestE2E_WorkflowWithCredentialInjection(t *testing.T) {
	// Setup test database
	db, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()

	// Setup services
	workflowRepo := workflow.NewRepository(db)
	credentialRepo := credential.NewRepository(db)

	// Create encryption service (simple for testing)
	masterKey := make([]byte, 32)
	for i := range masterKey {
		masterKey[i] = byte(i)
	}
	encryptionSvc, err := credential.NewSimpleEncryptionService(masterKey)
	require.NoError(t, err)

	// Create credential injector
	injector := credential.NewInjector(credentialRepo, encryptionSvc)

	// Create executor with credential support
	executor := NewWithCredentials(workflowRepo, nil, nil, injector)

	// Test data
	tenantID := "tenant-123"
	userID := "user-456"
	workflowID := "wf-789"
	apiToken := "secret-api-token-12345"

	// Step 1: Create a credential
	encrypted, err := encryptionSvc.Encrypt(tenantID, apiToken)
	require.NoError(t, err)

	cred := &credential.Credential{
		ID:                  "cred-1",
		TenantID:            tenantID,
		Name:                "api_token",
		Description:         "API token for external service",
		Type:                "api_key",
		EncryptedDEK:        encrypted.EncryptedDEK,
		Ciphertext:          encrypted.Ciphertext,
		Nonce:               encrypted.Nonce,
		AuthTag:             encrypted.AuthTag,
		EncryptionAlgorithm: "AES-256-GCM",
		KMSKeyID:            encrypted.KMSKeyID,
		Version:             1,
		IsCurrent:           true,
		CreatedBy:           userID,
		CreatedAt:           time.Now(),
		UpdatedAt:           time.Now(),
	}

	err = credentialRepo.Create(ctx, cred)
	require.NoError(t, err)

	// Step 2: Create workflow that references the credential
	workflowDef := workflow.WorkflowDefinition{
		Nodes: []workflow.Node{
			{
				ID:   "trigger-1",
				Type: "trigger:webhook",
				Position: workflow.Position{X: 0, Y: 0},
				Data: workflow.NodeData{
					Name:   "Webhook Trigger",
					Config: json.RawMessage(`{}`),
				},
			},
			{
				ID:   "http-1",
				Type: "action:http",
				Position: workflow.Position{X: 200, Y: 0},
				Data: workflow.NodeData{
					Name: "HTTP Request with Credential",
					Config: json.RawMessage(`{
						"method": "GET",
						"url": "https://api.example.com/data",
						"headers": {
							"Authorization": "Bearer {{credentials.api_token}}"
						}
					}`),
				},
			},
		},
		Edges: []workflow.Edge{
			{
				ID:     "edge-1",
				Source: "trigger-1",
				Target: "http-1",
			},
		},
	}

	defJSON, err := json.Marshal(workflowDef)
	require.NoError(t, err)

	wf := &workflow.Workflow{
		ID:          workflowID,
		TenantID:    tenantID,
		Name:        "Test Workflow with Credentials",
		Description: "Test workflow",
		Definition:  defJSON,
		Status:      "active",
		Version:     1,
		CreatedBy:   userID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	err = workflowRepo.Create(ctx, wf)
	require.NoError(t, err)

	// Step 3: Create execution
	triggerData := json.RawMessage(`{"test": "data"}`)
	execution, err := workflowRepo.CreateExecution(ctx, workflowID, tenantID, "webhook", &triggerData)
	require.NoError(t, err)

	// Step 4: Execute workflow (this should inject credentials)
	err = executor.Execute(ctx, execution)

	// Step 5: Verify execution succeeded
	assert.NoError(t, err)

	// Step 6: Retrieve execution to check final status
	updatedExec, err := workflowRepo.GetExecutionByID(ctx, execution.ID)
	require.NoError(t, err)
	assert.Equal(t, workflow.ExecutionStatusCompleted, updatedExec.Status)

	// Step 7: Verify credential was accessed (audit log)
	accessLogs, err := credentialRepo.GetAccessLog(ctx, tenantID, cred.ID, 10)
	require.NoError(t, err)
	assert.NotEmpty(t, accessLogs)
	assert.True(t, accessLogs[0].Success)
	assert.Equal(t, "read", accessLogs[0].Action)

	// Step 8: Verify credential value does NOT appear in execution logs
	// (This would require checking step execution outputs)
	// For now, we verify the workflow executed successfully
}

// TestE2E_WorkflowWithMissingCredential tests that workflow fails when credential is missing
func TestE2E_WorkflowWithMissingCredential(t *testing.T) {
	// Setup test database
	db, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()

	// Setup services
	workflowRepo := workflow.NewRepository(db)
	credentialRepo := credential.NewRepository(db)

	// Create encryption service
	masterKey := make([]byte, 32)
	encryptionSvc, err := credential.NewSimpleEncryptionService(masterKey)
	require.NoError(t, err)

	// Create credential injector
	injector := credential.NewInjector(credentialRepo, encryptionSvc)

	// Create executor with credential support
	executor := NewWithCredentials(workflowRepo, nil, nil, injector)

	// Test data
	tenantID := "tenant-123"
	userID := "user-456"
	workflowID := "wf-missing-cred"

	// Create workflow that references a non-existent credential
	workflowDef := workflow.WorkflowDefinition{
		Nodes: []workflow.Node{
			{
				ID:   "trigger-1",
				Type: "trigger:webhook",
				Position: workflow.Position{X: 0, Y: 0},
				Data: workflow.NodeData{
					Name:   "Webhook Trigger",
					Config: json.RawMessage(`{}`),
				},
			},
			{
				ID:   "http-1",
				Type: "action:http",
				Position: workflow.Position{X: 200, Y: 0},
				Data: workflow.NodeData{
					Name: "HTTP Request",
					Config: json.RawMessage(`{
						"method": "GET",
						"url": "https://api.example.com/data",
						"headers": {
							"Authorization": "Bearer {{credentials.missing_token}}"
						}
					}`),
				},
			},
		},
		Edges: []workflow.Edge{
			{
				ID:     "edge-1",
				Source: "trigger-1",
				Target: "http-1",
			},
		},
	}

	defJSON, err := json.Marshal(workflowDef)
	require.NoError(t, err)

	wf := &workflow.Workflow{
		ID:          workflowID,
		TenantID:    tenantID,
		Name:        "Test Workflow with Missing Credential",
		Description: "Test workflow",
		Definition:  defJSON,
		Status:      "active",
		Version:     1,
		CreatedBy:   userID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	err = workflowRepo.Create(ctx, wf)
	require.NoError(t, err)

	// Create execution
	triggerData := json.RawMessage(`{"test": "data"}`)
	execution, err := workflowRepo.CreateExecution(ctx, workflowID, tenantID, "webhook", &triggerData)
	require.NoError(t, err)

	// Execute workflow (should fail)
	err = executor.Execute(ctx, execution)

	// Verify execution failed
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "credential not found")

	// Verify execution status is failed
	updatedExec, err := workflowRepo.GetExecutionByID(ctx, execution.ID)
	require.NoError(t, err)
	assert.Equal(t, workflow.ExecutionStatusFailed, updatedExec.Status)
}

// TestE2E_WorkflowWithExpiredCredential tests that workflow fails when credential is expired
func TestE2E_WorkflowWithExpiredCredential(t *testing.T) {
	// Setup test database
	db, cleanup := setupTestDB(t)
	defer cleanup()

	ctx := context.Background()

	// Setup services
	workflowRepo := workflow.NewRepository(db)
	credentialRepo := credential.NewRepository(db)

	// Create encryption service
	masterKey := make([]byte, 32)
	encryptionSvc, err := credential.NewSimpleEncryptionService(masterKey)
	require.NoError(t, err)

	// Create credential injector
	injector := credential.NewInjector(credentialRepo, encryptionSvc)

	// Create executor
	executor := NewWithCredentials(workflowRepo, nil, nil, injector)

	// Test data
	tenantID := "tenant-123"
	userID := "user-456"
	workflowID := "wf-expired-cred"
	apiToken := "expired-token"

	// Create an expired credential
	encrypted, err := encryptionSvc.Encrypt(tenantID, apiToken)
	require.NoError(t, err)

	expiredTime := time.Now().Add(-1 * time.Hour) // Expired 1 hour ago
	cred := &credential.Credential{
		ID:                  "cred-expired",
		TenantID:            tenantID,
		Name:                "expired_token",
		Description:         "Expired API token",
		Type:                "api_key",
		EncryptedDEK:        encrypted.EncryptedDEK,
		Ciphertext:          encrypted.Ciphertext,
		Nonce:               encrypted.Nonce,
		AuthTag:             encrypted.AuthTag,
		EncryptionAlgorithm: "AES-256-GCM",
		KMSKeyID:            encrypted.KMSKeyID,
		Version:             1,
		IsCurrent:           true,
		ExpiresAt:           &expiredTime,
		CreatedBy:           userID,
		CreatedAt:           time.Now(),
		UpdatedAt:           time.Now(),
	}

	err = credentialRepo.Create(ctx, cred)
	require.NoError(t, err)

	// Create workflow
	workflowDef := workflow.WorkflowDefinition{
		Nodes: []workflow.Node{
			{
				ID:   "trigger-1",
				Type: "trigger:webhook",
				Position: workflow.Position{X: 0, Y: 0},
				Data: workflow.NodeData{
					Name:   "Webhook Trigger",
					Config: json.RawMessage(`{}`),
				},
			},
			{
				ID:   "http-1",
				Type: "action:http",
				Position: workflow.Position{X: 200, Y: 0},
				Data: workflow.NodeData{
					Name: "HTTP Request",
					Config: json.RawMessage(`{
						"method": "GET",
						"url": "https://api.example.com/data",
						"headers": {
							"Authorization": "Bearer {{credentials.expired_token}}"
						}
					}`),
				},
			},
		},
		Edges: []workflow.Edge{
			{
				ID:     "edge-1",
				Source: "trigger-1",
				Target: "http-1",
			},
		},
	}

	defJSON, err := json.Marshal(workflowDef)
	require.NoError(t, err)

	wf := &workflow.Workflow{
		ID:          workflowID,
		TenantID:    tenantID,
		Name:        "Test Workflow with Expired Credential",
		Description: "Test workflow",
		Definition:  defJSON,
		Status:      "active",
		Version:     1,
		CreatedBy:   userID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	err = workflowRepo.Create(ctx, wf)
	require.NoError(t, err)

	// Create execution
	triggerData := json.RawMessage(`{"test": "data"}`)
	execution, err := workflowRepo.CreateExecution(ctx, workflowID, tenantID, "webhook", &triggerData)
	require.NoError(t, err)

	// Execute workflow (should fail)
	err = executor.Execute(ctx, execution)

	// Verify execution failed
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "expired")

	// Verify execution status is failed
	updatedExec, err := workflowRepo.GetExecutionByID(ctx, execution.ID)
	require.NoError(t, err)
	assert.Equal(t, workflow.ExecutionStatusFailed, updatedExec.Status)
}

// setupTestDB creates a test database connection
func setupTestDB(t *testing.T) (*sqlx.DB, func()) {
	// This should connect to your test database
	// For now, skip if not available
	t.Skip("Skipping E2E test - requires test database setup")

	db, err := sqlx.Connect("postgres", "postgres://user:pass@localhost/testdb?sslmode=disable")
	require.NoError(t, err)

	cleanup := func() {
		// Clean up test data
		db.Exec("DELETE FROM step_executions WHERE 1=1")
		db.Exec("DELETE FROM executions WHERE 1=1")
		db.Exec("DELETE FROM workflows WHERE 1=1")
		db.Exec("DELETE FROM credentials WHERE 1=1")
		db.Exec("DELETE FROM credential_access_log WHERE 1=1")
		db.Close()
	}

	return db, cleanup
}
